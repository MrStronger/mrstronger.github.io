<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="莫凡的个人博客"><title>窥探React-源码分析(二)-组件的初始渲染 | 莫凡</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"></head><body><div class="body_container"><div id="header"><div class="site-name"><a id="logo" href="/."><img src="http://ot6vbgl2y.bkt.clouddn.com/18-2-12/7859845.jpg" class="logoImg"><span id="hidden">窥探React-源码分析(二)-组件的初始渲染</span></a></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">窥探React-源码分析(二)-组件的初始渲染</h1><div class="post-meta"><a href="/2018/03/17/窥探React-源码分析(二)-组件的初始渲染/#comments" class="comment-count"></a><p><span class="date">Mar 17, 2018</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>上一篇文章讲到了React 调用<code>ReactDOM.render</code>首次渲染组件的<strong>前几个过程</strong>的源码, 包括创建元素、根据元素实例化对应组件, 利用事务来进行批量更新. 我们还穿插介绍了React 事务的实现以及如何利用事务进行批量更新的实现. 这篇文章我们接着分析后面的过程, 包括调用了哪些事务, 组件插入的过程, 组件生命周期方法什么时候被调用等.</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在React 源码中, 首次渲染组件有一个重要的过程, <code>mount</code>, 插入,  即插入到DOM中, 发生在实例化组件之后. 这是一个不断生成(render)不断插入、类似递归的过程. 让我们一步一步来分析.</p>
<h3 id="使用事务执行插入过程"><a href="#使用事务执行插入过程" class="headerlink" title="使用事务执行插入过程"></a>使用事务执行插入过程</h3><p>我们来看首先在插入之前的准备, ReactMount.js中, <code>batchedMountComponentIntoNode</code>被放到了批量策略<code>batchedUpdates</code>中执行, batchedMountComponentIntoNode 函数正是执行插入过程的第一步</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 放在批量策略batchedUpdates中执行插入</span></span><br><span class="line">ReactUpdates.batchedUpdates(</span><br><span class="line">    batchedMountComponentIntoNode,</span><br><span class="line">    componentInstance,</span><br><span class="line">    ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这个<code>batchingStrategy</code>就是<code>ReactDefaultBatchingStrategy</code>, 因此调用了<code>ReactDefaultBatchingStrategy</code>的<code>batchedUpdates</code>, 并将<code>batchedMountComponentIntoNode</code>当作callback. </p>
<p>在ReactDefaultBatchingStrategy.js中启动了<code>ReactDefaultBatchingStrategyTransaction</code>事务去执行<code>batchedMountComponentIntoNode</code>, 以便利用策略控制更新, 而在这个函数中又启动了一个调和(Reconcile)事务, 执行<code>mountComponentIntoNode</code>进行插入. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReactDefaultBatchingStrategy.js</span></span><br><span class="line"><span class="keyword">var</span> transaction = <span class="keyword">new</span> ReactDefaultBatchingStrategyTransaction();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> ReactDefaultBatchingStrategy = &#123;</span><br><span class="line">  ...</span><br><span class="line">  batchedUpdates: <span class="function"><span class="keyword">function</span>(<span class="params">callback, a, b, c, d, e</span>) </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">    <span class="comment">// 启动ReactDefaultBatchingStrategy事务</span></span><br><span class="line">      <span class="keyword">return</span> transaction.perform(callback, <span class="literal">null</span>, a, b, c, d, e);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReactMount.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">batchedMountComponentIntoNode</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  ...</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> transaction = ReactUpdates.ReactReconcileTransaction.getPooled(</span><br><span class="line">    !shouldReuseMarkup &amp;&amp; ReactDOMFeatureFlags.useCreateElement,</span><br><span class="line">  );</span><br><span class="line">    <span class="comment">// 启动Reconcile事务</span></span><br><span class="line">  transaction.perform(</span><br><span class="line">    mountComponentIntoNode,</span><br><span class="line">    ...</span><br><span class="line">  );</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相信你注意到了 <code>ReactUpdates.ReactReconcileTransaction.getPooled</code>, 这个函数的作用就是从对象池里拿到ReactReconcileTransaction 对象重用.</p>
<h3 id="React优化策略——对象池"><a href="#React优化策略——对象池" class="headerlink" title="React优化策略——对象池"></a>React优化策略——对象池</h3><p>在ReactMount.js :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">batchedMountComponentIntoNode</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  componentInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  container,</span></span></span><br><span class="line"><span class="function"><span class="params">  shouldReuseMarkup,</span></span></span><br><span class="line"><span class="function"><span class="params">  context,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 从对象池中拿到ReactReconcileTransaction事务</span></span><br><span class="line">  <span class="keyword">var</span> transaction = ReactUpdates.ReactReconcileTransaction.getPooled(</span><br><span class="line">    !shouldReuseMarkup &amp;&amp; ReactDOMFeatureFlags.useCreateElement,</span><br><span class="line">  );</span><br><span class="line">    <span class="comment">// 启动事务执行mountComponentIntoNode</span></span><br><span class="line">  transaction.perform(</span><br><span class="line">    mountComponentIntoNode,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    componentInstance,</span><br><span class="line">    container,</span><br><span class="line">    transaction,</span><br><span class="line">    shouldReuseMarkup,</span><br><span class="line">    context,</span><br><span class="line">  );</span><br><span class="line">    <span class="comment">// 释放事务</span></span><br><span class="line">  ReactUpdates.ReactReconcileTransaction.release(transaction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>React 在启动另一个事务之前拿到了这个事务, 从哪里拿到的呢? 这里就涉及到了React 优化策略之一——对象池</p>
<h4 id="GC很慢"><a href="#GC很慢" class="headerlink" title="GC很慢"></a>GC很慢</h4><p>首先你用JavaScript声明的变量不再使用时, js引擎会在某些时间回收它们, 这个回收时间是耗时的. <a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/45361.pdf" target="_blank" rel="noopener">资料显示</a>: </p>
<blockquote>
<p>Marking latency depends on the number of live objects that have to be marked, with marking of the whole heap potentially taking more than <strong>100 ms</strong> for large webpages. </p>
</blockquote>
<p>整个堆的标记对于大型网页很可能需要超过100毫秒 </p>
<p>尽管V8引擎对垃圾回收有优化, 但为了避免重复创建临时对象造成GC不断启动以及复用对象, React使用了对象池来复用对象, 对GC表明, 我一直在使用它们, 请不要启动回收.  </p>
<p>React 实现的对象池其实就是对类进行了包装, 给类添加一个实例队列, 用时取, 不用时再放回, 防止重复实例化:</p>
<p>PooledClass.js :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加对象池, 实质就是对类包装</span></span><br><span class="line"><span class="keyword">var</span> addPoolingTo = <span class="function"><span class="keyword">function</span> (<span class="params">CopyConstructor, pooler</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 拿到类</span></span><br><span class="line">  <span class="keyword">var</span> NewKlass = CopyConstructor;</span><br><span class="line">  <span class="comment">// 添加实例队列属性</span></span><br><span class="line">  NewKlass.instancePool = [];</span><br><span class="line">  <span class="comment">// 添加拿到实例方法</span></span><br><span class="line">  NewKlass.getPooled = pooler || DEFAULT_POOLER;</span><br><span class="line">  <span class="comment">// 实例队列默认为10个</span></span><br><span class="line">  <span class="keyword">if</span> (!NewKlass.poolSize) &#123;</span><br><span class="line">    NewKlass.poolSize = DEFAULT_POOL_SIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将实例放回队列</span></span><br><span class="line">  NewKlass.release = standardReleaser;</span><br><span class="line">  <span class="keyword">return</span> NewKlass;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 从对象池申请一个实例.对于不同参数数量的类,React分别处理, 这里是一个参数的类的申请实例的方法, 其他一样</span></span><br><span class="line"><span class="keyword">var</span> oneArgumentPooler = <span class="function"><span class="keyword">function</span>(<span class="params">copyFieldsFrom</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// this 指的就是传进来的类</span></span><br><span class="line">  <span class="keyword">var</span> Klass = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// 如果类的实例队列有实例, 则拿出来一个</span></span><br><span class="line">  <span class="keyword">if</span> (Klass.instancePool.length) &#123;</span><br><span class="line">    <span class="keyword">var</span> instance = Klass.instancePool.pop();</span><br><span class="line">    Klass.call(instance, copyFieldsFrom);</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则说明是第一次实例化, new 一个</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Klass(copyFieldsFrom);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 释放实例到类的队列中</span></span><br><span class="line"><span class="keyword">var</span> standardReleaser = <span class="function"><span class="keyword">function</span>(<span class="params">instance</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> Klass = <span class="keyword">this</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 调用类的解构函数</span></span><br><span class="line">  instance.destructor();</span><br><span class="line">  <span class="comment">// 放到队列</span></span><br><span class="line">  <span class="keyword">if</span> (Klass.instancePool.length &lt; Klass.poolSize) &#123;</span><br><span class="line">    Klass.instancePool.push(instance);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用时将类传进去即可</span></span><br><span class="line">PooledClass.addPoolingTo(ReactReconcileTransaction);</span><br></pre></td></tr></table></figure>
<p>可以看到, React对象池就是给类维护一个实例队列, 用到就pop一个, 不用就push回去. 在React源码中, 用完实例后要立即释放, 也就是申请和释放成对出现, 达到优化性能的目的.</p>
<h3 id="插入过程"><a href="#插入过程" class="headerlink" title="插入过程"></a>插入过程</h3><p>在ReactMount.js中, <code>mountComponentIntoNode</code>函数执行了组件实例的<code>mountComponent</code>, 不同的组件实例有自己的mountComponent方法, 做的也是不同的事情. (源码我就不上了, 太TM…)</p>
<p>ReactCompositeComponent类型的mountComponent方法: </p>
<p><img src="http://ot6vbgl2y.bkt.clouddn.com/18-3-10/31947198.jpg" alt=""></p>
<p>ReactDOMComponent类型:</p>
<p><img src="http://ot6vbgl2y.bkt.clouddn.com/18-3-11/88934047.jpg" alt=""></p>
<p>ReactDOMTextComponent类型:</p>
<p><img src="http://ot6vbgl2y.bkt.clouddn.com/18-3-11/27440744.jpg" alt=""></p>
<p>整个mount过程是递归渲染的(<a href="https://www.processon.com/view/link/5a7dad5be4b0615ac054a703" target="_blank" rel="noopener">矢量图</a>): </p>
<p><img src="http://ot6vbgl2y.bkt.clouddn.com/18-3-17/27933899.jpg" alt=""></p>
<p>刚开始, React给要渲染的组件从最顶层加了一个ReactCompositeComponent类型的 topLevelWrapper来方便的存储所有更新, 因此初次递归是从 ReactCompositeComponent 的<code>mountComponent</code> 开始的, 这个过程会调用组件的render函数(如果有的话), 根据render出来的elements再调用<code>instantiateReactComponent</code>实例化不同类型的组件, 再调用组件的 <code>mountComponent</code>, 因此这是一个不断渲染不断插入、递归的过程.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>React 初始渲染主要分为以下几个步骤:</p>
<ol>
<li>构建一个组件的elements tree(subtree)—— 从组件嵌套的最里层(转换JSX后最里层的createElements函数)开始层层调用<code>createElements</code>创建这个组件elements tree. 在这个subtree中, 里层创建出来的元素作为包裹层的props.children;</li>
<li>实例化组件——根据当前元素的类型创建对应类型的组件实例;</li>
<li>利用多种事务执行组件实例的<code>mountComponent</code>. <ol>
<li>首先执行topLevelWrapper(ReactCompositeComponent)的mountComponent;</li>
<li>ReactCompositeComponent的<code>mountComponent</code>过程中会先调用render(Composite类型 )生成组件的elements tree, 然后顺着props.children, 不断实例化, 不断调用各自组件的mountComponent 形成循环</li>
</ol>
</li>
<li>在以上过程中, 依靠事务进行存储更新、回调队列, 在事务结束时批量更新.  </li>
</ol>
</div><div class="tags"><a href="/tags/React/">React</a><a href="/tags/源码分析/">源码分析</a></div><div class="post-share"></div><div class="post-nav"><a href="/2018/04/17/窥探React-源码分析-三-全面剖析组件更新机制/" class="pre">窥探React-源码分析(三)-全面剖析组件更新机制</a><a href="/2018/02/11/窥探React-源码分析(一)-调用ReactDOM.render后发生了什么/" class="next">窥探React-源码分析(一)-调用ReactDOM.render后发生了什么</a></div><div id="comments"><div id="container"></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="React"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#正文"><span class="toc-text">正文</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用事务执行插入过程"><span class="toc-text">使用事务执行插入过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React优化策略——对象池"><span class="toc-text">React优化策略——对象池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GC很慢"><span class="toc-text">GC很慢</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#插入过程"><span class="toc-text">插入过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/04/17/窥探React-源码分析-三-全面剖析组件更新机制/">窥探React-源码分析(三)-全面剖析组件更新机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/17/窥探React-源码分析(二)-组件的初始渲染/">窥探React-源码分析(二)-组件的初始渲染</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/11/窥探React-源码分析(一)-调用ReactDOM.render后发生了什么/">窥探React-源码分析(一)-调用ReactDOM.render后发生了什么</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/21/认识node核心模块-网络编程/">认识node核心模块--网络编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/10/认识node核心模块-从Buffer、Stream到fs/">认识node核心模块--从Buffer、Stream到fs</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/03/认识node核心模块-深入EventEmitter/">认识node核心模块--深入EventEmitter</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/25/认识node核心模块-全局对象及Cluster/">认识node核心模块--全局对象及Cluster</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/14/node核心特性理解/">node核心特性理解</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/27/我对前端工程师这个职业的看法/">我对前端工程师这个职业的看法</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/21/浏览器中的事件循环机制/">浏览器中的事件循环机制</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/Redux/" style="font-size: 15px;">Redux</a> <a href="/tags/感想/" style="font-size: 15px;">感想</a> <a href="/tags/JavaScript函数/" style="font-size: 15px;">JavaScript函数</a> <a href="/tags/React/" style="font-size: 15px;">React</a> <a href="/tags/dva/" style="font-size: 15px;">dva</a> <a href="/tags/React架构/" style="font-size: 15px;">React架构</a> <a href="/tags/node/" style="font-size: 15px;">node</a> <a href="/tags/node基础/" style="font-size: 15px;">node基础</a> <a href="/tags/React基础/" style="font-size: 15px;">React基础</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/Redux-saga/" style="font-size: 15px;">Redux saga</a> <a href="/tags/前端工程师/" style="font-size: 15px;">前端工程师</a> <a href="/tags/职业规划/" style="font-size: 15px;">职业规划</a> <a href="/tags/JavaScript对象/" style="font-size: 15px;">JavaScript对象</a> <a href="/tags/事件循环机制/" style="font-size: 15px;">事件循环机制</a> <a href="/tags/源码分析/" style="font-size: 15px;">源码分析</a> <a href="/tags/实习/" style="font-size: 15px;">实习</a> <a href="/tags/面试题/" style="font-size: 15px;">面试题</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://mofan_tcg.coding.me/" title="时光笔记" target="_blank">时光笔记</a><ul></ul><a href="http://realtcg.com/Precious-Memories/" title="React小相册" target="_blank">React小相册</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p>你的梦想是这个世界上最伟大的事情</p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">mofan.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/MrStronger/hexo-theme-Mofan"> Mofan.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?3f3a5a8fd2b4cc3b3813fd00426fa25d";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment = new Gitment({
  id: '窥探React-源码分析(二)-组件的初始渲染', // 可选。默认为 location.href
  owner: 'MrStronger',
  repo: 'blogcomment',
  oauth: {
    client_id: '0a99d84bb46f7cda7fce',
    client_secret: 'b3915ea2a1e5364a698ec8335e34092ad6bc42d0',
  },
})
gitment.render('container')
</script></body></html>