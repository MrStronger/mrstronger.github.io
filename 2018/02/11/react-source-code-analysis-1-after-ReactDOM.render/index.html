<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="莫凡的个人博客"><title>React源码分析(一)-调用ReactDOM.render后发生了什么 | 莫凡</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"></head><body><div class="body_container"><div id="header"><div class="site-name"><a id="logo" href="/."><img src="http://ot6vbgl2y.bkt.clouddn.com/18-2-12/7859845.jpg" class="logoImg"><span id="hidden">React源码分析(一)-调用ReactDOM.render后发生了什么</span></a></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">React源码分析(一)-调用ReactDOM.render后发生了什么</h1><div class="post-meta"><a href="/2018/02/11/react-source-code-analysis-1-after-ReactDOM.render/#comments" class="comment-count"></a><p><span class="date">Feb 11, 2018</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>所谓知其然还要知其所以然. 本系列文章将分析 React 15-stable的部分源码, 包括组件初始渲染的过程、组件更新的过程等. 这篇文章先介绍组件初始渲染的过程的几个重要概念, 包括大致过程、创建元素、实例化组件、事务、批量更新策略等. 在这之前, 假设读者已经: </p>
<ul>
<li>对React有一定了解</li>
<li>知道React element、component、class区别</li>
<li>了解生命周期、事务、批量更新、virtual DOM大致概念等</li>
</ul>
<h4 id="如何分析-React-源码"><a href="#如何分析-React-源码" class="headerlink" title="如何分析 React 源码"></a>如何分析 React 源码</h4><p><strong>代码架构预览</strong></p>
<p>首先, 我们找到React在Github上的地址, 把<strong>15-stable版本</strong>的源码copy下来, 观察它的整体架构, 这里首先阅读关于源码介绍的<a href="https://reactjs.org/docs/codebase-overview.html" target="_blank" rel="noopener">官方文档</a>, 再接着看.</p>
<p>我们 要分析的源码在 src 目录下: </p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src 部分目录</span></span><br><span class="line"></span><br><span class="line">├── ReactVersion.js    <span class="meta"># React版本号</span></span><br><span class="line">├── addons             <span class="meta"># 插件</span></span><br><span class="line">├── isomorphic		   <span class="meta"># 同构代码,作为react-core, 提供顶级API</span></span><br><span class="line">├── node_modules</span><br><span class="line">├── package.json</span><br><span class="line">├── renderers          <span class="meta"># 渲染器, 包括DOM,Native,art,test等</span></span><br><span class="line">├── <span class="keyword">shared</span>             <span class="meta"># 子目录之间需要共享的代码,提到父级目录shared</span></span><br><span class="line">├── test			   <span class="meta"># 测试代码</span></span><br></pre></td></tr></table></figure>
<p><strong>分析方法</strong></p>
<p>1、首先看一些网上分析的文章, 对重点部分的源码有个印象, 知道一些关键词意思, 避免在无关的代码上迷惑、耗费时间;</p>
<p>2、准备一个demo, 无任何功能代码, 只安装react,react-dom, Babel转义包, 避免分析无关代码;</p>
<p>3、打debugger; 利用Chrome devtool一步一步走, 打断点, 看调用栈,看函数返回值, 看作用域变量值;</p>
<p>4、利用编辑器查找代码、阅读代码等</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>我们知道, 对于一般的React 应用, 浏览器会首先执行代码 <code>ReactDOM.render</code>来渲染顶层组件, 在这个过程中递归渲染嵌套的子组件, 最终所有组件被插入到DOM中. 我们来看看</p>
<h3 id="调用ReactDOM-render-发生了什么"><a href="#调用ReactDOM-render-发生了什么" class="headerlink" title="调用ReactDOM.render 发生了什么"></a>调用ReactDOM.render 发生了什么</h3><h4 id="大致过程-只展示主要的函数调用"><a href="#大致过程-只展示主要的函数调用" class="headerlink" title="大致过程(只展示主要的函数调用):"></a>大致过程(只展示主要的函数调用):</h4><p><img src="http://ot6vbgl2y.bkt.clouddn.com/18-4-23/71297891.jpg" alt="React 初始渲染"></p>
<p>如果看不清这有<a href="http://ot6vbgl2y.bkt.clouddn.com/18-4-23/71297891.jpg" target="_blank" rel="noopener">矢量图</a></p>
<h4 id="让我们来分析一下具体过程"><a href="#让我们来分析一下具体过程" class="headerlink" title="让我们来分析一下具体过程:"></a><strong>让我们来分析一下具体过程:</strong></h4><hr>
<h5 id="1、创建元素"><a href="#1、创建元素" class="headerlink" title="1、创建元素"></a><strong>1、创建元素</strong></h5><p>首先, 对于你写的jsx, Babel会把这种语法糖转义成这样: </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jsx</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;C /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转义后</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  React.createElement(C, <span class="literal">null</span>), </span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>没错, 就是调用<code>React.createElement</code>来创建元素. 元素是什么? 元素只是一个对象描述了DOM树, 它像这样: </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  $$<span class="keyword">typeof</span>: <span class="built_in">Symbol</span>(react.element)</span><br><span class="line">  key: <span class="literal">null</span></span><br><span class="line">  props: &#123;&#125;        <span class="comment">// props有child属性, 描述子组件, 同样是元素</span></span><br><span class="line">  ref: <span class="literal">null</span></span><br><span class="line">  type: <span class="class"><span class="keyword">class</span> <span class="title">C</span>    // <span class="title">type</span>可以是类(自定义组件)、函数(<span class="title">wrapper</span>)、<span class="title">string</span>(<span class="title">DOM</span>节点)</span></span><br><span class="line">  _owner: null</span><br><span class="line">  _store: &#123;<span class="attr">validated</span>: <span class="literal">false</span>&#125;</span><br><span class="line">  _self: <span class="literal">null</span></span><br><span class="line">  _source: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>React.createElement</code>源码在<code>ReactElement.js</code>中, 其他逻辑比较简单, 值得说的是props属性, 这个props属性里面包含的就是我们给组件传的各种属性: </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jsx</span></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">'container'</span>&gt;</span><br><span class="line">          <span class="string">"dscsdcsd"</span></span><br><span class="line">          &lt;i onClick=&#123;(e) =&gt; <span class="built_in">console</span>.log(e)&#125;&gt;&#123;<span class="keyword">this</span>.state.val&#125;&lt;<span class="regexp">/i&gt;</span></span><br><span class="line"><span class="regexp">          &lt;Children val=&#123;this.state.val&#125;/</span>&gt;</span><br><span class="line">	&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ bable 转义后</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ createElement(type, props, children)</span></span><br><span class="line"><span class="regexp">return React.createElement(</span></span><br><span class="line"><span class="regexp">    'div', &#123; className: 'container' &#125;, </span></span><br><span class="line"><span class="regexp">    '"dscsdcsd"',</span></span><br><span class="line"><span class="regexp">    React.createElement('i', &#123; onClick: e =&gt; console.log(e) &#125;, this.state.val),</span></span><br><span class="line"><span class="regexp">    React.createElement(Children, &#123; val: this.state.val &#125;)</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 对应的元素树</span></span><br><span class="line"><span class="regexp">&#123;</span></span><br><span class="line"><span class="regexp">  $$typeof: Symbol(react.element)</span></span><br><span class="line"><span class="regexp">  key: null</span></span><br><span class="line"><span class="regexp">  props: &#123;  /</span><span class="regexp">/ props有children属性, 描述子组件, 同样是元素</span></span><br><span class="line"><span class="regexp">    children: [</span></span><br><span class="line"><span class="regexp">      ""dscsdcsd"",</span></span><br><span class="line"><span class="regexp">      // 子元素</span></span><br><span class="line"><span class="regexp">	  &#123;$$typeof: Symbol(react.element), type: "i", key: null, ref: null, props: &#123;…&#125;, …&#125;,</span></span><br><span class="line"><span class="regexp">	  &#123;$$typeof: Symbol(react.element), type: class Children, props: &#123;…&#125;, …&#125;</span></span><br><span class="line"><span class="regexp">    ]</span></span><br><span class="line"><span class="regexp">    className: 'container'</span></span><br><span class="line"><span class="regexp">  &#125;  </span></span><br><span class="line"><span class="regexp">  ref: null</span></span><br><span class="line"><span class="regexp">  type: 'div'</span></span><br><span class="line"><span class="regexp">  _owner: null</span></span><br><span class="line"><span class="regexp">  _store: &#123;validated: false&#125;</span></span><br><span class="line"><span class="regexp">  _self: null</span></span><br><span class="line"><span class="regexp">  _source: null</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h5 id="2、创建对应类型的React组件"><a href="#2、创建对应类型的React组件" class="headerlink" title="2、创建对应类型的React组件"></a><strong>2、创建对应类型的React组件</strong></h5><p>创建出来的元素被当作参数和指定的 DOM container 一起传进<code>ReactDOM.render</code>. 接下来会调用一些内部方法, 接着调用了 <code>instantiateReactComponent</code>, 这个函数根据element的类型实例化对应的component.  当element的类型为:</p>
<ul>
<li>string时, 说明是文本, 创建<code>ReactDOMTextComponent</code>;</li>
<li>ReactElement时, 说明是react元素, 进一步判断element.type的类型, 当为<ul>
<li>string时, 为DOM原生节点, 创建<code>ReactDOMComponent</code>;</li>
<li>函数或类时, 为react 组件, 创建<code>ReactCompositeComponent</code></li>
</ul>
</li>
</ul>
<p><code>instantiateReactComponent</code>函数在instantiateReactComponent.js :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Given a ReactNode, create an instance that will actually be mounted.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instantiateReactComponent</span>(<span class="params">node(这里node指element</span>), <span class="title">shouldHaveDebugID</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果element为空</span></span><br><span class="line">  <span class="keyword">if</span> (node === <span class="literal">null</span> || node === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建空component</span></span><br><span class="line">    instance = ReactEmptyComponent.create(instantiateReactComponent);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> node === <span class="string">'object'</span>) &#123;  <span class="comment">// 如果是对象</span></span><br><span class="line">      ...     <span class="comment">// 这里是类型检查</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 如果element.type是字符串</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> element.type === <span class="string">'string'</span>) &#123;</span><br><span class="line">      <span class="comment">//实例化 宿主组件, 也就是DOM节点</span></span><br><span class="line">      instance = ReactHostComponent.createInternalComponent(element);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isInternalComponentType(element.type)) &#123;</span><br><span class="line">      <span class="comment">// 保留给以后版本使用，此处暂时不会涉及到</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则就实例化ReactCompositeComponent</span></span><br><span class="line">      instance = <span class="keyword">new</span> ReactCompositeComponentWrapper(element);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 如果element是string或number</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> node === <span class="string">'string'</span> || <span class="keyword">typeof</span> node === <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="comment">// 实例化ReactDOMTextComponent</span></span><br><span class="line">    instance = ReactHostComponent.createInstanceForText(node);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    invariant(<span class="literal">false</span>, <span class="string">'Encountered invalid React node of type %s'</span>, <span class="keyword">typeof</span> node);</span><br><span class="line">  &#125;</span><br><span class="line">   ...</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3、开启批量更新以应对可能的setState"><a href="#3、开启批量更新以应对可能的setState" class="headerlink" title="3、开启批量更新以应对可能的setState"></a><strong>3、开启批量更新以应对可能的setState</strong></h5><p>在调用<code>instantiateReactComponent</code>拿到组件实例后, React 接着调用了<code>batchingStrategy.batchedUpdates</code>并将组件实例当作参数执行批量更新(首次渲染为批量插入).</p>
<p>批量更新是一种优化策略, 避免重复渲染, 在很多框架都存在这种机制. 其实现要点是要弄清楚何时存储更新, 何时批量更新.</p>
<p>在React中, 批量更新受<code>batchingStrategy</code>控制,而这个策略除了server端都是<code>ReactDefaultBatchingStrategy</code>:</p>
<p>不信你看, 在ReactUpdates.js中 :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ReactUpdatesInjection = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 注入批量策略的函数声明</span></span><br><span class="line">  injectBatchingStrategy: <span class="function"><span class="keyword">function</span>(<span class="params">_batchingStrategy</span>) </span>&#123;</span><br><span class="line">    ... </span><br><span class="line">  </span><br><span class="line">    batchingStrategy = _batchingStrategy;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在ReactDefaultInjection.js中注入<code>ReactDefaultBatchingStrategy</code> :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy); <span class="comment">// 注入</span></span><br></pre></td></tr></table></figure>
<p>那么React是如何实现批量更新的? 在ReactDefaultBatchingStrategy.js我们看到, 它的实现依靠了<strong>事务</strong>. </p>
<h6 id="3-1-我们先介绍一下事务"><a href="#3-1-我们先介绍一下事务" class="headerlink" title="3.1 我们先介绍一下事务."></a>3.1 我们先介绍一下事务.</h6><p>在 Transaction.js中, React 介绍了事务: </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">* <span class="xml"><span class="tag">&lt;<span class="name">pre</span>&gt;</span></span></span><br><span class="line"><span class="xml"> *                       wrappers (injected at creation time)</span></span><br><span class="line"><span class="xml"> *                                      +        +</span></span><br><span class="line"><span class="xml"> *                                      |        |</span></span><br><span class="line"><span class="xml"> *                    +-----------------|--------|--------------+</span></span><br><span class="line"><span class="xml"> *                    |                 v        |              |</span></span><br><span class="line"><span class="xml"> *                    |      +---------------+   |              |</span></span><br><span class="line"><span class="xml"> *                    |   +--|    wrapper1   |---|----+         |</span></span><br><span class="line"><span class="xml"> *                    |   |  +---------------+   v    |         |</span></span><br><span class="line"><span class="xml"> *                    |   |          +-------------+  |         |</span></span><br><span class="line"><span class="xml"> *                    |   |     +----|   wrapper2  |--------+   |</span></span><br><span class="line"><span class="xml"> *                    |   |     |    +-------------+  |     |   |</span></span><br><span class="line"><span class="xml"> *                    |   |     |                     |     |   |</span></span><br><span class="line"><span class="xml"> *                    |   v     v                     v     v   | wrapper</span></span><br><span class="line"><span class="xml"> *                    | +---+ +---+   +---------+   +---+ +---+ | invariants</span></span><br><span class="line"><span class="xml"> * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained</span></span><br><span class="line"><span class="xml"> * +-----------------&gt;|-|---|-|---|--&gt;|anyMethod|---|---|-|---|-|--------&gt;</span></span><br><span class="line"><span class="xml"> *                    | |   | |   |   |         |   |   | |   | |</span></span><br><span class="line"><span class="xml"> *                    | |   | |   |   |         |   |   | |   | |</span></span><br><span class="line"><span class="xml"> *                    | |   | |   |   |         |   |   | |   | |</span></span><br><span class="line"><span class="xml"> *                    | +---+ +---+   +---------+   +---+ +---+ |</span></span><br><span class="line"><span class="xml"> *                    |  initialize                    close    |</span></span><br><span class="line"><span class="xml"> *                    +-----------------------------------------+</span></span><br><span class="line"><span class="xml"> * <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>React 把要调用的函数封装一层wrapper, 这个wrapper一般是一个对象, 里面有initialize方法, 在调用函数前调用;有close方法, 在函数执行后调用. 这样封装的目的是为了, 在要调用的函数<strong>执行前后某些不变性约束条件(invariant)仍然成立</strong>.  </p>
<p>这里的不变性约束条件(invariant), 我把它理解为 “真命题”, 因此前面那句话意思就是, 函数调用前后某些规则仍然成立. 比如, 在调和(reconciliation)前后保留UI组件一些状态.</p>
<p>React 中, 事务就像一个黑盒, 函数在这个黑盒里被执行, 执行前后某些规则仍然成立, 即使函数报错. 事务提供了函数执行的一个安全环境.</p>
<p>继续看Transaction.js对事务的抽象实现: </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事务的抽象实现, 作为基类</span></span><br><span class="line"><span class="keyword">var</span> TransactionImpl = &#123;</span><br><span class="line">  <span class="comment">// 初始化/重置实例属性, 给实例添加/重置几个属性, 实例化事务时会调用</span></span><br><span class="line">  reinitializeTransaction: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.transactionWrappers = <span class="keyword">this</span>.getTransactionWrappers();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.wrapperInitData) &#123;</span><br><span class="line">      <span class="keyword">this</span>.wrapperInitData.length = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.wrapperInitData = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>._isInTransaction = <span class="literal">false</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  _isInTransaction: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个函数会交给具体的事务实例化时定义, 初始设为null</span></span><br><span class="line">  getTransactionWrappers: <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 判断是否已经在这个事务中, 保证当前的Transaction正在perform的同时不会再次被perform</span></span><br><span class="line">  isInTransaction: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !!<span class="keyword">this</span>._isInTransaction;</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 顶级API, 事务的主要实现, 用来在安全的窗口下执行函数</span></span><br><span class="line">  perform: <span class="function"><span class="keyword">function</span> (<span class="params">method, scope, a, b, c, d, e, f</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ret;</span><br><span class="line">    <span class="keyword">var</span> errorThrown;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>._isInTransaction = <span class="literal">true</span>;</span><br><span class="line">      errorThrown = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">this</span>.initializeAll(<span class="number">0</span>);  <span class="comment">// 调用所有wrapper的initialize方法</span></span><br><span class="line">      ret = method.call(scope, a, b, c, d, e, f); <span class="comment">// 调用要执行的函数</span></span><br><span class="line">      errorThrown = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 调用所有wrapper的close方法, 利用errorThrown标志位保证只捕获函数执行时的错误, 对initialize	  // 和close抛出的错误不做处理</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (errorThrown) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.closeAll(<span class="number">0</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (err) &#123;&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.closeAll(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>._isInTransaction = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;,</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 调用所有wrapper的initialize方法的函数定义</span></span><br><span class="line">  initializeAll: <span class="function"><span class="keyword">function</span> (<span class="params">startIndex</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> transactionWrappers = <span class="keyword">this</span>.transactionWrappers; <span class="comment">// 得到wrapper</span></span><br><span class="line">    <span class="comment">// 遍历依次调用</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = startIndex; i &lt; transactionWrappers.length; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> wrapper = transactionWrappers[i];</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">this</span>.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(<span class="keyword">this</span>):<span class="literal">null</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.wrapperInitData[i] === OBSERVED_ERROR) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.initializeAll(i + <span class="number">1</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (err) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用所有wrapper的close方法的函数定义</span></span><br><span class="line">  closeAll: <span class="function"><span class="keyword">function</span> (<span class="params">startIndex</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">var</span> transactionWrappers = <span class="keyword">this</span>.transactionWrappers; <span class="comment">// 拿到wrapper</span></span><br><span class="line">    <span class="comment">// 遍历依次调用</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = startIndex; i &lt; transactionWrappers.length; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> wrapper = transactionWrappers[i];</span><br><span class="line">      <span class="keyword">var</span> initData = <span class="keyword">this</span>.wrapperInitData[i];</span><br><span class="line">      <span class="keyword">var</span> errorThrown;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (initData !== OBSERVED_ERROR &amp;&amp; wrapper.close) &#123;</span><br><span class="line">          wrapper.close.call(<span class="keyword">this</span>, initData);</span><br><span class="line">        &#125;</span><br><span class="line">        errorThrown = <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (errorThrown) &#123;</span><br><span class="line">          ...</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.closeAll(i + <span class="number">1</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.wrapperInitData.length = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这只是React事务的抽象实现(基类), 还需要实例化事务并对其加强的配合, 才能发挥事务的真正作用.  另外, 在React 中, 一个事务里开启另一个事务很普遍, 这说明事务是有粒度大小的, 就像进程和线程一样.</p>
<h6 id="3-2-批量更新依靠了事务"><a href="#3-2-批量更新依靠了事务" class="headerlink" title="3.2 批量更新依靠了事务"></a>3.2 批量更新依靠了事务</h6><p>刚讲到,  在React中, 批量更新受<code>batchingStrategy</code>控制,而这个策略除了server端都是<code>ReactDefaultBatchingStrategy</code>, 而在ReactDefaultBatchingStrategy.js中, 批量更新的实现依靠了事务: </p>
<p>ReactDefaultBatchingStrategy.js :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">var</span> Transaction = <span class="built_in">require</span>(<span class="string">'Transaction'</span>);<span class="comment">// 引入事务</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> RESET_BATCHED_UPDATES = &#123;   <span class="comment">// 重置的 wrapper</span></span><br><span class="line">  initialize: emptyFunction,</span><br><span class="line">  close: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates = <span class="literal">false</span>;  <span class="comment">// 事务结束即一次batch结束</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> FLUSH_BATCHED_UPDATES = &#123;  <span class="comment">// 批处理的 wrapper</span></span><br><span class="line">  initialize: emptyFunction,</span><br><span class="line">  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合成 ReactDefaultBatchingStrategyTransaction 事务的wrapper</span></span><br><span class="line"><span class="keyword">var</span> TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES]; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 reinitializeTransaction 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReactDefaultBatchingStrategyTransaction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.reinitializeTransaction();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数中依赖了事务</span></span><br><span class="line"><span class="built_in">Object</span>.assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, &#123;</span><br><span class="line">  getTransactionWrappers: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> TRANSACTION_WRAPPERS;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> transaction = <span class="keyword">new</span> ReactDefaultBatchingStrategyTransaction(); <span class="comment">// 实例化这类事务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 批处理策略</span></span><br><span class="line"><span class="keyword">var</span> ReactDefaultBatchingStrategy = &#123;</span><br><span class="line">  isBatchingUpdates: <span class="literal">false</span>, <span class="comment">// 是否处在一次BatchingUpdates标志位</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 批量更新策略调用的就是这个方法</span></span><br><span class="line">  batchedUpdates: <span class="function"><span class="keyword">function</span>(<span class="params">callback, a, b, c, d, e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;</span><br><span class="line">	<span class="comment">// 一旦调用批处理, 重置isBatchingUpdates标志位, 表示正处在一次BatchingUpdates中</span></span><br><span class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 避免重复分配事务</span></span><br><span class="line">    <span class="keyword">if</span> (alreadyBatchingUpdates) &#123;</span><br><span class="line">      <span class="keyword">return</span> callback(a, b, c, d, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> transaction.perform(callback, <span class="literal">null</span>, a, b, c, d, e);  <span class="comment">// 将callback放进事务里执行</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>那么, 为什么批量更新的实现依靠了事务呢? 还记得实现批量更新的两个要点吗?</p>
<ul>
<li>何时存储更新</li>
<li>何时批处理</li>
</ul>
<p>对于这两个问题, React 在执行事务时调用wrappers的initialize方法, 建立更新队列, 然后执行函数, 接着 : </p>
<ul>
<li>何时存储更新——  在执行函数时遇到更新请求就存到这个队列中</li>
<li>何时批处理——  函数执行后调用wrappers的close方法, 在close方法中调用批量处理函数</li>
</ul>
<p>口说无凭, 得有证据. 我们拿<code>ReactDOM.render</code>会调用的事务<code>ReactReconcileTransaction</code>来看看是不是这样:</p>
<p>ReactReconcileTransaction.js 里有个wrapper, 它是这样定义的(英文是官方注释) :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ON_DOM_READY_QUEUEING = &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Initializes the internal `onDOMReady` queue.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  initialize: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.reactMountReady.reset();</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  close: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.reactMountReady.notifyAll();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们再看<code>ReactReconcileTransaction</code>事务会执行的函数<code>mountComponent</code>, 它在</p>
<p>ReactCompositeComponent.js :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Initializes the component, renders markup, and registers event listeners.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  mountComponent: <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    transaction,</span></span></span><br><span class="line"><span class="function"><span class="params">    hostParent,</span></span></span><br><span class="line"><span class="function"><span class="params">    hostContainerInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">    context,</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (inst.componentDidMount) &#123;</span><br><span class="line">          <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">            transaction.getReactMountReady().enqueue(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 将要调用的callback存起来</span></span><br><span class="line">              measureLifeCyclePerf(</span><br><span class="line">                () =&gt; inst.componentDidMount(),</span><br><span class="line">                <span class="keyword">this</span>._debugID,</span><br><span class="line">                <span class="string">'componentDidMount'</span>,</span><br><span class="line">              );</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">     ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>而上述wrapper定义的close方法调用的<code>this.reactMountReady.notifyAll()</code>在这</p>
<p>CallbackQueue.js :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Invokes all enqueued callbacks and clears the queue. This is invoked after</span></span><br><span class="line"><span class="comment">   * the DOM representation of a component has been created or updated.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  notifyAll() &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 遍历调用存储的callback</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; callbacks.length; i++) &#123;</span><br><span class="line">        callbacks[i].call(contexts[i], arg);</span><br><span class="line">      &#125;</span><br><span class="line">      callbacks.length = <span class="number">0</span>;</span><br><span class="line">      contexts.length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>即证.</p>
<h3 id="你竟然读到这了"><a href="#你竟然读到这了" class="headerlink" title="你竟然读到这了"></a>你竟然读到这了</h3><p>好累(笑哭), 先写到这吧. 我本来还想一篇文章就把组件初始渲染的过程和组件更新的过程讲完, 现在看来要分开讲了… React 细节太多了, 蕴含的信息量也很大…说博大精深一点不夸张…向React的作者们以及社区的人们致敬!</p>
<p>我觉得读源码是一件很费力但是非常值得的事情. 刚开始读的时候一点头绪也没有, 不知道它是什么样的过程, 不知道为什么要这么写, 有时候还会因为断点没打好绕了很多弯路…也是硬着头皮一遍一遍看, 结合网上的文章, 就这样云里雾里的慢慢摸索, 不断更正自己的认知.后来看多了, 就经常会有大彻大悟的感觉, 零碎的认知开始连通起来, 逐渐摸清了来龙去脉. </p>
<p>现在觉得确实很值得, 自己学到了不少. 看源码的过程就感觉是跟作者们交流讨论一样, 思想在碰撞! 强烈推荐前端的同学们阅读React源码, 大神们智慧的结晶!</p>
<p>未完待续…</p>
</div><div class="tags"><a href="/tags/React/">React</a><a href="/tags/源码分析/">源码分析</a></div><div class="post-share"></div><div class="post-nav"><a href="/2018/03/17/react-source-code-analysis-2-initial-render/" class="pre">React源码分析(二)-组件的初始渲染</a><a href="/2017/11/21/认识node核心模块-网络编程/" class="next">认识node核心模块--网络编程</a></div><div id="comments"><div id="container"></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="React"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#如何分析-React-源码"><span class="toc-text">如何分析 React 源码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#正文"><span class="toc-text">正文</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#调用ReactDOM-render-发生了什么"><span class="toc-text">调用ReactDOM.render 发生了什么</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#大致过程-只展示主要的函数调用"><span class="toc-text">大致过程(只展示主要的函数调用):</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#让我们来分析一下具体过程"><span class="toc-text">让我们来分析一下具体过程:</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1、创建元素"><span class="toc-text">1、创建元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2、创建对应类型的React组件"><span class="toc-text">2、创建对应类型的React组件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3、开启批量更新以应对可能的setState"><span class="toc-text">3、开启批量更新以应对可能的setState</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#3-1-我们先介绍一下事务"><span class="toc-text">3.1 我们先介绍一下事务.</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-2-批量更新依靠了事务"><span class="toc-text">3.2 批量更新依靠了事务</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#你竟然读到这了"><span class="toc-text">你竟然读到这了</span></a></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/06/29/learning-about-the-operating-system/">操作系统了解一下</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/02/a-comprehensive-understanding-of-HTTP/">全面了解HTTP</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/17/react-source-code-analysis-3-update/">React源码分析(三)-全面剖析组件更新机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/17/react-source-code-analysis-2-initial-render/">React源码分析(二)-组件的初始渲染</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/11/react-source-code-analysis-1-after-ReactDOM.render/">React源码分析(一)-调用ReactDOM.render后发生了什么</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/21/认识node核心模块-网络编程/">认识node核心模块--网络编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/10/认识node核心模块-从Buffer、Stream到fs/">认识node核心模块--从Buffer、Stream到fs</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/03/认识node核心模块-深入EventEmitter/">认识node核心模块--深入EventEmitter</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/25/认识node核心模块-全局对象及Cluster/">认识node核心模块--全局对象及Cluster</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/14/node核心特性理解/">node核心特性理解</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/源码分析/" style="font-size: 15px;">源码分析</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/感想/" style="font-size: 15px;">感想</a> <a href="/tags/React/" style="font-size: 15px;">React</a> <a href="/tags/React架构/" style="font-size: 15px;">React架构</a> <a href="/tags/HTTP/" style="font-size: 15px;">HTTP</a> <a href="/tags/dva/" style="font-size: 15px;">dva</a> <a href="/tags/操作系统/" style="font-size: 15px;">操作系统</a> <a href="/tags/node/" style="font-size: 15px;">node</a> <a href="/tags/node基础/" style="font-size: 15px;">node基础</a> <a href="/tags/JavaScript函数/" style="font-size: 15px;">JavaScript函数</a> <a href="/tags/React基础/" style="font-size: 15px;">React基础</a> <a href="/tags/Redux/" style="font-size: 15px;">Redux</a> <a href="/tags/Redux-saga/" style="font-size: 15px;">Redux saga</a> <a href="/tags/JavaScript对象/" style="font-size: 15px;">JavaScript对象</a> <a href="/tags/前端工程师/" style="font-size: 15px;">前端工程师</a> <a href="/tags/职业规划/" style="font-size: 15px;">职业规划</a> <a href="/tags/事件循环机制/" style="font-size: 15px;">事件循环机制</a> <a href="/tags/实习/" style="font-size: 15px;">实习</a> <a href="/tags/面试题/" style="font-size: 15px;">面试题</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://mofan_tcg.coding.me/" title="时光笔记" target="_blank">时光笔记</a><ul></ul><a href="http://realtcg.com/Precious-Memories/" title="React小相册" target="_blank">React小相册</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p>你的梦想是这个世界上最伟大的事情</p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">mofan.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/MrStronger/hexo-theme-Mofan"> Mofan.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-121639135-1','auto');ga('send','pageview');
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment = new Gitment({
  id: 'React源码分析(一)-调用ReactDOM.render后发生了什么', // 可选。默认为 location.href
  owner: 'MrStronger',
  repo: 'blogcomment',
  oauth: {
    client_id: '0a99d84bb46f7cda7fce',
    client_secret: 'b3915ea2a1e5364a698ec8335e34092ad6bc42d0',
  },
})
gitment.render('container')
</script></body></html>