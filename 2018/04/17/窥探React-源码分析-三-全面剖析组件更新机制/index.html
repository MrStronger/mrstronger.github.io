<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="莫凡的个人博客"><title>窥探React-源码分析(三)-全面剖析组件更新机制 | 莫凡</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"></head><body><div class="body_container"><div id="header"><div class="site-name"><a id="logo" href="/."><img src="http://ot6vbgl2y.bkt.clouddn.com/18-2-12/7859845.jpg" class="logoImg"><span id="hidden">窥探React-源码分析(三)-全面剖析组件更新机制</span></a></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">窥探React-源码分析(三)-全面剖析组件更新机制</h1><div class="post-meta"><a href="/2018/04/17/窥探React-源码分析-三-全面剖析组件更新机制/#comments" class="comment-count"></a><p><span class="date">Apr 17, 2018</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>React 把组件看作状态机(有限状态机), 使用state来控制本地状态, 使用props来传递状态.  前面我们探讨了 React 如何映射状态到 UI 上(初始渲染), 那么接下来我们谈谈 React 时如何同步状态到 UI 上的, 也就是:</p>
<p>React 是如何更新组件的? </p>
<p>React 是如何对比出页面变化最小的部分?</p>
<p>这篇文章会为你解答这些问题.</p>
<h3 id="在这之前"><a href="#在这之前" class="headerlink" title="在这之前"></a>在这之前</h3><p>你已经了解了React (15-stable版本)内部的一些基本概念, 包括不同类型的组件实例、mount过程、事务、批量更新的大致过程(还没有? 不用担心, 为你准备好了<a href="http://realtcg.com/2018/02/11/%E7%AA%A5%E6%8E%A2React-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%80">从源码看组件初始渲染</a>-%E8%B0%83%E7%94%A8ReactDOM.render%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/)、<a href="http://realtcg.com/2018/03/17/%E7%AA%A5%E6%8E%A2React-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%BA%8C">接着从源码看组件初始渲染</a>-%E7%BB%84%E4%BB%B6%E7%9A%84%E5%88%9D%E5%A7%8B%E6%B8%B2%E6%9F%93/);</p>
<p>准备一个<a href="https://github.com/MrStronger/react-experiment" target="_blank" rel="noopener">demo</a>, 调试源码, 以便更好理解;</p>
<p>Keep calm and make a big deal !</p>
<h2 id="React-是如何更新组件的"><a href="#React-是如何更新组件的" class="headerlink" title="React 是如何更新组件的?"></a>React 是如何更新组件的?</h2><h5 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h5><ul>
<li>依靠事务进行批量更新;</li>
<li>一次batch(批量)的生命周期就是从<code>ReactDefaultBatchingStrategy</code>事务perform之前(调用ReactUpdates.batchUpdates)到这个事务的最后一个close方法调用后结束;</li>
<li>事务启动后, 遇到 setState 则将 partial state 存到组件实例的_pendingStateQueue上, 然后将这个组件存到dirtyComponents 数组中, 等到 <code>ReactDefaultBatchingStrategy</code>事务结束时调用<code>runBatchedUpdates</code>批量更新所有组件;</li>
<li>组件的更新是递归的, 三种不同类型的组件都有自己的<code>updateComponent</code>方法来决定自己的组件如何更新, 其中 ReactDOMComponent 会采用diff算法对比子元素中最小的变化, 再批量处理.</li>
</ul>
<p>这个更新过程像是一套流程, 无论你通过setState(或者replaceState)还是新的props去更新一个组件, 都会起作用.</p>
<h3 id="那么具体是什么"><a href="#那么具体是什么" class="headerlink" title="那么具体是什么?"></a>那么具体是什么?</h3><p>让我们从这套更新流程的开始部分讲起…</p>
<h4 id="调用-setState-之前"><a href="#调用-setState-之前" class="headerlink" title="调用 setState 之前"></a>调用 setState 之前</h4><p>首先, 开始一次batch的入口是在<code>ReactDefaultBatchingStrategy</code>里, 调用里面的<code>batchedUpdates</code>便可以开启一次batch:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 批处理策略</span></span><br><span class="line"><span class="keyword">var</span> ReactDefaultBatchingStrategy = &#123;</span><br><span class="line">  isBatchingUpdates: <span class="literal">false</span>, </span><br><span class="line">  batchedUpdates: <span class="function"><span class="keyword">function</span>(<span class="params">callback, a, b, c, d, e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;</span><br><span class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates = <span class="literal">true</span>; <span class="comment">// 开启一次batch</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (alreadyBatchingUpdates) &#123;</span><br><span class="line">      <span class="keyword">return</span> callback(a, b, c, d, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 启动事务, 将callback放进事务里执行</span></span><br><span class="line">      <span class="keyword">return</span> transaction.perform(callback, <span class="literal">null</span>, a, b, c, d, e);  </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 React 中, 调用<code>batchedUpdates</code>有很多地方, 与更新流程相关的如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReactMount.js</span></span><br><span class="line">ReactUpdates.batchedUpdates(</span><br><span class="line">      batchedMountComponentIntoNode,  <span class="comment">// 负责初始渲染</span></span><br><span class="line">      componentInstance,</span><br><span class="line">      container,</span><br><span class="line">      shouldReuseMarkup,</span><br><span class="line">      context,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReactEventListener.js</span></span><br><span class="line">dispatchEvent: <span class="function"><span class="keyword">function</span>(<span class="params">topLevelType, nativeEvent</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);  <span class="comment">// 处理事件</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      TopLevelCallbackBookKeeping.release(bookKeeping);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>第一种情况, React 在首次渲染组件的时候会调用<code>batchedUpdates</code>, 然后开始渲染组件. 那么为什么要在这个时候启动一次batch呢? 不是因为要批量插入, 因为插入过程是递归的, 而是因为组件在渲染的过程中, 会依顺序调用各种生命周期函数, 开发者很可能在生命周期函数中(如<code>componentWillMount</code>或者<code>componentDidMount</code>)调用<code>setState</code>. 因此, 开启一次batch就是要存储更新(放入dirtyComponents), 然后在事务结束时批量更新. 这样以来, 在初始渲染流程中, 任何<code>setState</code>都会生效, 用户看到的始终是最新的状态.</p>
<p>第二种情况, 如果你在HTML元素上或者组件上绑定了事件, 那么你有可能在事件的监听函数中调用<code>setState</code>, 因此, 同样为了存储更新(放入dirtyComponents), 需要启动批量更新策略. 在回调函数被调用之前, React事件系统中的<code>dispatchEvent</code>函数负责事件的分发, 在<code>dispatchEvent</code>中启动了事务, 开启了一次batch, 随后调用了回调函数. 这样一来, 在事件的监听函数中调用的<code>setState</code>就会生效.</p>
<p>也就是说, 任何可能调用 setState 的地方, 在调用之前, React 都会启动批量更新策略以提前应对可能的setState</p>
<h4 id="那么调用-batchedUpdates-后发生了什么"><a href="#那么调用-batchedUpdates-后发生了什么" class="headerlink" title="那么调用 batchedUpdates 后发生了什么?"></a>那么调用 batchedUpdates 后发生了什么?</h4><p>React 调用<code>batchedUpdates</code>时会传进去一个函数, <code>batchedUpdates</code>会启动<code>ReactDefaultBatchingStrategyTransaction</code>事务, 这个函数就会被放在事务里执行: </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReactDefaultBatchingStrategy.js</span></span><br><span class="line"><span class="keyword">var</span> transaction = <span class="keyword">new</span> ReactDefaultBatchingStrategyTransaction(); <span class="comment">// 实例化事务</span></span><br><span class="line"><span class="keyword">var</span> ReactDefaultBatchingStrategy = &#123;</span><br><span class="line">  ...</span><br><span class="line">  batchedUpdates: <span class="function"><span class="keyword">function</span>(<span class="params">callback, a, b, c, d, e</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">      <span class="keyword">return</span> transaction.perform(callback, <span class="literal">null</span>, a, b, c, d, e);  <span class="comment">// 将callback放进事务里执行</span></span><br><span class="line">   	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>ReactDefaultBatchingStrategyTransaction</code>这个事务控制了批量策略的生命周期:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReactDefaultBatchingStrategy.js</span></span><br><span class="line"><span class="keyword">var</span> FLUSH_BATCHED_UPDATES = &#123;</span><br><span class="line">  initialize: emptyFunction,</span><br><span class="line">  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates),  <span class="comment">// 批量更新</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> RESET_BATCHED_UPDATES = &#123;</span><br><span class="line">  initialize: emptyFunction,</span><br><span class="line">  close: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates = <span class="literal">false</span>;  <span class="comment">// 结束本次batch</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];</span><br></pre></td></tr></table></figure>
<p>无论你传进去的函数是什么, 无论这个函数后续会做什么, 都会在执行完后调用上面事务的close方法, 先调用<code>flushBatchedUpdates</code>批量更新, 再结束本次batch.</p>
<h4 id="调用-setState-后发生了什么"><a href="#调用-setState-后发生了什么" class="headerlink" title="调用 setState 后发生了什么"></a>调用 setState 后发生了什么</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReactBaseClasses.js :</span></span><br><span class="line">ReactComponent.prototype.setState = <span class="function"><span class="keyword">function</span>(<span class="params">partialState, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.updater.enqueueSetState(<span class="keyword">this</span>, partialState);</span><br><span class="line">  <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>.updater.enqueueCallback(<span class="keyword">this</span>, callback, <span class="string">'setState'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; ReactUpdateQueue.js:</span></span><br><span class="line">enqueueSetState: <span class="function"><span class="keyword">function</span>(<span class="params">publicInstance, partialState</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 根据 this.setState 中的 this 拿到内部实例, 也就是组件实例</span></span><br><span class="line">	<span class="keyword">var</span> internalInstance = getInternalInstanceReadyForUpdate(publicInstance, <span class="string">'setState'</span>);</span><br><span class="line">    <span class="comment">// 取得组件实例的_pendingStateQueue</span></span><br><span class="line">    <span class="keyword">var</span> queue =</span><br><span class="line">      internalInstance._pendingStateQueue ||</span><br><span class="line">      (internalInstance._pendingStateQueue = []);</span><br><span class="line">    <span class="comment">// 将partial state存到_pendingStateQueue</span></span><br><span class="line">    queue.push(partialState);</span><br><span class="line">	<span class="comment">// 调用enqueueUpdate</span></span><br><span class="line">    enqueueUpdate(internalInstance);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; ReactUpdate.js:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueueUpdate</span>(<span class="params">component</span>) </span>&#123;</span><br><span class="line">  ensureInjected(); <span class="comment">// 注入默认策略</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果没有开启batch(或当前batch已结束)就开启一次batch再执行, 这通常发生在异步回调中调用 setState 	 // 的情况</span></span><br><span class="line">  <span class="keyword">if</span> (!batchingStrategy.isBatchingUpdates) &#123;</span><br><span class="line">    batchingStrategy.batchedUpdates(enqueueUpdate, component);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 如果batch已经开启就存储更新</span></span><br><span class="line">  dirtyComponents.push(component);</span><br><span class="line">  <span class="keyword">if</span> (component._updateBatchNumber == <span class="literal">null</span>) &#123;</span><br><span class="line">    component._updateBatchNumber = updateBatchNumber + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说, 调用 setState 会首先拿到内部组件实例, 然后把要更新的partial state存到其_pendingStateQueue中, 然后标记当前组件为<code>dirtyComponent</code>, 存到<code>dirtyComponents</code>数组中. 然后就接着继续做下面的事情了, 并没有立即更新, 这是因为接下来要执行的代码里有可能还会调用 setState, 因此只做存储处理.</p>
<h4 id="什么时候批量更新"><a href="#什么时候批量更新" class="headerlink" title="什么时候批量更新?"></a>什么时候批量更新?</h4><p>首先, 一个事务在执行的时候(包括initialize、perform、close阶段), 任何一阶段都有可能调用一系列函数, 并且开启了另一些事务. 那么只有等后续开启的事务执行完, 之前开启的事务才继续执行. 下图是我们刚才所说的第一种情况, 在初始渲染组件期间 setState 后, React 启动的各种事务和执行的顺序:</p>
<p><img src="http://ot6vbgl2y.bkt.clouddn.com/18-4-14/89051918.jpg" alt=""></p>
<p>从图中可以看到, <strong>批量更新是在<code>ReactDefaultBatchingStrategyTransaction</code>事务的close阶段, 在<code>flushBatchedUpdates</code>函数中启动了<code>ReactUpdatesFlushTransaction</code>事务负责批量更新.</strong></p>
<h4 id="怎么批量更新的"><a href="#怎么批量更新的" class="headerlink" title="怎么批量更新的?"></a>怎么批量更新的?</h4><h5 id="开启批量更新事务、批量处理callback"><a href="#开启批量更新事务、批量处理callback" class="headerlink" title="开启批量更新事务、批量处理callback"></a>开启批量更新事务、批量处理callback</h5><p>我们接着看<code>flushBatchedUpdates</code>函数, 在ReactUpdates.js中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flushBatchedUpdates = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 启动批量更新事务</span></span><br><span class="line">  <span class="keyword">while</span> (dirtyComponents.length || asapEnqueued) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dirtyComponents.length) &#123;</span><br><span class="line">      <span class="keyword">var</span> transaction = ReactUpdatesFlushTransaction.getPooled();</span><br><span class="line">      transaction.perform(runBatchedUpdates, <span class="literal">null</span>, transaction);</span><br><span class="line">      ReactUpdatesFlushTransaction.release(transaction);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 批量处理callback</span></span><br><span class="line">    <span class="keyword">if</span> (asapEnqueued) &#123;</span><br><span class="line">      asapEnqueued = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">var</span> queue = asapCallbackQueue;</span><br><span class="line">      asapCallbackQueue = CallbackQueue.getPooled();</span><br><span class="line">      queue.notifyAll();</span><br><span class="line">      CallbackQueue.release(queue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="遍历dirtyComponents"><a href="#遍历dirtyComponents" class="headerlink" title="遍历dirtyComponents"></a>遍历dirtyComponents</h5><p><code>flushBatchedUpdates</code>启动了一个更新事务, 这个事务执行了<code>runBatchedUpdates</code>进行批量更新:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReactUpdates.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runBatchedUpdates</span>(<span class="params">transaction</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> len = transaction.dirtyComponentsLength;</span><br><span class="line">  <span class="comment">// 排序保证父组件优先于子组件更新</span></span><br><span class="line">  dirtyComponents.sort(mountOrderComparator);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 代表批量更新的次数, 保证每个组件只更新一次</span></span><br><span class="line">  updateBatchNumber++;</span><br><span class="line">  <span class="comment">// 遍历 dirtyComponents</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> component = dirtyComponents[i];</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">var</span> callbacks = component._pendingCallbacks;</span><br><span class="line">    component._pendingCallbacks = <span class="literal">null</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 执行更新</span></span><br><span class="line">    ReactReconciler.performUpdateIfNecessary(</span><br><span class="line">      component,</span><br><span class="line">      transaction.reconcileTransaction,</span><br><span class="line">      updateBatchNumber,</span><br><span class="line">    );</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 存储 callback以便后续按顺序调用</span></span><br><span class="line">    <span class="keyword">if</span> (callbacks) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; callbacks.length; j++) &#123;</span><br><span class="line">        transaction.callbackQueue.enqueue(</span><br><span class="line">          callbacks[j],</span><br><span class="line">          component.getPublicInstance(),</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面 setState 后将组件推入了<code>dirtyComponents</code>, 现在就是要遍历<code>dirtyComponents</code>数组进行更新了. </p>
<h5 id="根据不同情况执行更新"><a href="#根据不同情况执行更新" class="headerlink" title="根据不同情况执行更新"></a>根据不同情况执行更新</h5><p><code>ReactReconciler</code>会调用组件实例的<code>performUpdateIfNecessary</code>.  如果接收了props, 就会调用此组件的<code>receiveComponent</code>, 再在里面调用<code>updateComponent</code>更新组件; 如果没有接受props, 但是有新的要更新的状态(_pendingStateQueue不为空)就会直接调用<code>updateComponent</code>来更新:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReactCompositeComponent.js</span></span><br><span class="line">performUpdateIfNecessary: <span class="function"><span class="keyword">function</span> (<span class="params">transaction</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._pendingElement != <span class="literal">null</span>) &#123;</span><br><span class="line">        ReactReconciler.receiveComponent(<span class="keyword">this</span>, <span class="keyword">this</span>._pendingElement, transaction, 				<span class="keyword">this</span>._context);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>._pendingStateQueue !== <span class="literal">null</span> || <span class="keyword">this</span>._pendingForceUpdate) &#123;</span><br><span class="line">        <span class="keyword">this</span>.updateComponent(transaction, <span class="keyword">this</span>._currentElement, <span class="keyword">this</span>._currentElement, 			<span class="keyword">this</span>._context, <span class="keyword">this</span>._context);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>._updateBatchNumber = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="调用组件实例的updateComponent"><a href="#调用组件实例的updateComponent" class="headerlink" title="调用组件实例的updateComponent"></a>调用组件实例的updateComponent</h5><p>接下里就是重头戏<code>updateComponent</code>了, 它决定了组件如果更新自己和它的后代们. <strong>需要特别注意的是, React 内部三种不同的组件类型, 每种组件都有自己的<code>updateComponent</code>, 有不同的行为.</strong></p>
<p>对于 ReactCompositeComponent (<a href="https://www.processon.com/view/link/5acb3adfe4b0899654a18c4d" target="_blank" rel="noopener">矢量图</a>):</p>
<p><img src="http://ot6vbgl2y.bkt.clouddn.com/18-4-15/19570800.jpg" alt=""></p>
<p><code>updateComponent</code>所做的事情 :</p>
<ul>
<li>调用此层级组件的一系列生命周期函数, 并且在合适的时机更新props、state、context;</li>
<li>re-render, 与之前 render 的 element 比较, 如果两者key &amp;&amp; element.type 相等, 则进入下一层进行更新; 如果不等, 直接移除重新mount</li>
</ul>
<p>对于 ReactDOMComponent:</p>
<p><img src="http://ot6vbgl2y.bkt.clouddn.com/18-4-15/71842292.jpg" alt=""></p>
<p><code>updateComponent</code>所做的事情 :</p>
<ul>
<li>更新这一层级DOM元素属性;</li>
<li>更新子元素, 调用 ReactMultiChild 的 <code>updateChildren</code>, 对比前后变化、标记变化类型、存到updates中(diff算法主要部分);</li>
<li>批量处理updates</li>
</ul>
<p>对于 ReactDOMTextComponent :</p>
<p><img src="http://ot6vbgl2y.bkt.clouddn.com/18-4-15/4725141.jpg" alt=""></p>
<p>上面只是每个组件自己更新的过程, 那么 React 是如何一次性更新所有组件的 ? 答案是递归.</p>
<h5 id="递归调用组件的updateComponent"><a href="#递归调用组件的updateComponent" class="headerlink" title="递归调用组件的updateComponent"></a>递归调用组件的updateComponent</h5><p>观察 ReactCompositeComponent 和 ReactDOMComponent 的更新流程, 我们发现 React 每次走到一个组件更新过程的最后部分, 都会有一个判断 : 如果 nextELement 和 prevElement key 和 type 相等, 就会调用<code>receiveComponent</code>. <code>receiveComponent</code>和<code>updateComponent</code>一样, 每种组件都有一个, 作用就相当于updateComponent 接受了新 props 的版本. 而这里调用的就是子元素的<code>receiveComponent</code>, 进而进行子元素的更新, 于是就形成了递归更新、递归diff. 因此, 整个流程就像这样(<a href="https://www.processon.com/view/link/5acb3adfe4b0899654a18c4d" target="_blank" rel="noopener">矢量图</a>) :</p>
<p><img src="http://ot6vbgl2y.bkt.clouddn.com/18-4-15/26921228.jpg" alt=""></p>
<p>这种更新完一级、diff完一级再进入下一级的过程保证 React 只遍历一次组件树就能完成更新, 但代价就是只要前后 render 出元素的 type 和 key 有一个不同就删除重造, 因此, React 建议页面要尽量保持稳定的结构.</p>
<h2 id="React-是如何对比出页面变化最小的部分"><a href="#React-是如何对比出页面变化最小的部分" class="headerlink" title="React 是如何对比出页面变化最小的部分?"></a>React 是如何对比出页面变化最小的部分?</h2><p>你可能会说 React 用 virtual DOM 表示了页面结构, 每次更新, React 都会re-render出新的 virtual DOM, 再通过 diff 算法对比出前后变化, 最后批量更新. 没错, 很好, 这就是大致过程, 但这里存在着一些隐藏的深层问题值得探讨 : </p>
<ul>
<li>React 是如何用 virtual DOM 表示了页面结构, 从而使任何页面变化都能被 diff 出来?</li>
<li>React 是如何 diff 出页面变化最小的部分?</li>
</ul>
<h4 id="React-如何表示页面结构"><a href="#React-如何表示页面结构" class="headerlink" title="React 如何表示页面结构"></a>React 如何表示页面结构</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render () &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">'container'</span>&gt;</span><br><span class="line">                  <span class="string">"dscsdcsd"</span></span><br><span class="line">                  &lt;i onClick=&#123;(e) =&gt; <span class="built_in">console</span>.log(e)&#125;&gt;&#123;<span class="keyword">this</span>.state.val&#125;&lt;<span class="regexp">/i&gt;</span></span><br><span class="line"><span class="regexp">                  &lt;Children val=&#123;this.state.val&#125;/</span>&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ virtual DOM(React element)</span></span><br><span class="line"><span class="regexp">&#123;</span></span><br><span class="line"><span class="regexp">  $$typeof: Symbol(react.element)</span></span><br><span class="line"><span class="regexp">  key: null</span></span><br><span class="line"><span class="regexp">  props: &#123;  /</span><span class="regexp">/ props 代表元素上的所有属性, 有children属性, 描述子组件, 同样是元素</span></span><br><span class="line"><span class="regexp">    children: [</span></span><br><span class="line"><span class="regexp">      ""dscsdcsd"",</span></span><br><span class="line"><span class="regexp">	  &#123;$$typeof: Symbol(react.element), type: "i", key: null, ref: null, props: &#123;…&#125;, …&#125;,</span></span><br><span class="line"><span class="regexp">	  &#123;$$typeof: Symbol(react.element), type: class Children, props: &#123;…&#125;, …&#125;</span></span><br><span class="line"><span class="regexp">    ]</span></span><br><span class="line"><span class="regexp">    className: 'container'</span></span><br><span class="line"><span class="regexp">  &#125;  </span></span><br><span class="line"><span class="regexp">  ref: null</span></span><br><span class="line"><span class="regexp">  type: "div"</span></span><br><span class="line"><span class="regexp">  _owner: ReactCompositeComponentWrapper &#123;...&#125; /</span><span class="regexp">/ class C 实例化后的对象</span></span><br><span class="line"><span class="regexp">  _store: &#123;validated: false&#125;</span></span><br><span class="line"><span class="regexp">  _self: null</span></span><br><span class="line"><span class="regexp">  _source: null</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>每个标签, 无论是DOM元素还是自定义组件, 都会有 key、type、props、ref 等属性.</p>
<ul>
<li>key 代表元素唯一id值, 意味着只要id改变, 就算前后元素种类相同, 元素也肯定不一样了;</li>
<li>type 代表元素种类,  有 function(空的wrapper)、class(自定义类)、string(具体的DOM元素名称)类型, 与key一样, 只要改变, 元素肯定不一样;</li>
<li>props 是元素的属性, 任何写在标签上的属性(如className=’container’)都会被存在这里, 如果这个元素有子元素(包括文本内容), props就会有children属性, 存储子元素; children属性是递归插入、递归更新的依据; </li>
</ul>
<p>也就是说, 如果元素唯一标识符或者类别或者属性有变化, 那么它们re-render后对应的 key、type 和props里面的属性也会改变, 前后一对比即可找出变化. 综上来看, React 这么表示页面结构确实能够反映前后所有变化.</p>
<h4 id="那么-React-是如何-diff-的"><a href="#那么-React-是如何-diff-的" class="headerlink" title="那么 React 是如何 diff 的?"></a>那么 React 是如何 diff 的?</h4><p>React diff 每次只对同一层级的节点进行比对 :</p>
<p><img src="http://ot6vbgl2y.bkt.clouddn.com/18-4-16/35051456.jpg" alt=""></p>
<p>上图的数字表示遍历更新的次序.</p>
<p>从父节点开始, 每一层 diff 包括两个地方</p>
<ul>
<li><p>element diff—— 前后 render 出来的 element 的对比, 这个对比是为了找出前后节点是不是同一节点, 会对比前后render出来的元素它们的 key 和 type. element diff 包括两个地方, 组件顶层DOM元素对比和子元素的对比:</p>
<p><strong>组件顶层DOM元素对比 :</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReactCompositeComponent.js/updateComponent =&gt; _updateRenderedComponent</span></span><br><span class="line">_updateRenderedComponent: <span class="function"><span class="keyword">function</span>(<span class="params">transaction, context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// re-render 出element</span></span><br><span class="line">	<span class="keyword">var</span> nextRenderedElement = <span class="keyword">this</span>._renderValidatedComponent();</span><br><span class="line">	<span class="comment">// 对比前后变化</span></span><br><span class="line">    <span class="keyword">if</span> (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) &#123;</span><br><span class="line">      <span class="comment">// 如果 key &amp;&amp; type 没变进行下一级更新</span></span><br><span class="line">      ReactReconciler.receiveComponent(...);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果变了移除重造</span></span><br><span class="line">      ReactReconciler.unmountComponent(prevComponentInstance, <span class="literal">false</span>);</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">var</span> child = <span class="keyword">this</span>._instantiateReactComponent(...);</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">var</span> nextMarkup = ReactReconciler.mountComponent(...);</span><br><span class="line">      <span class="keyword">this</span>._replaceNodeWithMarkup(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>子元素的对比:</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReactChildReconciler.js</span></span><br><span class="line">updateChildren: <span class="function"><span class="keyword">function</span>(<span class="params">...</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (name <span class="keyword">in</span> nextChildren) &#123;  <span class="comment">// 遍历 re-render 出的elements</span></span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        prevChild != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        shouldUpdateReactComponent(prevElement, nextElement)</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// 如果key &amp;&amp; type 没变进行下一级更新</span></span><br><span class="line">        ReactReconciler.receiveComponent(...);  </span><br><span class="line">        nextChildren[name] = prevChild;  <span class="comment">// 更新完放入 nextChildren, 注意放入的是组件实例</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果变了则移除重建                               </span></span><br><span class="line">        <span class="keyword">if</span> (prevChild) &#123;</span><br><span class="line">          removedNodes[name] = ReactReconciler.getHostNode(prevChild);</span><br><span class="line">          ReactReconciler.unmountComponent(prevChild, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> nextChildInstance = instantiateReactComponent(nextElement, <span class="literal">true</span>);</span><br><span class="line">        nextChildren[name] = nextChildInstance;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">var</span> nextChildMountImage = ReactReconciler.mountComponent(...);</span><br><span class="line">        mountImages.push(nextChildMountImage);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 再除掉 prevChildren 里有, nextChildren 里没有的组件</span></span><br><span class="line">    <span class="keyword">for</span> (name <span class="keyword">in</span> prevChildren) &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        prevChildren.hasOwnProperty(name) &amp;&amp;</span><br><span class="line">        !(nextChildren &amp;&amp; nextChildren.hasOwnProperty(name))</span><br><span class="line">      ) &#123;</span><br><span class="line">        prevChild = prevChildren[name];</span><br><span class="line">        removedNodes[name] = ReactReconciler.getHostNode(prevChild);</span><br><span class="line">        ReactReconciler.unmountComponent(prevChild, <span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>shouldComponentUpdate 函数:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shouldUpdateReactComponent</span>(<span class="params">prevElement, nextElement</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> prevEmpty = prevElement === <span class="literal">null</span> || prevElement === <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">var</span> nextEmpty = nextElement === <span class="literal">null</span> || nextElement === <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (prevEmpty || nextEmpty) &#123;</span><br><span class="line">    <span class="keyword">return</span> prevEmpty === nextEmpty;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> prevType = <span class="keyword">typeof</span> prevElement;</span><br><span class="line">  <span class="keyword">var</span> nextType = <span class="keyword">typeof</span> nextElement;</span><br><span class="line">  <span class="comment">// 如果前后变化都是字符串、数字类型的则允许更新</span></span><br><span class="line">  <span class="keyword">if</span> (prevType === <span class="string">'string'</span> || prevType === <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> nextType === <span class="string">'string'</span> || nextType === <span class="string">'number'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则检查 type &amp;&amp; key</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      nextType === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">      prevElement.type === nextElement.type &amp;&amp;</span><br><span class="line">      prevElement.key === nextElement.key</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>element diff 检测 type &amp;&amp; key 都没变时会进入下一级更新, 如果变化则直接移除重造新元素, 然后遍历同级的下一个.</p>
</li>
<li><p>subtree diff ——组件顶层DOM元素包裹的所有子元素(也就是props.children里的元素)与之前版本的对比, 这个对比是为了找出同级所有子节点的变化, 包括移除、新建、同级范围的移动;</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReactMultiChild.js</span></span><br><span class="line">_updateChildren: <span class="function"><span class="keyword">function</span>(<span class="params">...</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> prevChildren = <span class="keyword">this</span>._renderedChildren;</span><br><span class="line">      <span class="keyword">var</span> removedNodes = &#123;&#125;;</span><br><span class="line">      <span class="keyword">var</span> mountImages = [];</span><br><span class="line">      <span class="comment">// 拿到更新后子组件实例</span></span><br><span class="line">      <span class="keyword">var</span> nextChildren = <span class="keyword">this</span>._reconcilerUpdateChildren();</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 遍历子组件实例</span></span><br><span class="line">      <span class="keyword">for</span> (name <span class="keyword">in</span> nextChildren) &#123;</span><br><span class="line">   		...</span><br><span class="line">        <span class="keyword">var</span> prevChild = prevChildren &amp;&amp; prevChildren[name];</span><br><span class="line">        <span class="keyword">var</span> nextChild = nextChildren[name];</span><br><span class="line">        <span class="comment">// 因为子组件的更新是在原组件实例上更改的, 因此与之前的组件作引用比较即可判断</span></span><br><span class="line">        <span class="keyword">if</span> (prevChild === nextChild) &#123;</span><br><span class="line">            <span class="comment">// 发生了移动</span></span><br><span class="line">          updates = enqueue(</span><br><span class="line">            updates,</span><br><span class="line">            <span class="keyword">this</span>.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex),</span><br><span class="line">          );</span><br><span class="line">          lastIndex = <span class="built_in">Math</span>.max(prevChild._mountIndex, lastIndex);</span><br><span class="line">          prevChild._mountIndex = nextIndex;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          ...</span><br><span class="line">          <span class="comment">// 有新的组件</span></span><br><span class="line">          updates = enqueue(</span><br><span class="line">            updates,</span><br><span class="line">            <span class="keyword">this</span>._mountChildAtIndex(</span><br><span class="line">              nextChild,</span><br><span class="line">              mountImages[nextMountIndex],</span><br><span class="line">              lastPlacedNode,</span><br><span class="line">              nextIndex,</span><br><span class="line">              transaction,</span><br><span class="line">              context,</span><br><span class="line">            ),</span><br><span class="line">          );</span><br><span class="line">          nextMountIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        nextIndex++;</span><br><span class="line">        lastPlacedNode = ReactReconciler.getHostNode(nextChild);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Remove children that are no longer present.</span></span><br><span class="line">      <span class="keyword">for</span> (name <span class="keyword">in</span> removedNodes) &#123;</span><br><span class="line">          <span class="comment">// removedNodes 记录了所有的移除节点</span></span><br><span class="line">        <span class="keyword">if</span> (removedNodes.hasOwnProperty(name)) &#123;</span><br><span class="line">          updates = enqueue(</span><br><span class="line">            updates,</span><br><span class="line">            <span class="keyword">this</span>._unmountChild(prevChildren[name], removedNodes[name]),</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (updates) &#123;</span><br><span class="line">        processQueue(<span class="keyword">this</span>, updates); <span class="comment">// 批量处理</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>._renderedChildren = nextChildren;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>
<p>React 会将同一层级的变化标记, 如 MOVE_EXISTING、REMOVE_NODE、TEXT_CONTENT、INSERT_MARKUP 等, 统一放到 updates 数组中然后批量处理.</p>
</li>
</ul>
<h2 id="And-that‘s-it"><a href="#And-that‘s-it" class="headerlink" title="And that‘s it !"></a>And that‘s it !</h2><p>React 是一个激动人心的库, 它给我们带来了前所未有的开发体验, 但当我们沉浸在使用 React 快速实现需求的喜悦中时, 有必要去探究两个问题 : Why and How?</p>
<p>为什么 React 会如此流行, 原因是什么?  组件化、快速、足够简单、all in js、容易扩展、生态丰富、社区强大…</p>
<p>React 反映了哪些思想/理念/思路 ?  状态机、webComponents、virtual DOM、virtual stack、异步渲染、多端渲染、单向数据流、反应式更新、函数式编程…</p>
<p>React 这些理念/思路受什么启发 ? 怎么想到的 ? 又怎么实现的? …</p>
</div><div class="tags"><a href="/tags/React/">React</a><a href="/tags/源码分析/">源码分析</a></div><div class="post-share"></div><div class="post-nav"><a href="/2018/03/17/窥探React-源码分析(二)-组件的初始渲染/" class="next">窥探React-源码分析(二)-组件的初始渲染</a></div><div id="comments"><div id="container"></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="React"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#在这之前"><span class="toc-text">在这之前</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-是如何更新组件的"><span class="toc-text">React 是如何更新组件的?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#TL-DR"><span class="toc-text">TL;DR</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#那么具体是什么"><span class="toc-text">那么具体是什么?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#调用-setState-之前"><span class="toc-text">调用 setState 之前</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#那么调用-batchedUpdates-后发生了什么"><span class="toc-text">那么调用 batchedUpdates 后发生了什么?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#调用-setState-后发生了什么"><span class="toc-text">调用 setState 后发生了什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么时候批量更新"><span class="toc-text">什么时候批量更新?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#怎么批量更新的"><span class="toc-text">怎么批量更新的?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#开启批量更新事务、批量处理callback"><span class="toc-text">开启批量更新事务、批量处理callback</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#遍历dirtyComponents"><span class="toc-text">遍历dirtyComponents</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#根据不同情况执行更新"><span class="toc-text">根据不同情况执行更新</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#调用组件实例的updateComponent"><span class="toc-text">调用组件实例的updateComponent</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#递归调用组件的updateComponent"><span class="toc-text">递归调用组件的updateComponent</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-是如何对比出页面变化最小的部分"><span class="toc-text">React 是如何对比出页面变化最小的部分?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#React-如何表示页面结构"><span class="toc-text">React 如何表示页面结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#那么-React-是如何-diff-的"><span class="toc-text">那么 React 是如何 diff 的?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#And-that‘s-it"><span class="toc-text">And that‘s it !</span></a></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/04/17/窥探React-源码分析-三-全面剖析组件更新机制/">窥探React-源码分析(三)-全面剖析组件更新机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/17/窥探React-源码分析(二)-组件的初始渲染/">窥探React-源码分析(二)-组件的初始渲染</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/11/窥探React-源码分析(一)-调用ReactDOM.render后发生了什么/">窥探React-源码分析(一)-调用ReactDOM.render后发生了什么</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/21/认识node核心模块-网络编程/">认识node核心模块--网络编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/10/认识node核心模块-从Buffer、Stream到fs/">认识node核心模块--从Buffer、Stream到fs</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/03/认识node核心模块-深入EventEmitter/">认识node核心模块--深入EventEmitter</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/25/认识node核心模块-全局对象及Cluster/">认识node核心模块--全局对象及Cluster</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/14/node核心特性理解/">node核心特性理解</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/27/我对前端工程师这个职业的看法/">我对前端工程师这个职业的看法</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/21/浏览器中的事件循环机制/">浏览器中的事件循环机制</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/Redux/" style="font-size: 15px;">Redux</a> <a href="/tags/感想/" style="font-size: 15px;">感想</a> <a href="/tags/JavaScript函数/" style="font-size: 15px;">JavaScript函数</a> <a href="/tags/React/" style="font-size: 15px;">React</a> <a href="/tags/dva/" style="font-size: 15px;">dva</a> <a href="/tags/React架构/" style="font-size: 15px;">React架构</a> <a href="/tags/node/" style="font-size: 15px;">node</a> <a href="/tags/node基础/" style="font-size: 15px;">node基础</a> <a href="/tags/React基础/" style="font-size: 15px;">React基础</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/Redux-saga/" style="font-size: 15px;">Redux saga</a> <a href="/tags/前端工程师/" style="font-size: 15px;">前端工程师</a> <a href="/tags/职业规划/" style="font-size: 15px;">职业规划</a> <a href="/tags/JavaScript对象/" style="font-size: 15px;">JavaScript对象</a> <a href="/tags/事件循环机制/" style="font-size: 15px;">事件循环机制</a> <a href="/tags/源码分析/" style="font-size: 15px;">源码分析</a> <a href="/tags/实习/" style="font-size: 15px;">实习</a> <a href="/tags/面试题/" style="font-size: 15px;">面试题</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://mofan_tcg.coding.me/" title="时光笔记" target="_blank">时光笔记</a><ul></ul><a href="http://realtcg.com/Precious-Memories/" title="React小相册" target="_blank">React小相册</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p>你的梦想是这个世界上最伟大的事情</p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">mofan.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/MrStronger/hexo-theme-Mofan"> Mofan.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?3f3a5a8fd2b4cc3b3813fd00426fa25d";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment = new Gitment({
  id: '窥探React-源码分析(三)-全面剖析组件更新机制', // 可选。默认为 location.href
  owner: 'MrStronger',
  repo: 'blogcomment',
  oauth: {
    client_id: '0a99d84bb46f7cda7fce',
    client_secret: 'b3915ea2a1e5364a698ec8335e34092ad6bc42d0',
  },
})
gitment.render('container')
</script></body></html>