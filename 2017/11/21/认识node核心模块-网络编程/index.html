<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="莫凡的个人博客"><title>认识node核心模块--网络编程 | 莫凡</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"></head><body><div class="body_container"><div id="header"><div class="site-name"><a id="logo" href="/."><img src="http://ot6vbgl2y.bkt.clouddn.com/18-2-12/7859845.jpg" class="logoImg"><span id="hidden">认识node核心模块--网络编程</span></a></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">认识node核心模块--网络编程</h1><div class="post-meta"><a href="/2017/11/21/认识node核心模块-网络编程/#comments" class="comment-count"></a><p><span class="date">Nov 21, 2017</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>在构建网络通信服务方面，相比于其他老牌后端语言，Node.js 同样能够胜任(也许更胜一筹)，并且有自己独特的处理方式。node是一个面向网络而生的平台，它的事件驱动、非阻塞、单线程使node应用程序具有低内存、高并发、伸缩性强的优良特性，适合在分布式网络大展身手。Node底层实现了传输层TCP/UDP、应用层HTTP/HTTPS的功能并封装成贴合网络的API，并且可以自己创建服务器而不依赖三方服务，使用起来非常方便、简单、灵活。对于网络编程，node提供了net、dgram、http、https 4个模块，分别用于处理TCP、UDP、HTTP、HTTPS。本文将介绍这些模块并利用这些模块提供的API构建简单的网络服务。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>其实无论什么语言、什么平台，实现网络编程都需要遵循网络标准规范，只不过具体实现或者提供的API不同而已。因此，在探讨node网络编程之前，我们需要了解用于网络通信的网络协议(推荐阅读《图解HTTP》)。理解了网络通信的规范和机制，再熟悉一下API就可以了。</p>
<p><img src="http://ot6vbgl2y.bkt.clouddn.com/17-11-14/90782053.jpg" alt="图片来源https://yjhjstz.gitbooks.io/deep-into-node/content/chapter9/chapter9-1.html"></p>
<h3 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP/UDP"></a>TCP/UDP</h3><p>TCP(Transmission Control Protocol)传输控制协议是面向连接的协议，也就是必须建立连接才能发送数据。TCP在传输之前需要与服务器端进行3次握手形成会话(SYN是同步信号，ACK是确认信号)：</p>
<p><img src="http://ot6vbgl2y.bkt.clouddn.com/17-11-14/23108293.jpg" alt=""></p>
<p>TCP传送数据比较可靠，如果丢失数据会重传，并且会对传送数据进行排序。适用于重要、有序数据的传送。</p>
<p>UDP(User Datagram Protocol)用户数据报协议是无连接协议，不面向连接，面向事务，创建过程相对简单，占用内存底，处理快速且灵活，发送数据不需要与另一端建立连接，且不分客户端、服务器端，在一端即可以发送数据也可以接收数据。传送的数据是无序的，网络中断会导致丢包。UDP的简单不可靠特性适用于丢失一部分数据不会造成太大影响的场景，如音视频数据传送等。</p>
<p><strong>socket</strong></p>
<p>网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket(套接字)，因此建立网络通信连接至少要一对端口号(socket)。socket本质是对TCP/IP协议栈的封装，它提供了一个针对TCP或者UDP编程的接口，并不是另一种协议。通过socket，你可以使用TCP/IP协议。</p>
<blockquote>
<p>Socket的英文原义是“孔”或“插座”。作为BSD UNIX的<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1" target="_blank" rel="noopener">进程通信</a>机制，取后一种意思。通常也称作”<a href="https://baike.baidu.com/item/%E5%A5%97%E6%8E%A5%E5%AD%97" target="_blank" rel="noopener">套接字</a>“，用于描述IP地址和端口，是一个通信链的句柄，可以用来实现不同虚拟机或不同计算机之间的通信。<strong>在Internet上的<a href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA" target="_blank" rel="noopener">主机</a>一般运行了多个服务软件，同时提供几种服务。每种服务都打开一个Socket，并绑定到一个端口上，不同的端口对应于不同的服务</strong>。Socket正如其英文原意那样，像一个多孔插座。一台主机犹如布满各种插座的房间，每个插座有一个编号，有的插座提供220伏交流电， 有的提供110伏交流电，有的则提供有线电视节目。 客户软件将插头插到不同编号的插座，就可以得到不同的服务。</p>
<p>​                                                                        ——百度百科</p>
</blockquote>
<p><strong>创建TCP、UDP客户端和服务端</strong></p>
<p>在node中，net模块提供创建基于TCP协议的网络通信的API，<code>net.Socket</code>类提供了 TCP 或 UNIX Socket 的抽象，<code>net.createServer</code>用于创建服务端，<code>net.Socket</code>和<code>net.connect</code>用于创建客户端。</p>
<p>dgram模块用于创建基于UDP协议的网络服务，创建不分客户端不分客户端、服务器端，在一端使用<code>dgram.createSocket</code>即可发送数据也可以接收数据。</p>
<h3 id="http-https"><a href="#http-https" class="headerlink" title="http/https"></a>http/https</h3><p>http是应用层协议，建立在TCP/IP之上，https则建立在TLS、SSL加密层协议之上，现代web基本都是http/https应用。TCP在建立连接要发送报文，http也是，http报文分为请求报文和响应报文，报文格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK    //起始行</span><br><span class="line"></span><br><span class="line">Content-type:text/plain    //头部</span><br><span class="line">Content-length:19            //头部  </span><br><span class="line"></span><br><span class="line">Hi I&apos;m a message!    //主体</span><br></pre></td></tr></table></figure>
<p>其中最重要的莫过于头部报文了，它定义了请求或响应的行为方式，是客户端与服务器端交流的重要信息。http报文头部的属性多达几十个，而且越来越多，保证客户端与服务器端充分交流。</p>
<p>现代浏览器，集成了HTTP代理功能，用户点击链接等行为会由浏览器生成HTTP请求报文发送给服务器端，收到响应后会解析报文，渲染报文中的主体内容。</p>
<p><strong>node中的http</strong></p>
<p>node中http模块提供创建基于http协议的网络通信应用的接口，继承于net模块，采用事件驱动机制，能与多个客户端保持连接，并不为每个连接开启新的进程或线程，低内存、高并发，性能优良。</p>
<blockquote>
<p>“http模块将连接所用套接字(socket)的读写抽象为ServerRequest和ServerResponse对象，它们分别对应请求和响应操作。在请求产生的过程中，http模块拿到连接中传来的数据，调用二进制模块http_parser进行解析，在解析完请求报文的报头后，触发request事件，调用用户的业务逻辑。”</p>
<p>​                                                            ——朴灵《深入浅出Node.js》</p>
</blockquote>
<p><img src="http://ot6vbgl2y.bkt.clouddn.com/17-11-16/38855201.jpg" alt=""></p>
<p>从上图可以看到，node中http模块所做的事情就是继承net模块使用TCP协议、封装http请求、产生http事件、响应事件绑定的处理程序。</p>
<p><strong>http代理</strong></p>
<p>node中http模块提供了一个类<code>http.Agent</code>，它称为http代理，它的作用就是为了重用TCP连接，减少资源浪费。那么http代理是如何重用TCP连接呢？http代理维护一个连接池，从客户端发起的http请求都经由代理管理：</p>
<p><img src="http://ot6vbgl2y.bkt.clouddn.com/17-11-16/33274908.jpg" alt=""></p>
<blockquote>
<p>它为一个给定的主机与端口维护着一个等待请求的队列，且为每个请求重复使用一个单一的 socket(TCP) 连接直到队列为空，此时 socket(TCP 连接) 会被销毁或被放入一个连接池中，在连接池中等待被有着相同主机与端口的请求再次使用。 是否被销毁或被放入连接池取决于 <code>keepAlive</code>选项</p>
<p>​                                                                ——Node.js 8.9.0中文文档</p>
</blockquote>
<p>连接池如何管理连接还得取决于服务器：</p>
<blockquote>
<p>即便连接池中的连接的 TCP Keep-Alive 是开启的，服务器仍然可能关闭闲置的连接，在这种情况下，这些连接会被移出连接池，且当一个新的 HTTP 请求被创建时再为指定的主机与端口创建一个新的连接。 服务器也可能拒绝允许同一连接上有多个请求，在这种情况下，连接会为每个请求重新创建，且不能被放入连接池。<code>Agent</code> 仍然会创建请求到服务器，但每个请求会出现在一个新的连接。</p>
<p>但一个连接被客户端或服务器关闭时，它会被移出连接池。 连接池中任何未被使用的 socket 会被释放，从而使 Node.js 进程在没有请求时不用保持运行。</p>
<p>​                                                                ——Node.js 8.9.0中文文档</p>
</blockquote>
<p>http模块除了提供代理类，还提供了：</p>
<ul>
<li>http.ClientRequest类—— 表示一个正在处理的请求，这个请求还能设置请求头</li>
<li>http.Server类——继承<code>net.Server</code>，并添加了一些事件</li>
<li>http.ServerResponse类——代表响应</li>
<li>http.createServer方法——创建服务器，返回http.Server实例</li>
<li>http.request方法——显式发出请求</li>
<li>各种请求、响应对应的事件</li>
</ul>
<p><strong>创建http服务器</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node创建服务器非常简单，不需要任何三方代理</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;)</span><br><span class="line">  res.end(<span class="string">'Hello World\n'</span>);</span><br><span class="line">&#125;).listen(<span class="number">8880</span>, <span class="string">'127.0.0.1'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server running at http://127.0.0.1:8880/'</span>)</span><br></pre></td></tr></table></figure>
<p><strong>创建http请求</strong></p>
<p>使用<code>http.request</code>即可发送请求。</p>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>一问一答是HTTP协议的特点，然而服务器主动向客户端推送数据的场景也是常见的、被需要的。在WebSocket出现之前，实现客户端和服务器端双工通信一般只能通过多开几个HTTP连接、以轮询方式来实现。由于HTTP一问一答的特点不适合这种场景，就算HTTP1.1新增的Keep-Alive也不能很好的解决这种问题，于是WebSocket协议就出现了。</p>
<p>WebSocket协议可以让客户端与服务器端实现双向通信，服务端可以主动发送数据到客户端。建立WebSocket协议连接时，客户端会发送一条HTTP请求，请求服务器端切换协议为WebSocket，服务器端如果支持WebSocket协议，就会返回一条HTTP响应表示正在切换WebSocket协议并切换。之后就可以互相发送数据了。</p>
<p>使用WebSocket协议构建应用有以下优点：</p>
<ul>
<li>客户端可以与服务器端实现双向通信，服务端可以主动发送数据到客户端</li>
<li>通过第一个request建立了TCP连接之后，之后交换的数据都不需要发送 HTTP header就能交换数据</li>
</ul>
<p>目前大多数浏览器已经实现WebSocket，可以直接使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:3000/'</span>) <span class="comment">// 路径中的协议改为ws(WebSocket)</span></span><br><span class="line">socket.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 连接打开要做的事</span></span><br><span class="line">&#125;;</span><br><span class="line">socket.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 接收到服务端的信息（event.data）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>调用WebSocket后浏览器会发送一个HTTP请求，请求报文如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET /chat HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket // 请求协议升级为websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ== //校验值</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure>
<p>在Node原生模块中没有支持WebSocket协议连接功能的模块，但Node有很多三方模块来帮助做这件事，常用的ws模块方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入WebSocket模块:</span></span><br><span class="line"><span class="keyword">const</span> WebSocket = <span class="built_in">require</span>(<span class="string">'ws'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用Server类:</span></span><br><span class="line"><span class="keyword">const</span> WebSocketServer = WebSocket.Server;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化:</span></span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> WebSocketServer(&#123;     <span class="comment">// 在本地3000端口打开一个WebSocket Server</span></span><br><span class="line">    port: <span class="number">3000</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">wss.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">ws</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`[SERVER] connection()`</span>);</span><br><span class="line">    ws.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">message</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`[SERVER] Received: <span class="subst">$&#123;message&#125;</span>`</span>);</span><br><span class="line">        ws.send(<span class="string">`ECHO: <span class="subst">$&#123;message&#125;</span>`</span>, (err) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`[SERVER] error: <span class="subst">$&#123;err&#125;</span>`</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>服务器返回的响应报文如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo= // 返回经过计算得出的校验值 </span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure>
<h3 id="使用框架进行网络编程"><a href="#使用框架进行网络编程" class="headerlink" title="使用框架进行网络编程"></a>使用框架进行网络编程</h3><p>Node网络模块中提供的API较为底层，有时在构建网络应用程序并不需要关心底层实现，这时就可以借助三方框架封装好的API来帮助我们，常用的框架包括express、koa、connect等。</p>
</div><div class="tags"><a href="/tags/node/">node</a><a href="/tags/node基础/">node基础</a></div><div class="post-share"></div><div class="post-nav"><a href="/2018/02/11/react-source-code-analysis-1-after-ReactDOM.render/" class="pre">React源码分析(一)-调用ReactDOM.render后发生了什么</a><a href="/2017/11/10/认识node核心模块-从Buffer、Stream到fs/" class="next">认识node核心模块--从Buffer、Stream到fs</a></div><div id="comments"><div id="container"></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="React"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#正文"><span class="toc-text">正文</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-UDP"><span class="toc-text">TCP/UDP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http-https"><span class="toc-text">http/https</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebSocket"><span class="toc-text">WebSocket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用框架进行网络编程"><span class="toc-text">使用框架进行网络编程</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/06/29/learning-about-the-operating-system/">操作系统了解一下</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/02/a-comprehensive-understanding-of-HTTP/">全面了解HTTP</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/17/react-source-code-analysis-3-update/">React源码分析(三)-全面剖析组件更新机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/17/react-source-code-analysis-2-initial-render/">React源码分析(二)-组件的初始渲染</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/11/react-source-code-analysis-1-after-ReactDOM.render/">React源码分析(一)-调用ReactDOM.render后发生了什么</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/21/认识node核心模块-网络编程/">认识node核心模块--网络编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/10/认识node核心模块-从Buffer、Stream到fs/">认识node核心模块--从Buffer、Stream到fs</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/03/认识node核心模块-深入EventEmitter/">认识node核心模块--深入EventEmitter</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/25/认识node核心模块-全局对象及Cluster/">认识node核心模块--全局对象及Cluster</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/14/node核心特性理解/">node核心特性理解</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/源码分析/" style="font-size: 15px;">源码分析</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/React/" style="font-size: 15px;">React</a> <a href="/tags/React架构/" style="font-size: 15px;">React架构</a> <a href="/tags/感想/" style="font-size: 15px;">感想</a> <a href="/tags/HTTP/" style="font-size: 15px;">HTTP</a> <a href="/tags/dva/" style="font-size: 15px;">dva</a> <a href="/tags/操作系统/" style="font-size: 15px;">操作系统</a> <a href="/tags/node/" style="font-size: 15px;">node</a> <a href="/tags/node基础/" style="font-size: 15px;">node基础</a> <a href="/tags/JavaScript函数/" style="font-size: 15px;">JavaScript函数</a> <a href="/tags/React基础/" style="font-size: 15px;">React基础</a> <a href="/tags/Redux/" style="font-size: 15px;">Redux</a> <a href="/tags/Redux-saga/" style="font-size: 15px;">Redux saga</a> <a href="/tags/JavaScript对象/" style="font-size: 15px;">JavaScript对象</a> <a href="/tags/前端工程师/" style="font-size: 15px;">前端工程师</a> <a href="/tags/职业规划/" style="font-size: 15px;">职业规划</a> <a href="/tags/事件循环机制/" style="font-size: 15px;">事件循环机制</a> <a href="/tags/实习/" style="font-size: 15px;">实习</a> <a href="/tags/面试题/" style="font-size: 15px;">面试题</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://mofan_tcg.coding.me/" title="时光笔记" target="_blank">时光笔记</a><ul></ul><a href="http://realtcg.com/Precious-Memories/" title="React小相册" target="_blank">React小相册</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p>你的梦想是这个世界上最伟大的事情</p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">mofan.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/MrStronger/hexo-theme-Mofan"> Mofan.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?3f3a5a8fd2b4cc3b3813fd00426fa25d";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment = new Gitment({
  id: '认识node核心模块--网络编程', // 可选。默认为 location.href
  owner: 'MrStronger',
  repo: 'blogcomment',
  oauth: {
    client_id: '0a99d84bb46f7cda7fce',
    client_secret: 'b3915ea2a1e5364a698ec8335e34092ad6bc42d0',
  },
})
gitment.render('container')
</script></body></html>