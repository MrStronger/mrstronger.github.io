<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="莫凡的个人博客"><title>认识node核心模块--深入EventEmitter | 莫凡</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"></head><body><div class="body_container"><div id="header"><div class="site-name"><a id="logo" href="/."><img src="http://ot6vbgl2y.bkt.clouddn.com/17-7-18/91792276.jpg" class="logoImg"><span id="hidden">认识node核心模块--深入EventEmitter</span></a></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">认识node核心模块--深入EventEmitter</h1><div class="post-meta"><a href="/2017/11/03/认识node核心模块-深入EventEmitter/#comments" class="comment-count"></a><p><span class="date">Nov 03, 2017</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>node 采用了事件驱动机制，而EventEmitter 就是node实现事件驱动的基础。在EventEmitter的基础上，node 几乎所有的模块都继承了这个类，以实现异步事件驱动架构。继承了EventEmitter的模块，拥有了自己的事件，可以绑定／触发监听器，实现了异步操作。EventEmitter是node事件模型的根基，由EventEmitter为基础构建的事件驱动架构处处体现着异步编程的思想，因此，我们在构建node程序时也要遵循这种思想。EventEmitter实现的原理是观察者模式，这也是实现事件驱动的基本模式。本文将围绕EventEmitter，从中探讨它的原理观察者模式、体现的异步编程思想以及应用。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="events模块的EventEmitter类"><a href="#events模块的EventEmitter类" class="headerlink" title="events模块的EventEmitter类"></a>events模块的EventEmitter类</h3><p>node 的events模块只提供了一个EventEmitter类，这个类实现了node异步事件驱动架构的基本模式——观察者模式，提供了绑定事件和触发事件等事件监听器模式一般都会提供的API：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEmitter</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;&#125;</div><div class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> MyEmitter()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'触发了event事件！'</span>)</div><div class="line">&#125;</div><div class="line">myEmitter.on(<span class="string">'event'</span>, callback)</div><div class="line">myEmitter.emit(<span class="string">'event'</span>)</div><div class="line">myEmitter.removeListener(<span class="string">'event'</span>, callback);</div></pre></td></tr></table></figure>
<p>只要继承EventEmitter类就可以拥有事件、触发事件等，所有能触发事件的对象都是 <code>EventEmitter</code> 类的实例。</p>
<p>而观察者模式(事件发布／订阅模式)就是实现EventEmitter类的基本原理，也是事件驱动机制基本模式。</p>
<h3 id="事件驱动原理：观察者模式"><a href="#事件驱动原理：观察者模式" class="headerlink" title="事件驱动原理：观察者模式"></a>事件驱动原理：观察者模式</h3><p>在事件驱动系统里，事件是如何产生的？一个事件发生为什么能”自动”调用回调函数？我们先看看观察者模式。</p>
<p>观察者(Observer)模式是一种设计模式，应用场景是当一个对象的变化需要通知其他多个对象而且这些对象之间需要松散耦合时。在这种模式中，被观察者(主体)维护着一组其他对象派来(注册)的观察者，有新的对象对主体感兴趣就注册观察者，不感兴趣就取消订阅，主体有更新的话就依次通知观察者们。说猿话就是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Subject</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.listeners = &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Subject.prototype = &#123;</div><div class="line">	<span class="comment">// 增加事件监听器</span></div><div class="line">    addListener: <span class="function"><span class="keyword">function</span>(<span class="params">eventName, callback</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> callback !== <span class="string">'function'</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'"listener" argument must be a function'</span>)</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.listeners[eventName] === <span class="string">'undefined'</span>) &#123;</div><div class="line">            <span class="keyword">this</span>.listeners[eventName] = []</div><div class="line">        &#125; </div><div class="line">        <span class="keyword">this</span>.listeners[eventName].push(callback) <span class="comment">// 放到观察者对象中</span></div><div class="line">    &#125;,</div><div class="line">	<span class="comment">// 取消监听某个回调</span></div><div class="line">    removeListener: <span class="function"><span class="keyword">function</span>(<span class="params">eventName, callback</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> callback !== <span class="string">'function'</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'"listener" argument must be a function'</span>)</div><div class="line">        <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(<span class="keyword">this</span>.listeners[eventName]) &amp;&amp; <span class="keyword">this</span>.listeners[eventName].length !== <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">var</span> callbackList = <span class="keyword">this</span>.listeners[eventName]</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len=callbackList.length; i &lt; len; i++) &#123;</div><div class="line">                <span class="keyword">if</span>(callbackList[i] === callback) &#123;</div><div class="line">                    <span class="keyword">this</span>.listeners[eventName].splice(i,<span class="number">1</span>) 	<span class="comment">// 找到监听器并从观察者对象中删除</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">	<span class="comment">// 触发事件：在观察者对象里找到这个事件对应的回调函数队列，依次执行</span></div><div class="line">    triggerEvent: <span class="function"><span class="keyword">function</span>(<span class="params">eventName,...args</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.listeners[eventName]) &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>, len=<span class="keyword">this</span>.listeners[eventName].length; i&lt;len; i++)&#123;</div><div class="line">                <span class="keyword">this</span>.listeners[eventName][i](...args)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OK，我们现在来添加监听器和发送事件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> Subject()</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'hello, there'</span>)</div><div class="line">&#125;</div><div class="line">event.addListener(<span class="string">'hello'</span>, hello)</div><div class="line">event.triggerEvent(<span class="string">'hello'</span>) 	<span class="comment">//	输出 hello, there</span></div><div class="line">event.removeListener(<span class="string">'hello'</span>, hello) <span class="comment">// 取消监听</span></div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> event.triggerEvent(<span class="string">'hello'</span>),<span class="number">1000</span>) <span class="comment">// 过了一秒什么也没输出</span></div></pre></td></tr></table></figure>
<p>在观察者模式中，注册的回调函数即事件监听器，触发事件调用各个回调函数即是发布消息。</p>
<p>你可以看到，观察者模式只不过维护一个信号对应函数的列表，可以存，可以除，你只要给它信号(索引)，它就按照这个信号执行对应的函数，也就相当于间接调用了。那直接调用函数不就行了，干嘛写的那么拐弯抹角？刚才也说了，这是因为观察者模式能够解耦对象之间的关系，实现了表示层和数据逻辑层的分离，并定义了稳定的更新消息传递机制。</p>
<p>回到开始的问题，事件是如何产生又“自动”被调用的？是像上面那样当调用<code>event.triggerEvent</code>的时侯产生的吗？并不是，调用<code>event.triggerEvent</code>就相当于调用了回调函数，是事件执行过程，而事件产生过程则更多由底层来产生并通知给node的。我们拿node的全局变量 process来举例，process是EventEmitter的实例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">process.on(<span class="string">'exit'</span>, (code) =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`About to exit with code: <span class="subst">$&#123;code&#125;</span>`</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>node执行时会在process的exit事件上绑定你指定的回调，相当于调用了上面的<code>addListener</code>，而当你退出进程时，你会发现你指定的函数被执行了，但是你没有手动调用触发exit事件的方法，也就是上面的<code>triggerEvent</code>，这是因为node底层帮你调用了——操作系统底层使这个进程退出了，node会得到这个信息，然后触发事先定义好的触发方法，回调函数就因此依次执行了。像这样的内置事件是node模块事先写好并开放出来的，使用时直接绑定回调函数即可，如果要自定义事件，那就得自己发送信号了。</p>
<p>上面代码实现了最基本的观察者模式，<strong>node 源码中EventEmitter的实现原理跟这差不多</strong>，除了这些还加入了其他有用的特性，而且各种实现都尽可能使用性能最好的方式(node源码真是处处反映着智慧的光芒)。</p>
<p>node中众多模块都继承了EventEmitter，比如文件模块系统下的<code>FSWatcher</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>)</div><div class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>)</div><div class="line">...</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">FSWatcher</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  EventEmitter.call(<span class="keyword">this</span>);<span class="comment">// 调用构造函数</span></div><div class="line">  ...</div><div class="line">&#125;</div><div class="line">util.inherits(FSWatcher, EventEmitter); <span class="comment">// 继承 EventEmitter</span></div></pre></td></tr></table></figure>
<p>其他模块也是如此。它们一同组成了node的异步事件驱动架构。</p>
<h3 id="异步编程范式"><a href="#异步编程范式" class="headerlink" title="异步编程范式"></a>异步编程范式</h3><p>可以看到，由于采用事件模型和异步I／O，node中大量模块的API采用了异步回调函数的方式，底层也处处体现了异步编程的方式。虽然异步也带来了很多问题——理解困难、回调嵌套过深、错误难以捕捉、多线程编程困难等，不过相比于异步带来的高性能，加上这些问题都有比较好的解决方案，异步编程范式还是很值得尝试的，尤其对于利用node构建应用程序的时候。</p>
<p><strong>从最基本的回调函数开始</strong></p>
<p>回调函数是异步编程的体现，而回调函数的实现离不开高阶函数。得益于javascript语言的灵活性，函数作为参数或返回值，而将函数作为参数或返回值的函数就是高阶函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x,bar</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> bar(x)</div><div class="line">&#125;<span class="comment">// 对于相同的foo，传进去不同的bar就有不同的操作结果</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</div><div class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item,index</span>)</span>&#123;</div><div class="line">    <span class="comment">// do something for every item</span></div><div class="line">&#125;) <span class="comment">// 数组的高阶函数</span></div><div class="line"></div><div class="line">event.addListener(<span class="string">'hello'</span>, hello) <span class="comment">// 还有上面观察者模式实现的addListener</span></div></pre></td></tr></table></figure>
<p>基于高阶函数的特性，就可以实现回调函数的模式。实际上，正式因为javascript函数用法非常灵活，才有高阶函数和众多设计模式。</p>
<p><strong>采用事件发布／订阅模式(观察者模式)</strong></p>
<p>单纯地使用高阶函数特性不足以构建简单、灵活、强大的异步编程模式的应用程序，我们需要从其他语言借鉴一些设计模式。就像上面提到的，node的events模块实现了事件发布／订阅模式，这是一种广泛用于异步编程的模式。它将回调函数事件化，将事件与各回调函数相关联，注册回调函数就是添加事件监听器，这些事件监听器可以很方便的添加、删除、被执行，使得事件和处理逻辑（注册的回调函数）之间轻松实现关联和解耦——事件发布者无需关注监听器是如何实现业务逻辑的，也不用关注有多少个事件监听器，只需按照消息执行即可，而且数据通过这种消息的方式可以灵活的传递。</p>
<p>不仅如此，这种模式还可以实现像类一样的对功能进行封装：将不变的逻辑封装在内部，将需要自定义、容易变化的部分通过事件暴露给外部定义。Node中很多对象大多都有这样黑盒子的特点，通过事件钩子，可以使使用者不用关注这个对象是如何启动的，只需关注自己关注的事件即可。</p>
<p>像大多数node核心模块一样，继承EventEmitter，我们就可以使用这种模式，帮助我们以异步编程方式构建node程序。</p>
<p><strong>利用Promise</strong></p>
<p>Promise是CommonJs发布的一个规范，它的出现给异步编程带来了方便。Promise所作的只是封装了异步调用、嵌套回调，使得原本复杂嵌套逻辑不清的回调变得优雅和容易理解。有了Promise的封装，你可以这样写异步调用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'步骤一：执行'</span>);</div><div class="line">        resolve(<span class="string">'1'</span>);</div><div class="line">    &#125;,<span class="number">500</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'步骤二：执行'</span>);</div><div class="line">        resolve(<span class="string">'2'</span>);</div><div class="line">    &#125;,<span class="number">100</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(fn1).then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(val);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(fn2);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(val);</div><div class="line">    <span class="keyword">return</span> <span class="number">33</span>;</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(val);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>那Promise是如何封装的呢？</p>
<p>首先，Promise经常用于处理异步、延时操作，为了放在then里面的”接下来要做的事“以正确的顺序被执行，Promise被设计为状态机，状态变化为pending =&gt; resolve（成功）、pending =&gt; reject（失败），而且，Promise还维护成功或失败时要执行的函数List，List中的回调正是Promise处在pending状态时将then中注册的回调push进去的；Promise内部有一个resolve和reject函数，分别在成功／失败时执行函数List，并且这两个函数会传递给回调函数，由用户决定什么时候resolve/reject；为了实现链式调用，then中返回的是promise：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserId</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, i</span>) </span>&#123;</div><div class="line">        <span class="comment">//异步请求</span></div><div class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'异步操作成功，下一步执行promise的'</span>+i+<span class="string">'的resolve'</span>)</div><div class="line">            resolve(<span class="string">'Fuck you Promise!'</span>, i)</div><div class="line">        &#125;,<span class="number">1000</span>)</div><div class="line">    &#125;, <span class="number">1</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">getUserId().then(<span class="function"><span class="keyword">function</span>(<span class="params">words</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(words)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 实现</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn, i</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> i = i</div><div class="line">    <span class="keyword">var</span> state = <span class="string">'pending'</span></div><div class="line">    <span class="keyword">var</span> result = <span class="literal">null</span></div><div class="line">    <span class="keyword">var</span> promises = []</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Promise'</span> + i + <span class="string">'constructing'</span>)</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'then被调用'</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'返回一个promise'</span>)</div><div class="line">            handle(&#123;</div><div class="line">                onFulfilled: onFulfilled || <span class="literal">null</span>,</div><div class="line">                resolve: <span class="function"><span class="keyword">function</span>(<span class="params">ret, i</span>) </span>&#123;resolve(ret,i)&#125;</div><div class="line">            &#125;)</div><div class="line">        &#125;,<span class="number">2</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">promise</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span>(state === <span class="string">'pending'</span>) &#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'promise'</span> + i + <span class="string">'还在pending中'</span>)</div><div class="line">            promises.push(promise)</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'注册回调'</span>)</div><div class="line">            <span class="keyword">return</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(!promise.onFulfilled) &#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'回调为空，resolve结果'</span>)</div><div class="line">            promise.resolve(result, i)</div><div class="line">            <span class="keyword">return</span></div><div class="line">        &#125;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'执行回调'</span>)</div><div class="line">        <span class="keyword">var</span> ret = promise.onFulfilled(result)</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'处理回调返回的值(可能是另一个promise)'</span>)</div><div class="line">        promise.resolve(ret, <span class="number">2</span>)</div><div class="line">        </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">newResult, i</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'执行promise'</span> + i + <span class="string">'的resolve'</span>)</div><div class="line">        <span class="keyword">if</span>(newResult &amp;&amp; (<span class="keyword">typeof</span> newResult === <span class="string">'object'</span> || <span class="keyword">typeof</span> newResult === <span class="string">'function'</span>)) &#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'then中注册的回调返回了promise'</span>)</div><div class="line">            <span class="keyword">var</span> then = newResult.then</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">'调用then'</span>)</div><div class="line">                then.call(newResult, resolve)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'设置promise'</span> + i + <span class="string">'的状态为fulfilled'</span>)</div><div class="line">        state = <span class="string">'fulfilled'</span></div><div class="line">        result = newResult</div><div class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'遍历promise'</span> + i + <span class="string">'注册的回调执行'</span>)</div><div class="line">            <span class="built_in">console</span>.log(promises[<span class="number">0</span>])</div><div class="line">            promises.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">promise</span>) </span>&#123;</div><div class="line">                handle(promise)</div><div class="line">            &#125;);</div><div class="line">        &#125;,<span class="number">0</span>)</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'传resolve到promise'</span> + i + <span class="string">'函数参数'</span>)</div><div class="line">    fn(resolve, i)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意，这是Promise/A+规范的简单实现，还有reject原理一样的。我在这里为了更好的理解promise，不至于弄混乱，加入了标号，方便理解，Promise/A+规范里并没有。</p>
<p>实际上，node高版本已经支持promise了，可以直接使用，但不如Bluebird这类三方库快，而且Bluebird扩展了很多Promise/A+没有的方法。</p>
<p><strong>使用第三方库Async/Step</strong></p>
<p>async是著名的流程控制库，经常被npm install，它提供了20多个方法帮助我们处理异步协作模式。比如：</p>
<ul>
<li>series ——异步任务的串行执行，就像Promise一样，只不过形式不同</li>
<li>parallel——异步任务并行执行，相当于Promise.all</li>
<li>waterfall——处理具有依赖关系的异步调用，比如前一个结果是后一个输入</li>
<li>auto——自动分析异步调用的依赖关系，参数是一个依赖关系对象</li>
<li>…</li>
</ul>
<p>Step比async更轻量、更简单，只有一个接口Step, 在接口里可以调用Step提供的方法，功能与async差不多。</p>
<p>异步编程范式远不止这么多，还有很多重要的思想、设计模式，还有一些需要在实践中去发现、总结。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>EventEmitter提供的接口非常简单，但是它背后体现的思想贯穿了Node整个架构。Node不是第一个使用异步编程的平台，但异步架构在Node中处处体现，是Node设计的基本思想。在学习node时，透过现象看本质、深入浅出，是一个明智的方法，对待任何事物也是如此。</p>
<p>参考文献：</p>
<ul>
<li><a href="https://segmentfault.com/a/1190000009478377" target="_blank" rel="external">https://segmentfault.com/a/1190000009478377</a></li>
<li>【朴灵】《深入浅出Node.Js》</li>
</ul>
</div><div class="tags"><a href="/tags/node/">node</a><a href="/tags/node基础/">node基础</a></div><div class="post-share"></div><div class="post-nav"><a href="/2017/11/10/认识node核心模块-从Buffer、Stream到fs/" class="pre">认识node核心模块--从Buffer、Stream到fs</a><a href="/2017/10/25/认识node核心模块-全局对象及Cluster/" class="next">认识node核心模块--全局对象及Cluster</a></div><div id="comments"><div id="container"></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="React"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#正文"><span class="toc-text">正文</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#events模块的EventEmitter类"><span class="toc-text">events模块的EventEmitter类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件驱动原理：观察者模式"><span class="toc-text">事件驱动原理：观察者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异步编程范式"><span class="toc-text">异步编程范式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/02/11/React源码分析/">React源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/21/认识node核心模块-网络编程/">认识node核心模块--网络编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/10/认识node核心模块-从Buffer、Stream到fs/">认识node核心模块--从Buffer、Stream到fs</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/03/认识node核心模块-深入EventEmitter/">认识node核心模块--深入EventEmitter</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/25/认识node核心模块-全局对象及Cluster/">认识node核心模块--全局对象及Cluster</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/14/node核心特性理解/">node核心特性理解</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/27/我对前端工程师这个职业的看法/">我对前端工程师这个职业的看法</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/21/浏览器中的事件循环机制/">浏览器中的事件循环机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/19/面试-实习心得/">面试&实习心得</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/25/dva值得一试/">dva值得一试</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/JavaScript对象/" style="font-size: 15px;">JavaScript对象</a> <a href="/tags/感想/" style="font-size: 15px;">感想</a> <a href="/tags/dva/" style="font-size: 15px;">dva</a> <a href="/tags/React架构/" style="font-size: 15px;">React架构</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/JavaScript函数/" style="font-size: 15px;">JavaScript函数</a> <a href="/tags/node/" style="font-size: 15px;">node</a> <a href="/tags/node基础/" style="font-size: 15px;">node基础</a> <a href="/tags/React/" style="font-size: 15px;">React</a> <a href="/tags/React基础/" style="font-size: 15px;">React基础</a> <a href="/tags/Redux/" style="font-size: 15px;">Redux</a> <a href="/tags/Redux-saga/" style="font-size: 15px;">Redux saga</a> <a href="/tags/事件循环机制/" style="font-size: 15px;">事件循环机制</a> <a href="/tags/前端工程师/" style="font-size: 15px;">前端工程师</a> <a href="/tags/职业规划/" style="font-size: 15px;">职业规划</a> <a href="/tags/实习/" style="font-size: 15px;">实习</a> <a href="/tags/面试题/" style="font-size: 15px;">面试题</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://mofan_tcg.coding.me/" title="时光笔记" target="_blank">时光笔记</a><ul></ul><a href="http://realtcg.com/Precious-Memories/" title="React小相册" target="_blank">React小相册</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p>你的梦想是这个世界上最伟大的事情</p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">mofan.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/MrStronger/hexo-theme-Mofan"> Mofan.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?3f3a5a8fd2b4cc3b3813fd00426fa25d";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment = new Gitment({
  id: '认识node核心模块--深入EventEmitter', // 可选。默认为 location.href
  owner: 'MrStronger',
  repo: 'blogcomment',
  oauth: {
    client_id: '0a99d84bb46f7cda7fce',
    client_secret: 'b3915ea2a1e5364a698ec8335e34092ad6bc42d0',
  },
})
gitment.render('container')
</script></body></html>