<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="莫凡的个人博客"><title>浏览器中的事件循环机制 | 莫凡</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"></head><body><div class="body_container"><div id="header"><div class="site-name"><a id="logo" href="/."><img src="http://ot6vbgl2y.bkt.clouddn.com/18-2-12/7859845.jpg" class="logoImg"><span id="hidden">浏览器中的事件循环机制</span></a></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">浏览器中的事件循环机制</h1><div class="post-meta"><a href="/2017/09/21/浏览器中的事件循环机制/#comments" class="comment-count"></a><p><span class="date">Sep 21, 2017</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>网上一搜事件循环, 很多文章标题的前面会加上 JavaScript, 但是我觉得事件循环机制跟 JavaScript 没什么关系, JavaScript 只是一门解释型语言, 方便开发和理解的, 由V8 JIT将 JavaScript 编译成机器语言来调用底层,  至于浏览器怎么执行 JavaScript 代码, JavaScript 管不着也不关心. 因此, “JavaScript事件循环机制”这种说法是不合理的. 事件循环机制是由运行时环境实现的, 具体来说有浏览器、Node等. 这篇文章就先来说说浏览器中实现的事件循环机制.</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>首先，javascript 在浏览器端运行是单线程的，这是由浏览器决定的，这是为了避免多线程执行不同任务会发生冲突的情况。也就是说我们写的javascript 代码只在一个线程上运行，称之为主线程（HTML5提供了web worker API可以让浏览器开一个线程运行比较复杂耗时的 javascript任务，但是这个线程仍受主线程的控制）。单线程的话，如果我们做一些“sleep”的操作比如说：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> now = + <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"><span class="keyword">while</span> (+<span class="keyword">new</span> <span class="built_in">Date</span>() &lt;= now + <span class="number">1000</span>)&#123;</span><br><span class="line"><span class="comment">//这是一个耗时的操所</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么在这将近一秒内，线程就会被阻塞，无法继续执行下面的任务。</p>
<p>还有些操作比如说获取远程数据、I/O操作等，他们都很耗时，如果采用同步的方式，那么进程在执行这些操作时就会因为耗时而等待，就像上面那样，下面的任务也只能等待，这样效率并不高。</p>
<p><strong>那浏览器是怎么做的呢?</strong> </p>
<p>我们找到WHATWG规范对<a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops" target="_blank" rel="noopener">Event loop</a>的介绍:</p>
<p><img src="http://ot6vbgl2y.bkt.clouddn.com/18-1-7/98296999.jpg" alt="WHATWG Event loop定义"></p>
<p><strong>为了协调事件，用户交互，脚本，渲染，网络等，用户代理必须使用事件循环。</strong></p>
<p>事件循环的主要机制就是<strong>任务队列机制</strong>:</p>
<ul>
<li>一个事件循环有一个或者多个<code>任务队列</code>（task queues）。任务队列是task的有序列表，task是调度Events，Parsing，Callbacks，Using a resource，Reacting to DOM manipulation这些任务的算法;</li>
<li>每个任务都来自一个特定的<code>任务源</code>（task source）(比如鼠标键盘事件)。来自同一个特定任务源且属于特定事件循环的任务必须被加入到同一个任务队列中，来自不同任务源的任务可以放在不同的任务队列中;</li>
<li>浏览器调用这些队列中的任务时采取这样的做法: 相同队列中的任务按照先进先出的顺序, 不同的队列按照提前设置的队列优先级来调用. 例如，用户代理可以有一个用于鼠标和键盘事件的任务队列（用户交互任务源），另一个用于其他任务。然后，用户代理75%概率调用键盘和鼠标事件任务队列，25%调用其他队列, 这样的话就保持界面响应而且不会饿死其他任务队列. 但是相同队列中的任务要按照先进先出的顺序。也就是说单独的任务队列中的任务总是按先进先出的顺序执行，但是<strong>不保证多个任务队列中的任务优先级，具体实现可能会交叉执行</strong></li>
</ul>
<p>在调用任务的过程中, 会产生新的任务, 浏览器就会不断执行任务, 因此称为事件循环.</p>
<p><strong>microtask queue 微任务队列</strong></p>
<p>还有一些特殊任务, 它们不会被放在task queues中, 会放在一个叫做<strong>microtask(微任务) queue</strong>中, 继续看标准:</p>
<blockquote>
<p>Each <a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop" target="_blank" rel="noopener">event loop</a> has <strong>a</strong> microtask queue. A microtask is a <a href="https://html.spec.whatwg.org/multipage/webappapis.html#concept-task" target="_blank" rel="noopener">task</a> that is originally to be queued on the <a href="https://html.spec.whatwg.org/multipage/webappapis.html#microtask-queue" target="_blank" rel="noopener">microtask queue</a> rather than a <a href="https://html.spec.whatwg.org/multipage/webappapis.html#task-queue" target="_blank" rel="noopener">task queue</a>. </p>
</blockquote>
<p>任务队列可以有多个, 但是微任务队列只有一个.</p>
<p>那么哪些任务是放在task queue, 哪些放在microtask queue呢? 通常对浏览器和Node.js来说: </p>
<ul>
<li><strong>macrotask(宏任务):</strong> script（整体代码）, <code>setTimeout</code>, <code>setInterval</code>, <code>setImmediate</code>, I/O, UI rendering等</li>
<li><strong>microtask(微任务):</strong> <code>process.nextTick</code>, <code>Promises</code>（这里指浏览器实现的原生 Promise）, <code>Object.observe</code>, <code>MutationObserver</code>等</li>
</ul>
<p>请尤其注意macrotask中<strong>执行整体代码也是一个宏任务</strong></p>
<p><strong>事件循环处理过程</strong></p>
<p>总体来说, 浏览器端事件循环的一个回合(go-around或者叫cycle)就是: </p>
<ul>
<li><strong>从macrotask队列中(task queue)取一个宏任务执行, 执行完后, 取出所有的microtask执行.</strong></li>
</ul>
<ul>
<li><strong>重复回合</strong></li>
</ul>
<p>无论在执行macrotask还是microtask, 都有可能产生新的macrotask或者microtask, 就这样继续执行.</p>
<p><strong>用任务队列机制解释异步操作顺序</strong></p>
<p>这里有一些常见异步操作:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> interval = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setInterval'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;  </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout 1'</span>)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise 3'</span>)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise 4'</span>)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'setTimeout 2'</span>)</span><br><span class="line">      <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise 5'</span>)</span><br><span class="line">      &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise 6'</span>)</span><br><span class="line">      &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      	clearInterval(interval)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise 1'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise 2'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>结果(Chrome 63.0.3239.84; Mac OS): </p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">promise <span class="number">1</span></span><br><span class="line">promise <span class="number">2</span></span><br><span class="line">setInterval</span><br><span class="line">setTimeout <span class="number">1</span></span><br><span class="line">promise <span class="number">3</span></span><br><span class="line">promise <span class="number">4</span></span><br><span class="line">setInterval <span class="comment">// 大部分情况下2次, 少数情况下一次</span></span><br><span class="line">setTimeout <span class="number">2</span></span><br><span class="line">promise <span class="number">5</span></span><br><span class="line">promise <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>这个顺序是如何得来的? </p>
<p>我们先讲promise 4后面只出现一次setInterval的情况,  画个图简单表示一下这个过程: </p>
<p><img src="http://ot6vbgl2y.bkt.clouddn.com/18-1-7/36416774.jpg" alt="任务队列机制"></p>
<blockquote>
<p><strong>注意</strong></p>
<p>本图为了方便把各时间段(Cycle)队列的任务都画在队列中去了, 实际上执行一个task 和 microtask 后就会把这个任务从相应队列中删除</p>
</blockquote>
<p>首先, 主任务就是执行脚本, 也就是执行上述代码, 这也是一个task. 在执行代码过程中,  遇到setTimeout、setInterval 就会将回调函数添加到task queue中, 遇到 promise 就会将then回调添加到 microtask 中去.</p>
<p>Task执行完, 接着取所有 microtask 执行, 所有microtask 执行完了, microtask queue也就空了, 接着再取task执行,  如果microtask queue为空, 没有任务, 则继续取下一个task执行, 就这样循环执行. 图中箭头就表示执行的顺序.</p>
<p><strong>那么为什么promise 4后面大部分情况下出现2次setInterval, 少数情况出现1次呢?</strong> </p>
<p><strong>我猜测</strong>这是因为setInterval是有最短间隔时间的(chrome下4ms左右), 这个时间不同机子、不同浏览器都有可能不一样. 代码中的参数是0, 意味着尽可能短的时间内就会产生一个task加入到 task queue中.  浏览器在执行setInterval后到执行下一个task前, 时间间隔就可能超过这个最短时间, 因此会产生一个setInterval task. </p>
<p>我是这样论证的:</p>
<p>我把含有promise5、promise6回调函数的setTimeout的时间设置大一点, 让它推迟插入task queue中:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...  </span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'setTimeout 2'</span>)</span><br><span class="line">      <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise 5'</span>)</span><br><span class="line">      &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise 6'</span>)</span><br><span class="line">      &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      	clearInterval(interval)</span><br><span class="line">      &#125;)</span><br><span class="line">&#125;, <span class="number">10</span>)   <span class="comment">//这里加上10ms </span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>结果是promise 4后面的setInterval出现了5次, 因此我觉得promise 4后面大部分情况下出现2次setInterval、少数情况出现一次的原因就是浏览器在执行setInterval回调函数后、执行setTimeout回调函数前, 时间间隔大部分情况超过了这个最短时间.</p>
<p>另外, 我试着再依次加上1ms, 直到14ms——也就是加上4ms时, promise 4后面的setInterval变成了6次, 可以认为setInterval最短间隔时间在Chrome下约为4ms(不考虑机子性能、设置).</p>
<p><strong>Node中的奇怪结果</strong></p>
<p>首先说明一下, 在Node中也体现了任务队列的机制, 但是这不是Node实现的, 这是V8实现的, 由Node调用了V8任务队列机制的API. 至于为什么是V8实现的, 我们翻翻<a href="http://www.ecma-international.org/ecma-262/#sec-jobs-and-job-queues" target="_blank" rel="noopener">ECMA 262</a> 标准对 Job 和 Job queue 的介绍就可以得知</p>
<p>但是让人摸不着头脑的是, 这段代码在node v8.5.0下<strong>有时</strong>会出现这样的结果:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">promise <span class="number">1</span></span><br><span class="line">promise <span class="number">2</span></span><br><span class="line">setInterval</span><br><span class="line">setTimeout <span class="number">1</span></span><br><span class="line">promise <span class="number">3</span></span><br><span class="line">promise <span class="number">4</span></span><br><span class="line">setInterval</span><br><span class="line">setTimeout <span class="number">2</span></span><br><span class="line">setInterval   <span class="comment">// 为什么会出现setInterval???</span></span><br><span class="line">promise <span class="number">5</span></span><br><span class="line">promise <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>按理说应该是setTimeout 2 =&gt; promise 5 =&gt; promise 6, 因为输出setTimeout 2的回调函数是task, 执行完这个task后应该调用microtask 输出promise 5 =&gt; promise 6啊? 很奇怪! Node对V8确实有些改动, 不知道是不是这方面原因…</p>
<p>还请大神解惑!</p>
<h3 id="你竟然读到这了"><a href="#你竟然读到这了" class="headerlink" title="你竟然读到这了"></a>你竟然读到这了</h3><p>总结一下:</p>
<p>学习技术还是有捷径的, 那就是读标准 ;)</p>
</div><div class="tags"><a href="/tags/事件循环机制/">事件循环机制</a></div><div class="post-share"></div><div class="post-nav"><a href="/2017/09/27/我对前端工程师这个职业的看法/" class="pre">我对前端工程师这个职业的看法</a><a href="/2017/09/19/面试-实习心得/" class="next">面试&amp;实习心得</a></div><div id="comments"><div id="container"></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="React"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#正文"><span class="toc-text">正文</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#你竟然读到这了"><span class="toc-text">你竟然读到这了</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/04/17/窥探React-源码分析-三-全面剖析组件更新机制/">窥探React-源码分析(三)-全面剖析组件更新机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/17/窥探React-源码分析(二)-组件的初始渲染/">窥探React-源码分析(二)-组件的初始渲染</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/11/窥探React-源码分析(一)-调用ReactDOM.render后发生了什么/">窥探React-源码分析(一)-调用ReactDOM.render后发生了什么</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/21/认识node核心模块-网络编程/">认识node核心模块--网络编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/10/认识node核心模块-从Buffer、Stream到fs/">认识node核心模块--从Buffer、Stream到fs</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/03/认识node核心模块-深入EventEmitter/">认识node核心模块--深入EventEmitter</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/25/认识node核心模块-全局对象及Cluster/">认识node核心模块--全局对象及Cluster</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/14/node核心特性理解/">node核心特性理解</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/27/我对前端工程师这个职业的看法/">我对前端工程师这个职业的看法</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/21/浏览器中的事件循环机制/">浏览器中的事件循环机制</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/Redux/" style="font-size: 15px;">Redux</a> <a href="/tags/感想/" style="font-size: 15px;">感想</a> <a href="/tags/JavaScript函数/" style="font-size: 15px;">JavaScript函数</a> <a href="/tags/React/" style="font-size: 15px;">React</a> <a href="/tags/React架构/" style="font-size: 15px;">React架构</a> <a href="/tags/dva/" style="font-size: 15px;">dva</a> <a href="/tags/node/" style="font-size: 15px;">node</a> <a href="/tags/node基础/" style="font-size: 15px;">node基础</a> <a href="/tags/React基础/" style="font-size: 15px;">React基础</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/Redux-saga/" style="font-size: 15px;">Redux saga</a> <a href="/tags/JavaScript对象/" style="font-size: 15px;">JavaScript对象</a> <a href="/tags/前端工程师/" style="font-size: 15px;">前端工程师</a> <a href="/tags/职业规划/" style="font-size: 15px;">职业规划</a> <a href="/tags/事件循环机制/" style="font-size: 15px;">事件循环机制</a> <a href="/tags/源码分析/" style="font-size: 15px;">源码分析</a> <a href="/tags/实习/" style="font-size: 15px;">实习</a> <a href="/tags/面试题/" style="font-size: 15px;">面试题</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://mofan_tcg.coding.me/" title="时光笔记" target="_blank">时光笔记</a><ul></ul><a href="http://realtcg.com/Precious-Memories/" title="React小相册" target="_blank">React小相册</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p>你的梦想是这个世界上最伟大的事情</p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">mofan.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/MrStronger/hexo-theme-Mofan"> Mofan.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?3f3a5a8fd2b4cc3b3813fd00426fa25d";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment = new Gitment({
  id: '浏览器中的事件循环机制', // 可选。默认为 location.href
  owner: 'MrStronger',
  repo: 'blogcomment',
  oauth: {
    client_id: '0a99d84bb46f7cda7fce',
    client_secret: 'b3915ea2a1e5364a698ec8335e34092ad6bc42d0',
  },
})
gitment.render('container')
</script></body></html>