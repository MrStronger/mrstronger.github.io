<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="莫凡的个人博客"><title>使用React技术栈的一些收获(二) | 莫凡</title><link rel="stylesheet" type="text/css" href="//fonts.css.network/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><a id="logo" href="/."><img src="http://ot6vbgl2y.bkt.clouddn.com/17-7-18/91792276.jpg" class="logoImg"><span class="hidden">使用React技术栈的一些收获(二)</span></a></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">使用React技术栈的一些收获(二)</h1><div class="post-meta"><a href="/2017/06/25/使用React技术栈的一些收获-二/#comments" class="comment-count"><a id="uyan_count_unit" href="/2017/06/25/使用React技术栈的一些收获-二/"></a>留言</a><p><span class="date">Jun 25, 2017</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p><strong><code>注意</code></strong> 这篇文章并不是教程，只是我对React原理的一些个人理解，欢迎与我一起讨论。文章不对的地方，还请读者费心指出^-^</p>
</blockquote>
<p>随着项目开发的深入，不可避免了遇到了一些问题。刚开始出现问题时很懵，不知道该怎么解决，原因就是对React的原理理解的不够透彻，不知道问题出在哪。在解决问题的过程中，也逐渐深入了解了React的一些原理，这篇文章就来分享一下我对React一些原理的理解。</p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>本文是《使用React技术栈的一些收获》系列文章的第二篇(第一篇在<a href="http://realtcg.com/2017/06/24/%E4%BD%BF%E7%94%A8React%E6%8A%80%E6%9C%AF%E6%A0%88%E7%9A%84%E4%B8%80%E4%BA%9B%E6%94%B6%E8%8E%B7/">这里</a>，介绍如何开始构建React大型项目)，简单介绍了React一些原理，包括React合成事件系统、组件的生命周期以及<code>setState()</code>。</p>
<h3 id="React合成事件系统"><a href="#React合成事件系统" class="headerlink" title="React合成事件系统"></a>React合成事件系统</h3><p>React快速的原因之一就是React很少直接操作DOM，浏览器事件也是一样。原因是太多的浏览器事件会占用很大内存。</p>
<p>React为此自己实现了一套合成系统，在DOM事件体系基础上做了很大改进，减少了内存消耗，简化了事件逻辑，最大化解决浏览器兼容问题。</p>
<p><strong>其基本原理就是，所有在JSX声明的事件都会被委托在顶层document节点上，并根据事件名和组件名存储回调函数(<code>listenerBank</code>)。每次当某个组件触发事件时，在document节点上绑定的监听函数（<code>dispatchEvent</code>）就会找到这个组件和它的所有父组件(<code>ancestors</code>)，对每个组件创建对应React合成事件(<code>SyntheticEvent</code>)并批处理(<code>runEventQueueInBatch(events)</code>)，从而根据事件名和组件名调用(<code>invokeGuardedCallback</code>)回调函数。</strong></p>
<p>因此，如果你采用下面这种写法，并且这样的P标签有很多个：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">listView = list.map(<span class="function">(<span class="params">item,index</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">        &lt;p onClick=&#123;this.handleClick&#125; key=&#123;item.id&#125;&gt;&#123;item.text&#125;&lt;/p&gt;</div><div class="line">    )</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>That’s OK，React帮你实现了<code>事件委托</code>。我之前因为不了解React合成事件系统，还显示的使用了事件委托，现在看来是多此一举的。</p>
<p>由于React合成事件系统模拟事件冒泡的方法是构建一个自己及父组件队列，因此也带来一个问题，合成事件不能阻止原生事件，原生事件可以阻止合成事件。用 <code>event.stopPropagation()</code> 并不能停止事件传播，应该使用  <code>event.preventDefault()</code>。</p>
<p>如果你想详细了解React合成事件系统，移步<a href="http://blog.csdn.net/u013510838/article/details/61224760" target="_blank" rel="external">http://blog.csdn.net/u013510838/article/details/61224760</a></p>
<h3 id="组件的生命周期（以父子组件为例）"><a href="#组件的生命周期（以父子组件为例）" class="headerlink" title="组件的生命周期（以父子组件为例）"></a>组件的生命周期（以父子组件为例）</h3><p>为了搞清楚组件生命周期，构造一个父组件包含子组件并且重写各生命周期函数的场景：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">super</span>()</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Child was created!'</span>)</div><div class="line">  &#125;</div><div class="line">  componentWillMount()&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Child componentWillMount!'</span>)</div><div class="line">  &#125;</div><div class="line">  componentDidMount()&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Child componentDidMount!'</span>)</div><div class="line">  &#125;</div><div class="line">  componentWillReceiveProps(nextProps)&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Child componentWillReceiveProps:'</span>+nextProps.data )</div><div class="line">  &#125;</div><div class="line">  shouldComponentUpdate(nextProps, nextState)&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Child shouldComponentUpdate:'</span>+ nextProps.data)</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">  &#125;</div><div class="line">  componentWillUpdate(nextProps, nextState)&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Child componentWillUpdate:'</span>+ nextProps.data)</div><div class="line">  &#125;</div><div class="line">  componentDidUpdate()&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Child componentDidUpdate'</span>)</div><div class="line">  &#125;</div><div class="line">  render() &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'render Child!'</span>)</div><div class="line">    <span class="keyword">return</span> (      </div><div class="line">      &lt;h1&gt;Child recieve props: &#123;this.props.data&#125;&lt;/h1&gt;      </div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="comment">// ... 前面跟子组件一样</span></div><div class="line">  handleChangeState()&#123;</div><div class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">randomData</span>: <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">50</span>)&#125;)</div><div class="line">  &#125;</div><div class="line">  render() &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'render Father!'</span>)</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div&gt;</div><div class="line">        &lt;Child data=&#123;this.state.randomData&#125; /&gt;</div><div class="line">        &lt;h1&gt;Father State: &#123; this.state.randomData&#125;&lt;/h1&gt;      </div><div class="line">        &lt;button onClick=&#123;this.handleChangeState&#125;&gt;切换状态&lt;/button&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">React.render(</div><div class="line">  &lt;Father /&gt;,</div><div class="line">  document.getElementById('root')</div><div class="line">);</div></pre></td></tr></table></figure>
<p>结果如下：<br>刚开始<br><img src="https://ooo.0o0.ooo/2017/06/28/595398ee54b1a.png" alt="Alt text"><br>调用父组件的setState后：<br><img src="https://ooo.0o0.ooo/2017/06/28/595398ff8a44a.png" alt="Alt text"><br><a href="http://jsbin.com/kihogom/edit?js,console,output" target="_blank" rel="external">在Jsbin上试试看</a><br>有一张图能说明这之间的流程（<a href="http://www.jianshu.com/p/4784216b8194" target="_blank" rel="external">图片来源</a>）：<br><img src="https://ooo.0o0.ooo/2017/06/28/595398b92d076.png" alt="Alt text"></p>
<h3 id="setState并不奇怪"><a href="#setState并不奇怪" class="headerlink" title="setState并不奇怪"></a>setState并不奇怪</h3><p>有一个能反映问题的场景：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">state = &#123;</div><div class="line">	<span class="attr">count</span>: <span class="number">0</span></div><div class="line">&#125;</div><div class="line">componentDidMount() &#123;</div><div class="line">  <span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span>&#125;)</div><div class="line">  <span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span>&#125;)</div><div class="line">  <span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span>&#125;)</div><div class="line">&#125;</div><div class="line">...</div></pre></td></tr></table></figure>
<p>看起来state.count被增加了三次，但结果是增加了一次。这并不奇怪：</p>
<p>React快的原因之一就是，在执行<code>this.setState()</code>时，React没有忙着立即更新<code>state</code>，只是把新的<code>state</code>存到一个队列（<code>batchUpdate</code>）中。上面三次执行<code>setState</code>只是对传进去的对象进行了合并,然后再统一处理（批处理），触发重新渲染过程，因此只重新渲染一次，结果只增加了一次。这样做是非常明智的，因为在一个函数里调用多个setState是常见的，如果每一次调用setState都要引发重新渲染，显然不是最佳实践。React官方文档里也说了：</p>
<blockquote>
<p>Think of <code>setState()</code> as a <strong>request</strong> rather than an immediate command to update the component.</p>
<p>把<code>setState()</code> 看作是重新render的一次请求而不是立刻更新组件的指令。</p>
</blockquote>
<p><strong>那么调用<code>this.setState()</code>后什么时候this.state才会更新？</strong><br>答案是即将要执行下一次的<code>render</code>函数时。</p>
<p><strong>这之间发生了什么？</strong><br><code>setState</code>调用后，React会执行一个事务（Transaction），在这个事务中，React将新state放进一个队列中，当事务完成后，React就会刷新队列，然后启动另一个事务，这个事务包括执行 <code>shouldComponentUpdate</code> 方法来判断是否重新渲染，如果是，React就会进行state合并（<code>state merge</code>）,生成新的state和props；如果不是，React仍然会更新<code>this.state</code>，只不过不会再<code>render</code>了。</p>
<p>开发人员对<code>setState</code>感到奇怪的原因可能就是按照上述写法并不能产生预期效果，但幸运的是我们改动一下就可以实现上述累加效果：<br>这归功于<code>setState</code>可以接受函数作为参数：</p>
<blockquote>
<p><code>setState(updater, [callback])</code></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">state = &#123;</div><div class="line">	<span class="attr">score</span>: <span class="number">0</span></div><div class="line">&#125;</div><div class="line">componentDidMount() &#123;</div><div class="line">    <span class="keyword">this</span>.setState( <span class="function">(<span class="params">prevState</span>) =&gt;</span> (&#123;<span class="attr">score</span> : prevState.score + <span class="number">1</span>&#125;) )</div><div class="line">    <span class="keyword">this</span>.setState( <span class="function">(<span class="params">prevState</span>) =&gt;</span> (&#123;<span class="attr">score</span> : prevState.score + <span class="number">1</span>&#125;) )</div><div class="line">    <span class="keyword">this</span>.setState( <span class="function">(<span class="params">prevState</span>) =&gt;</span> (&#123;<span class="attr">score</span> : prevState.score + <span class="number">1</span>&#125;) )</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个<code>updater</code>可以为函数，该函数接受该组件<strong>前一刻</strong>的 state 以及<strong>当前</strong>的 props 作为参数，计算和返回下一刻的 state。</p>
<p>你会发现达到增加三次的目的了: <a href="http://jsbin.com/nazazo/edit?html,js,console,output" target="_blank" rel="external">在Jsbin上试试看</a></p>
<p>这是因为React会把<code>setState</code>里传进去的函数放在一个任务队列里，React 会依次调用队列中的函数，传递给它们<strong>前一刻</strong>的 state。</p>
<p><strong>另外</strong>，不知道你在<a href="http://jsbin.com/nazazo/edit?html,js,console,output" target="_blank" rel="external">jsbin</a>上的代码上注意到没有，调用<code>setState</code>后<code>console.log(this.state.score)</code>输出仍然为0，也就是<code>this.state</code>并未改变，并且只<code>render</code>了一次。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>学习一个框架或者工具，我觉得应该了解以下几点：</p>
<ol>
<li>它是什么？能做什么？</li>
<li>它存在的理由是什么？解决了什么样的问题、满足了什么样的需求？</li>
<li>它的适用场景是什么？优缺点是什么？</li>
<li>它怎么用？最佳实践是什么？</li>
<li>它的原理是什么？ </li>
<li>…</li>
</ol>
<p>通过对React一些原理的简单了解，就懂得了React为什么这么快速的原因之一，也会在问题出现时知道错在什么地方，知道合理的解决方案。</p>
</div><div class="tags"><a href="/tags/React/">React</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div><div class="jiathis_style"><span class="jiathis_txt">分享到：</span><a class="jiathis_button_tsina"></a><a class="jiathis_button_qzone"></a><a class="jiathis_button_weixin"></a><a class="jiathis_button_fb"></a><a class="jiathis_button_linkedin"></a><a class="jiathis_button_twitter"></a><a class="jiathis_button_ydnote"></a><a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis"></a><a class="jiathis_counter_style"></a></div></div><div class="post-nav"><a href="/2017/06/24/使用React技术栈的一些收获/" class="next">使用React技术栈的一些收获</a></div><div id="comments"><div id="uyan_frame"></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#前言"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#概述"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React合成事件系统"><span class="toc-text">React合成事件系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#组件的生命周期（以父子组件为例）"><span class="toc-text">组件的生命周期（以父子组件为例）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setState并不奇怪"><span class="toc-text">setState并不奇怪</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/06/25/使用React技术栈的一些收获-二/">使用React技术栈的一些收获(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/24/使用React技术栈的一些收获/">使用React技术栈的一些收获</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/13/JavaScript常用函数总结-一/">JavaScript常用函数总结(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/16/我对JavaScript对象的理解/">我对JavaScript对象的理解</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/08/20/">今天我20岁</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/JavaScript-JavaScript函数/" style="font-size: 15px;">JavaScript,JavaScript函数</a> <a href="/tags/感想/" style="font-size: 15px;">感想</a> <a href="/tags/JavaScript对象/" style="font-size: 15px;">JavaScript对象</a> <a href="/tags/React/" style="font-size: 15px;">React</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://mofan_tcg.coding.me/" title="时光笔记" target="_blank">时光笔记</a><ul></ul><a href="http://realtcg.com/Precious-Memories/" title="React小相册" target="_blank">React小相册</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">mofan.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?3f3a5a8fd2b4cc3b3813fd00426fa25d";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script><script>var jiathis_config={
    data_track_clickback:true,
    summary:"",
    shortUrl:true,
    hideMore:false
}</script><script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script><script src="http://v2.uyan.cc/code/uyan.js?uid=2131218"></script></body></html>