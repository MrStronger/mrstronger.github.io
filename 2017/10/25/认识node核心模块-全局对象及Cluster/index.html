<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="莫凡的个人博客"><title>认识node核心模块--全局对象及Cluster | 莫凡</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"></head><body><div class="body_container"><div id="header"><div class="site-name"><a id="logo" href="/."><img src="http://ot6vbgl2y.bkt.clouddn.com/17-7-18/91792276.jpg" class="logoImg"><span id="hidden">认识node核心模块--全局对象及Cluster</span></a></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">认识node核心模块--全局对象及Cluster</h1><div class="post-meta"><a href="/2017/10/25/认识node核心模块-全局对象及Cluster/#comments" class="comment-count"></a><p><span class="date">Oct 25, 2017</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>node 模块是node 完成强大功能的实现者。node 的核心模块包括events、fs、buffer、stream、cluster、http、net、一些操作OS和工具模块、全局对象等。本文将在<a href="http://realtcg.com/2017/10/14/node%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E7%90%86%E8%A7%A3/">node核心特性理解</a>的基础上进一步深入探讨node核心模块的具体细节。本文主要探讨的模块有：全局对象global及其重要属性、多进程cluster、events重要类EventEmitter、流Stream、文件系统fs、网络http，还会介绍node框架express相关。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文先来介绍全局对象global及其重要属性、多进程cluster模块。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="node全局对象global"><a href="#node全局对象global" class="headerlink" title="node全局对象global"></a>node全局对象global</h3><p>与浏览器对应的window一样，在node中global是全局对象，在全局作用域定义的任何变量都会保存为global的属性，称为全局变量。下面是global一些重要的属性：</p>
<ul>
<li><p><strong>模块：<code>module</code>、<code>require</code>、<code>exports</code></strong></p>
<p>这三个全局变量组成了node 的模块定义和引入，是 commonJS 的实现。node将每个文件视为一个模块，在执行到每个模块之前都会定义好上述三个变量，因此可以直接使用。来看它们之间的协作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// module1.js</span></div><div class="line">exports.fun = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> a + b;</div><div class="line">&#125; <span class="comment">//绑定在exports的属性可以被其他模块引入使用</span></div><div class="line"></div><div class="line"><span class="comment">//module2.js</span></div><div class="line"><span class="keyword">var</span> module1 = <span class="built_in">require</span>(<span class="string">'./module1'</span>)</div><div class="line">module1.fun(<span class="number">3</span>,<span class="number">2</span>) 	<span class="comment">//5</span></div></pre></td></tr></table></figure>
<p>相关机制：</p>
<ul>
<li>module 表示对这个模块的引用，因此<code>module</code> 实际上不是全局的，而是每个模块本地的。module除了exports 还有其他关于模块的属性，例如<code>module.children</code></li>
<li>exports 其实是<code>module.exports</code>的简写，表示这个模块的输出。有一点需要注意，对exports直接赋值<code>exports = {...}</code>并不会被输出，因为exports事先已经被定义了，再次这样赋值会被覆盖，需要带上module：<code>module.exports = {...}</code></li>
<li>require 表示引入某个模块，填写模块路径即可，在node_modules里面的模块填写名字即可，js文件可以不用写扩展名。</li>
</ul>
<p>另外，由于V8引擎对ES6的不断支持，node 中也可以直接使用ES6的一些特性、例如promise、class等，ES6的模块也被node 实验性的引入并且是稳定的。详情见<a href="http://nodejs.cn/api/esm.html#esm_ecmascript_modules" target="_blank" rel="external">nodejs中文网</a>。可以在<a href="http://node.green/" target="_blank" rel="external">node.green</a>查看支持的特性</p>
</li>
<li><p><strong>异步操作 setTimeout、setInterval、setImmediate、process.nextTick</strong></p>
<ul>
<li><p>setTimeout和setInterval跟浏览器端一样，不同的是，node实现了setImmediate（目前浏览器端只有 IE实现了该方法）。它表示在 Node.js 事件循环的当前回合结束时要调用的函数，用来把一些需要长时间运行的操作放在一个回调函数里,在node主线程完成后面的其他语句后,就立刻执行这个回调函数，参数是一个函数和用作这个函数的参数，作用跟<code>setTimeout(fn,0)</code>差不多，都是相当于立即在事件队列末尾插入一个事件，但也有差别。</p>
</li>
<li><p><code>process.nextTick(fn,...args)</code>表示在当前调用栈结束后，在下一个事件执行前调用回调函数。node 提供这个API是为了把复杂耗时的任务放到最后去处理，以便优先执行简单的任务。来看它们之间的比较：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"setTimeout0"</span>),<span class="number">0</span>)</div><div class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"setImmediate"</span>))</div><div class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"nextTick"</span>))</div><div class="line"><span class="comment">//输出nextTick setTimeout0 setImmediate 或者 nextTick setImmediate setTimeout0</span></div></pre></td></tr></table></figure>
<p>无论<code>process.nextTick</code>写在什么地方，它总是第一个输出。无论setTimeout和setImmediate谁先谁后，都可能出现两种结果，其中setTimeout(fn,0)先于setImmediate多一点。这是因为它们三个产生的事件推入到了不同的<code>watcher</code>（观察者）中—— setTimeout推入到了定时器观察者，setImmediate是check观察者，而process.nextTick()是idle观察者 ，而node主线程在事件循环时调用watcher 的顺序一般是 <strong>idle观察者 &gt; check观察者，idle观察者 &gt; 定时器观察者</strong>，check 和定时器不分先后，但定时器先于check的概率大一点。</p>
<p><img src="http://ot6vbgl2y.bkt.clouddn.com/17-10-20/28824432.jpg" alt=""></p>
</li>
</ul>
</li>
<li><p><strong>node进程： process</strong></p>
<p>process 是node对进程的表示，提供了操作进程的接口，可以用process来提供进程有关信息，控制进程 。</p>
<p>process提供的接口包括</p>
<p>描述进程的一些状态（事件）：exit、beforeExit、uncaughtException、Signal</p>
<p>进程退出返回的状态码：Uncaught Fatal Exception、Signal Exits、Unused等</p>
<p>进程的相关信息：stdout、stderr、config、stdin、exitCode、pid(进程编号)等</p>
<p>操作进程的方法：abort、chdir、cwd、kill(发送信号给进程)、exit、nextTick、getgid、setgid、uptime等</p>
</li>
<li><p><strong>其他： console、<code>__filename</code>、  <code>__dirname</code></strong></p>
<p>这些都是全局变量，可以在任何地方引用</p>
</li>
</ul>
<h3 id="node-子进程：child-process模块"><a href="#node-子进程：child-process模块" class="headerlink" title="node 子进程：child_process模块"></a>node 子进程：child_process模块</h3><p>一个进程只能利用一个CPU时间分片，为了高效利用多核CPU，node 提供了可以创建子<strong>进程(注意不是子线程)</strong>的<code>child_process</code>模块，来帮助主进程高效利用多核CPU完成其他复杂的任务。之所以提供创建子进程而不是子线程的接口，是因为这让我们的程序状态单一，不用在意状态同步、死锁、上下文切换开销等等多线程编程中的头疼问题。这样以来一个进程只有一个线程。虽然单线程也会带来一些问题，如错误会引起整个应用退出等，但这都有了很好的解决方案。</p>
<p><strong>创建子进程</strong></p>
<p>node有三种创建子进程的接口：</p>
<ul>
<li><strong>exec / execFile</strong>: 这两者都会创建子进程来执行，执行的结果会存储在Buffer中。不同的是前者创建一个shell进程来执行命令，后者直接创建一个进程用来执行可执行文件，因此前者适合用来执行shell命令然后获取输出，后者效率较高。这两者因为输出的结果存储在Buffer中，因此只适合输出轻量的数据。</li>
<li><strong>spawn</strong>：适合用于进程输入、输出数据量比较大的情况，因为它支持以 stream 的形式输入输出，可以用于任何命令。spawn的参数option有一个stdio配置项，用来配置子进程与父进程之间的IO通道，还有一个detached来配置子进程是否独立运行，可以创建常驻后台进程。总之，给予了子进程更多的灵活性。</li>
<li><strong>fork</strong>：fork 其实是spawn的特例，它会创建一个V8实例，只能用来运行node.js程序，并且与上面两种方法不同的是，fork会在父子进程间建立 IPC 通道，父子进程之间可以互相收发消息——通过监听 <code>message</code> 事件和调用 <code>send</code> 方法，就可以在父子进程间进行通信了。</li>
</ul>
<p><strong>父子进程通信</strong></p>
<p>首先，这三种API都返回<code>ChildProcess</code>实例，因此都可以通过访问<code>stdout</code>属性来得到输出，exec/execFile 接口还可以在参数里绑定回调函数拿到子进程的stdout 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> &#123; exec, execFile, spawn, fork &#125; = <span class="built_in">require</span>(<span class="string">"child_process"</span>)</div><div class="line"></div><div class="line"><span class="comment">// exec/execFile 接口既可以在参数里绑定回调函数拿到输出流，也可以利用返回的ChildProcess实例</span></div><div class="line"><span class="keyword">const</span> exec_process = exec(<span class="string">"node child_process.js"</span>, &#123;&#125;, (err, stdout, stderr) =&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (err) &#123;</div><div class="line">        <span class="built_in">console</span>.log(err)</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(stdout) &#123;</div><div class="line">        <span class="built_in">console</span>.log(stdout)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(stderr)</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line">exec_process.stdout.on(<span class="string">'data'</span>,(data) =&gt; <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;data&#125;</span>`</span>))</div><div class="line"></div><div class="line"><span class="comment">// spawn 接口没有回调函数，只能利用返回的ChildProcess实例绑定监听数据函数拿到子进程的输出</span></div><div class="line"><span class="keyword">const</span> spawn_process = spawn(<span class="string">'node'</span>,[<span class="string">'child_process'</span>], &#123;&#125;)</div><div class="line">spawn_process.stdout.on(<span class="string">'data'</span>, (data) =&gt; <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;data&#125;</span>`</span>))</div><div class="line"></div><div class="line"><span class="comment">//fork 也可以利用返回的ChildProcess实例，注意配置项silent要设为true</span></div><div class="line"><span class="keyword">const</span> fork_process = fork(<span class="string">'child_process.js'</span>, [], &#123;<span class="string">'silent'</span>: <span class="literal">true</span>&#125;)</div><div class="line">fork_process.stdout.on(<span class="string">'data'</span> ,(data) =&gt; <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;data&#125;</span>`</span>))</div></pre></td></tr></table></figure>
<p>其次， fork返回的<code>ChildProcess</code>实例有一个额外的内置的通信通道IPC，它允许消息在父进程和子进程之间来回传递。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// child_process.js</span></div><div class="line">process.on(<span class="string">'message'</span>, (data) =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`message from Parent: <span class="subst">$&#123;data&#125;</span>`</span>);</div><div class="line">&#125;)</div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  process.send(<span class="string">'send from child'</span>);</div><div class="line">&#125;, <span class="number">2000</span>)</div><div class="line"></div><div class="line"><span class="comment">// parent.js</span></div><div class="line"><span class="keyword">const</span> &#123; fork &#125; = <span class="built_in">require</span>(<span class="string">"child_process"</span>)</div><div class="line"><span class="keyword">const</span> p = fork(</div><div class="line">  <span class="string">'child_process.js'</span>, <span class="comment">// 需要执行的脚本路径</span></div><div class="line">  [], <span class="comment">// 传递的参数</span></div><div class="line">  &#123;&#125;</div><div class="line">)</div><div class="line">p.on(<span class="string">'message'</span>, data =&gt; &#123;                      <span class="comment">//监听子进程消息</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`message from child: <span class="subst">$&#123;data&#125;</span>`</span>)</div><div class="line">&#125;)</div><div class="line">p.send(<span class="string">'send from parent'</span>)                     <span class="comment">//发送消息给子进程</span></div></pre></td></tr></table></figure>
<h3 id="集群：Cluster-模块"><a href="#集群：Cluster-模块" class="headerlink" title="集群：Cluster 模块"></a>集群：Cluster 模块</h3><blockquote>
<p><code>cluster</code>模块是对<code>child_process</code>模块的进一步封装，专用于解决单进程NodeJS Web服务器无法充分利用多核CPU的问题。使用该模块可以简化多进程服务器程序的开发，让每个核上运行一个工作进程，并<strong>统一通过主进程监听端口和分发请求</strong>。                                            ——<a href="http://nqdeng.github.io/7-days-nodejs/#5.2.3" target="_blank" rel="external">七天学会node.js</a></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> cluster = <span class="built_in">require</span>(<span class="string">'cluster'</span>);</div><div class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">const</span> numCPUs = <span class="built_in">require</span>(<span class="string">'os'</span>).cpus().length;</div><div class="line"><span class="built_in">console</span>.log(numCPUs)</div><div class="line"></div><div class="line"><span class="keyword">if</span> (cluster.isMaster) &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`主进程 <span class="subst">$&#123;process.pid&#125;</span> 正在运行`</span>);</div><div class="line"></div><div class="line">  <span class="comment">// 衍生工作进程。</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numCPUs; i++) &#123;</div><div class="line">    cluster.fork();      <span class="comment">// 调用了 child_process.fork()方法创建工作进程</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  cluster.on(<span class="string">'exit'</span>, (worker, code, signal) =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`工作进程 <span class="subst">$&#123;worker.process.pid&#125;</span> 已退出`</span>);</div><div class="line">  &#125;);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="comment">// 工作进程可以共享任何 TCP 连接。</span></div><div class="line">  <span class="comment">// 在本例子中，共享的是一个 HTTP 服务器。</span></div><div class="line">  http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</div><div class="line">    res.writeHead(<span class="number">200</span>);</div><div class="line">    res.end(<span class="string">'你好世界\n'</span>);</div><div class="line">  &#125;).listen(<span class="number">8000</span>);</div><div class="line"></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`工作进程 <span class="subst">$&#123;process.pid&#125;</span> 已启动`</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"WOW"</span>)</div><div class="line"></div><div class="line"><span class="comment">// 输出（Mac OS）</span></div><div class="line"><span class="number">4</span></div><div class="line">主进程 <span class="number">55570</span> 正在运行</div><div class="line">WOW</div><div class="line"><span class="number">4</span></div><div class="line">工作进程 <span class="number">55571</span> 已启动</div><div class="line">WOW</div><div class="line"><span class="number">4</span></div><div class="line">工作进程 <span class="number">55572</span> 已启动</div><div class="line">WOW</div><div class="line"><span class="number">4</span></div><div class="line">工作进程 <span class="number">55573</span> 已启动</div><div class="line">WOW</div><div class="line"><span class="number">4</span></div><div class="line">工作进程 <span class="number">55574</span> 已启动</div><div class="line">WOW</div><div class="line"></div><div class="line"><span class="comment">//可以看到 fork 是异步创建的，调用时请求创建进程并立即返回，系统创建好进程后会加入到事件队列，执行到事件就调用回调函数，这个回调函数包括执行一遍这个文件</span></div></pre></td></tr></table></figure>
<p><code>cluster.fork()</code>实际调用了<code>child_process.fork()</code>，因此建立了IPC通道与父进程通信。它会创建一个进程并返回<code>cluster.worker</code>实例。创建的每个进程之间都是独立的，一个进程的开启和关闭不影响其他进程。只要有存活的进程，服务器就可以继续处理连接。</p>
<p>主进程负责监听端口，接收新连接后会自动将连接循环（默认）分发给<code>cluster.fork()</code>创建的工作进程来帮忙处理，因此可以使用cluster模块来实现简单的负载均衡。</p>
<p><strong>注意</strong>：</p>
<ul>
<li><code>cluster.fork()</code>返回<code>cluster.worker</code>实例可能会引起困惑，困惑的原因把主进程和工作进程做了master和worker的区分，这里不用这么区分，既然主进程也是进程，那么也可以看作worker，调用<code>cluster.fork().send(message)</code>就可以向子进程发送信息，同样监听信息也是<code>cluster.fork().on(&#39;message&#39;, (data) =&gt; {...})</code>。</li>
<li>worker 和 process 都是相对的，如果当前执行进程是主进程就代表主进程，是工作进程就代表工作进程。</li>
<li>cluster代表整个集群，也就是主进程和工作进程，随着当前执行进程的变化，cluster的属性也在变化。在cluster上面绑定的事件对每个进程都起作用。cluster有一些API 是只对于主进程或只对于工作进程的，例如只能在主进程而不能在工作进程中调用的：fork、cluster.workers等，只能在工作进程不能在主进程调用的：cluster.worker等。</li>
<li>跟上面child_process模块不一样的是，<code>cluster.fork()</code>只有增加进程环境变量的参数(一般是不带的)，没有要执行文件路径的参数，因此像上面代码那样主进程做的事和工作进程做的事写在同一文件(if-else语句里)是合理的。</li>
</ul>
</div><div class="tags"><a href="/tags/node/">node</a><a href="/tags/node基础/">node基础</a></div><div class="post-share"></div><div class="post-nav"><a href="/2017/11/03/认识node核心模块-深入EventEmitter/" class="pre">认识node核心模块--深入EventEmitter</a><a href="/2017/10/14/node核心特性理解/" class="next">node核心特性理解</a></div><div id="comments"><div id="container"></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="React"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#概述"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#正文"><span class="toc-text">正文</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#node全局对象global"><span class="toc-text">node全局对象global</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#node-子进程：child-process模块"><span class="toc-text">node 子进程：child_process模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#集群：Cluster-模块"><span class="toc-text">集群：Cluster 模块</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/11/21/认识node核心模块-网络编程/">认识node核心模块--网络编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/10/认识node核心模块-从Buffer、Stream到fs/">认识node核心模块--从Buffer、Stream到fs</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/03/认识node核心模块-深入EventEmitter/">认识node核心模块--深入EventEmitter</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/25/认识node核心模块-全局对象及Cluster/">认识node核心模块--全局对象及Cluster</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/14/node核心特性理解/">node核心特性理解</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/27/我对前端工程师这个职业的看法/">我对前端工程师这个职业的看法</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/21/我对javascript事件循环机制的理解/">我对javascript事件循环机制的理解</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/19/面试-实习心得/">面试&实习心得</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/25/dva值得一试/">dva值得一试</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/12/对使用Redux和Redux-saga管理状态的思考/">对使用Redux和Redux-saga管理状态的思考</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/前端工程师/" style="font-size: 15px;">前端工程师</a> <a href="/tags/感想/" style="font-size: 15px;">感想</a> <a href="/tags/dva/" style="font-size: 15px;">dva</a> <a href="/tags/React架构/" style="font-size: 15px;">React架构</a> <a href="/tags/React基础/" style="font-size: 15px;">React基础</a> <a href="/tags/JavaScript对象/" style="font-size: 15px;">JavaScript对象</a> <a href="/tags/Redux/" style="font-size: 15px;">Redux</a> <a href="/tags/Redux-saga/" style="font-size: 15px;">Redux saga</a> <a href="/tags/React/" style="font-size: 15px;">React</a> <a href="/tags/职业规划/" style="font-size: 15px;">职业规划</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/Javascript事件循环机制/" style="font-size: 15px;">Javascript事件循环机制</a> <a href="/tags/node/" style="font-size: 15px;">node</a> <a href="/tags/node基础/" style="font-size: 15px;">node基础</a> <a href="/tags/实习/" style="font-size: 15px;">实习</a> <a href="/tags/面试题/" style="font-size: 15px;">面试题</a> <a href="/tags/JavaScript函数/" style="font-size: 15px;">JavaScript函数</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://mofan_tcg.coding.me/" title="时光笔记" target="_blank">时光笔记</a><ul></ul><a href="http://realtcg.com/Precious-Memories/" title="React小相册" target="_blank">React小相册</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p>你的梦想是这个世界上最伟大的事情</p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">mofan.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/MrStronger/hexo-theme-Mofan"> Mofan.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?3f3a5a8fd2b4cc3b3813fd00426fa25d";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment = new Gitment({
  id: '认识node核心模块--全局对象及Cluster', // 可选。默认为 location.href
  owner: 'MrStronger',
  repo: 'blogcomment',
  oauth: {
    client_id: '0a99d84bb46f7cda7fce',
    client_secret: 'b3915ea2a1e5364a698ec8335e34092ad6bc42d0',
  },
})
gitment.render('container')
</script></body></html>