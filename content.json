[{"title":"对使用Redux和Redux-saga管理状态的思考","date":"2017-08-12T10:32:45.000Z","path":"2017/08/12/对使用Redux和Redux-saga管理状态的思考/","text":"概述本文介绍了我对 Redux 状态管理的思想、原理、架构方法的认识和思考以及配合redux-saga处理异步操作的实践 前言You know, React 只是属于MV*架构模式的 view 层，是一种状态机，只使用 React 难以控制大型、复杂的应用，它需要一些框架来帮助管理状态，因此如何有效、简单、易于测试地管理这个状态机是各种架构框架感兴趣的。Facebook 早就意识到这个问题并提出了 Flux 架构，比较复杂; 后来出现了 Redux、Mobx 等。MobX 可以处理简单数据流的场景，可以实现精确更新; Redux 是从 Flux 和其他框架借鉴了一些思想， 它比 Flux 简单、易于理解、用于处理复杂数据流，并具有很强的扩展性，社区诞生了像redux-thunk、redux-promise、redux-saga等中间件用于方便地处理异步操作。最近也在项目中使用了 Redux 及其中间件 redux-saga 来管理状态和处理异步操作，这篇文章就来谈谈我对它们的思考和实践。 正文Redux 思想先来谈谈背景（需求） 我觉得理解Redux的思想，谈谈MV*架构模式的思路也许会有帮助。 MV*架构模式，它们的核心都是职责分离、解耦，不同的层次做不同的事，能让一个复杂、混乱的应用变得思路清晰，代码可以复用，并且易于测试，有利于分工合作，构建更大、更复杂的应用。 一个应用要包括哪些功能？表现（view）、处理数据的逻辑（model）以及数据映射到表现层的逻辑（presenter or controller），数据在这三层之间流通（MVVM模式通过数据双向绑定实现view和model同步）。 React 根据state来render，它只是个状态机，并没有解决管理状态的问题。我们在单纯的使用React来写组件的时候，经常会遇到组件间通信和管理组件state的问题，前者常用的解决办法就是把数据提到父组件共享；后者管理state简单的情况还行，一复杂就很麻烦且容易出错，再遇到一些需要异步处理的操作，想想就头皮发麻。 当你开发中遇到一些反人类的操作时，试着去想如何改变一下思路让它变得更简单，别耐着性子安慰自己开发就是这样 :) 解决方案 Redux 正是用来解决大型React应用所面临的状态管理、数据流通、异步处理、测试、团队合作等问题： Redux 用单一的object tree来表示整个应用的state，这个表示state的对象树被放在唯一的store 中，state相当于store的快照；所有组件都会通过API拿到这个state，各取所需； Redux 把页面上用户的操作或者浏览器的行为（如路由的变化）定义为一个要更新state的action，这个action是一个普通对象，它包含了要执行动作的类别和传递到state的数据（如果有的话），它只表明要更改state的意图，相当于一个信号，并不能直接修改state，Redux会集中处理这些信号，这个action由你来决定何时发起； 定义好信号，你还需要根据不同的信号定义不同的逻辑函数（reducers）来更新state。 通过这张图来整理一下： 咳咳…比如用户点击的一个按钮，你在按钮上绑定的回调函数调用了一个（多个）action creator，action creator就返回了一个更新state局部数据的action，store会根据这个（多个）action找到对应的reducers（reducer需要做拆分），按照action发起的顺序依次执行来更新state，每个reducer只负责更新自己关心那部分，根 reducer 把多个子 reducer 输出合并成一个单一的 state 树，生成一个新的state保存在store中，store中的state可以通过相应API传递到子组件。 这就是整个数据流。 那Redux如何处理异步操作？ Redux借鉴了中间件思想，利用可扩展的中间件来改造dispatch函数。比如redux-thunk让dispatch不仅仅可以接收action，还可以接受函数作为参数，你可以在这个函数里完成异步操作。再如redux-saga更强大、也更复杂，在后面会讲到。 Redux 架构方法对于React技术栈，Redux实现了react-redux库来让Redux管理React应用（其他框架也有相应的库），里面集成了一些有用的函数来把一些明确的流程自动化，如createStore用于创建唯一store，可以把根reducer传进createStore使store自动调用对应reducer，可以扩展中间件；提供&lt;Provider store&gt;组件和connect高阶组件用来包裹render component并传递state，connect还能自动dispatch，让你只要调用action creator就能dispatch；提供combineReducers来组合分割的reducers等。 知道这些特性，就可以配合react-router构建大型应用了： 总的思路就是：利用react-router 把应用分割为各个页面，reducer、action creator也跟随页面分割而分割。每个路由对应的页面下都有components和containers，分别存放functional components 和class components，前者用来渲染，后者当做containers被connect包裹，containers包裹components；containers从connect得到state并映射需要的数据到子组件的props，子组件再向下传递。 具体如何构建React + Redux + react-router，我在另一篇博客里讲了。 使用这种架构，开发大型应用变得得心应手。 Redux 存在的问题但是当我深入项目开发的时候，也逐渐发现了一些问题： 这种架构项目结构不够扁平化，文件嵌套比较深，思路比较复杂，搭建、写起来比较麻烦，上手有难度； 由于所有action creator都定义在页面层次上，让子组件调用必须一层一层的传递，很麻烦且非常容易出错，也很难调试； state难以做到局部更新（这个可以用reselect） Redux只是传递了一种思路，定义了几个简单的API，很灵活，架构方式不固定，设计方式不固定（如：如何设计state树）但这也是它的缺点，新人往往看完一遍还是不知道怎么做，对新人不友好 总之，redux可以胜任复杂数据流的应用，但是也比较难，前期架构比较麻烦，适合有经验的人。 使用redux-saga处理异步操作Redux 倡导action 和reducer尽可能”纯净”，没有什么“副作用”。可是像一些异步操作比如获取数据是必须的，在哪处理这些副作用呢？redux 把这些”不纯净的”任务交给了中间件，通过 向createStore里应用中间件，在交由store处理action之前就可以对其完成一些其他的操作： 而redux-saga 是Redux一个强大但并不复杂的用于异步处理的中间件。 它的思路是什么？相比其他redux异步中间件如redux-thunk、redux-promise有什么不同？ 先看名字来理解：saga，这个术语常用于CQRS架构，代表查询与责任分离。 没错，就是查询（dispatch）与责任（sagas）分离。saga提供了action监听函数，只需在组件里dispatch 相应type的action，就可以自动调用你定义好的对应这个action的异步处理函数（sagas）来完成任务，保证了只在组件里dispatch action来发起异步操作而不是redux-thunk、redux-promise的调用action creators。 另外一大特色就是redux-saga做到了异步代码以同步方式写，非常直观方便，怎么做到的呢？它是利用了ES6新魔法Generator迭代器，可以完美解决异步回调地狱，让你以同步方式写异步。saga正是利用Generator特性让其处理异步变得非常方便又容易理解。这是一个常见的请求后台数据的异步操作，感受一下： 1234567891011121314151617function *fetchNodeDetailByNodeId(&#123; payload: &#123; nodeId &#125; &#125;, &#123; call, put &#125;) &#123; try &#123; const &#123; data, status &#125;= yield call(fetchNodeDetailByNodeId, nodeId) if (data &amp;&amp; status.errmsg === 'success') &#123; yield put(&#123; type: 'setStates', payload: &#123; nodeDetailData: data, &#125;, &#125;); &#125; else &#123; message.info('开了个小差,再试一次吧..'); &#125; &#125; catch (error) &#123; console.log(error); &#125; &#125;, call 和 put 是saga的API，相当于dispatch，但是并不是真正执行dispatch，只是发送你指定的指令，交由saga中间件来执行这个指令。这样看来，这个saga函数就是一些指令的集合，称为effects，副作用，用来描述任务 为啥要描述指令而不直接调用呢？这样是因为易于测试，如果直接调用，你还得模拟调用的函数，详见redux-saga文档。 我觉得redux-saga相比于其他中间件的优点： 查询与责任分离，保证了action的纯洁性，符合redux设计思想 实现以同步方式写异步操作，容易理解，逻辑清晰 通过发送指令而不是直接调用让异步操作变得容易测试 监听、执行自动化 提供了丰富强大的指令来完成复杂的操作，比如无阻塞调用，同时执行多个任务等 讲道理，任何redux异步操作都可以让saga这个中间件来完成，非常复杂的同样可以胜任，并且很容易理解（异步操作以同步方式写）和测试。再配合dva，可以减轻redux的复杂度同时完成更强大的功能。 这样以来，redux配合saga，就可以让它们各司其职，整个思路也变得清晰起来： redux 倡导action和reducer要纯洁，那就让所有异步操作这些不纯洁的任务交给saga，reducer不用变，还是纯函数；定义好对应action的sagas专门用来处理异步操作，我只要在组件需要的地方里dispatch 纯action就行了，符合redux设计思想。 总结使用redux来管理应用状态适用于复杂的应用，而复杂的应用会有复杂的异步处理，异步处理不要用redux的action creator，它不是用来做这个的，也违背了redux设计思想，redux把这些任务交给了异步中间件，应该由它们来完成。使用redux saga是一个推荐的选择，它懂redux，也懂你需要什么。另外，既然你用到了saga，不妨试试dva架构，5分钟上手，值得一试。","tags":[{"name":"Redux,redux saga","slug":"Redux-redux-saga","permalink":"http://realtcg.com/tags/Redux-redux-saga/"}]},{"title":"对React一些原理的理解","date":"2017-06-25T09:12:58.000Z","path":"2017/06/25/对React一些原理的理解/","text":"前言随着项目开发的深入，不可避免了遇到了一些问题。刚开始出现问题时很懵，不知道该怎么解决，原因就是对React的原理理解的不够透彻，不知道问题出在哪。在解决问题的过程中，也逐渐深入了解了React的一些原理，这篇文章就来分享一下我对React一些原理的理解。 注意 这篇文章并不是教程，只是我对React原理的一些个人理解，欢迎与我一起讨论。文章不对的地方，还请读者费心指出^-^ 概述本文是《使用React技术栈的一些收获》系列文章的第二篇(第一篇在这里，介绍如何开始构建React大型项目)，简单介绍了React一些原理，包括React合成事件系统、组件的生命周期以及setState()。 React合成事件系统React快速的原因之一就是React很少直接操作DOM，浏览器事件也是一样。原因是太多的浏览器事件会占用很大内存。 React为此自己实现了一套合成系统，在DOM事件体系基础上做了很大改进，减少了内存消耗，简化了事件逻辑，最大化解决浏览器兼容问题。 其基本原理就是，所有在JSX声明的事件都会被委托在顶层document节点上，并根据事件名和组件名存储回调函数(listenerBank)。每次当某个组件触发事件时，在document节点上绑定的监听函数（dispatchEvent）就会找到这个组件和它的所有父组件(ancestors)，对每个组件创建对应React合成事件(SyntheticEvent)并批处理(runEventQueueInBatch(events))，从而根据事件名和组件名调用(invokeGuardedCallback)回调函数。 因此，如果你采用下面这种写法，并且这样的P标签有很多个： 12345listView = list.map((item,index) =&gt; &#123; return ( &lt;p onClick=&#123;this.handleClick&#125; key=&#123;item.id&#125;&gt;&#123;item.text&#125;&lt;/p&gt; )&#125;) That’s OK，React帮你实现了事件委托。我之前因为不了解React合成事件系统，还显示的使用了事件委托，现在看来是多此一举的。 由于React合成事件系统模拟事件冒泡的方法是构建一个自己及父组件队列，因此也带来一个问题，合成事件不能阻止原生事件，原生事件可以阻止合成事件。用 event.stopPropagation() 并不能停止事件传播，应该使用 event.preventDefault()。 如果你想详细了解React合成事件系统，移步http://blog.csdn.net/u013510838/article/details/61224760 组件的生命周期（以父子组件为例）为了搞清楚组件生命周期，构造一个父组件包含子组件并且重写各生命周期函数的场景： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Child extends React.Component &#123; constructor() &#123; super() console.log('Child was created!') &#125; componentWillMount()&#123; console.log('Child componentWillMount!') &#125; componentDidMount()&#123; console.log('Child componentDidMount!') &#125; componentWillReceiveProps(nextProps)&#123; console.log('Child componentWillReceiveProps:'+nextProps.data ) &#125; shouldComponentUpdate(nextProps, nextState)&#123; console.log('Child shouldComponentUpdate:'+ nextProps.data) return true &#125; componentWillUpdate(nextProps, nextState)&#123; console.log('Child componentWillUpdate:'+ nextProps.data) &#125; componentDidUpdate()&#123; console.log('Child componentDidUpdate') &#125; render() &#123; console.log('render Child!') return ( &lt;h1&gt;Child recieve props: &#123;this.props.data&#125;&lt;/h1&gt; ); &#125;&#125;class Father extends React.Component &#123; // ... 前面跟子组件一样 handleChangeState()&#123; this.setState(&#123;randomData: Math.floor(Math.random()*50)&#125;) &#125; render() &#123; console.log('render Father!') return ( &lt;div&gt; &lt;Child data=&#123;this.state.randomData&#125; /&gt; &lt;h1&gt;Father State: &#123; this.state.randomData&#125;&lt;/h1&gt; &lt;button onClick=&#123;this.handleChangeState&#125;&gt;切换状态&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;React.render( &lt;Father /&gt;, document.getElementById('root')); 结果如下：刚开始调用父组件的setState后：在Jsbin上试试看有一张图能说明这之间的流程（图片来源）： setState并不奇怪有一个能反映问题的场景： 12345678910...state = &#123; count: 0&#125;componentDidMount() &#123; this.setState(&#123;count: this.state.count + 1&#125;) this.setState(&#123;count: this.state.count + 1&#125;) this.setState(&#123;count: this.state.count + 1&#125;)&#125;... 看起来state.count被增加了三次，但结果是增加了一次。这并不奇怪： React快的原因之一就是，在执行this.setState()时，React没有忙着立即更新state，只是把新的state存到一个队列（batchUpdate）中。上面三次执行setState只是对传进去的对象进行了合并,然后再统一处理（批处理），触发重新渲染过程，因此只重新渲染一次，结果只增加了一次。这样做是非常明智的，因为在一个函数里调用多个setState是常见的，如果每一次调用setState都要引发重新渲染，显然不是最佳实践。React官方文档里也说了： Think of setState() as a request rather than an immediate command to update the component. 把setState() 看作是重新render的一次请求而不是立刻更新组件的指令。 那么调用this.setState()后什么时候this.state才会更新？答案是即将要执行下一次的render函数时。 这之间发生了什么？setState调用后，React会执行一个事务（Transaction），在这个事务中，React将新state放进一个队列中，当事务完成后，React就会刷新队列，然后启动另一个事务，这个事务包括执行 shouldComponentUpdate 方法来判断是否重新渲染，如果是，React就会进行state合并（state merge）,生成新的state和props；如果不是，React仍然会更新this.state，只不过不会再render了。 开发人员对setState感到奇怪的原因可能就是按照上述写法并不能产生预期效果，但幸运的是我们改动一下就可以实现上述累加效果：这归功于setState可以接受函数作为参数： setState(updater, [callback]) 12345678910...state = &#123; score: 0&#125;componentDidMount() &#123; this.setState( (prevState) =&gt; (&#123;score : prevState.score + 1&#125;) ) this.setState( (prevState) =&gt; (&#123;score : prevState.score + 1&#125;) ) this.setState( (prevState) =&gt; (&#123;score : prevState.score + 1&#125;) ) &#125;&#125; 这个updater可以为函数，该函数接受该组件前一刻的 state 以及当前的 props 作为参数，计算和返回下一刻的 state。 你会发现达到增加三次的目的了: 在Jsbin上试试看 这是因为React会把setState里传进去的函数放在一个任务队列里，React 会依次调用队列中的函数，传递给它们前一刻的 state。 另外，不知道你在jsbin上的代码上注意到没有，调用setState后console.log(this.state.score)输出仍然为0，也就是this.state并未改变，并且只render了一次。 总结学习一个框架或者工具，我觉得应该了解以下几点： 它是什么？能做什么？ 它存在的理由是什么？解决了什么样的问题、满足了什么样的需求？ 它的适用场景是什么？优缺点是什么？ 它怎么用？最佳实践是什么？ 它的原理是什么？ … 通过对React一些原理的简单了解，就懂得了React为什么这么快速的原因之一，也会在问题出现时知道错在什么地方，知道合理的解决方案。","tags":[{"name":"React","slug":"React","permalink":"http://realtcg.com/tags/React/"}]},{"title":"React + Redux + react router技术栈架构","date":"2017-06-24T11:59:52.000Z","path":"2017/06/24/React + Redux + react router技术栈架构/","text":"前言前些日子刚学习了React，觉得很不错，很符合我的逻辑。于是还没弄明白，就迫不及待的开始了一个中型项目(我觉得）（其实是项目需要赶紧开始，没时间了…咳咳）。期间不出所料地遇到了很多坑和问题，也得到了很多收获，特开几篇文章记录下来。 概述本文是《使用React技术栈的一些收获》系列文章的第一篇，介绍了项目是如何架构的。 具体技术栈项目技术栈使用的是React全家桶：React+redux+react router+es6+webpack+sass以及Data到View层我们使用了reselect。由于数据处理逻辑并不复杂，因此并没有使用immutable.js和Redux saga（后来我觉得连Redux都没必要用）；样式方面考虑到可读性和开发人数较少（俩），我们并没有使用流行的CSS-module。 脚手架的选择选择脚手架就选择了整体架构，我选择的是davezuko大神的react-redux-starter-kit，也是最受欢迎的脚手架之一。并在它的基础上安装了一些用到的包，删去了一些不用的包，让它更适合我们的项目。 项目架构项目目录如下：​ 根据脚手架的架构，我们构建的是一个React单页应用。 总体来说就是采用React router plain object+combineReducer+require.ensure的写法把不同的路由分割在routes目录下，对应不同的页面，做代码分割、按需加载。逻辑图如下： 具体来说首先src目录下有一个main.js，它用来创建store，并拿到路由（plain object形式），然后注入到顶层的Provider组件和其下的Router组件： src下的main.js文件：12345678910111213const initialState = window.___INITIAL_STATE__const store = createStore(initialState)// 创建storeconst MOUNT_NODE = document.getElementById('root')let render = () =&gt; &#123; const routes = require('./routes/index').default(store)// 拿到路由 ReactDOM.render( &lt;AppContainer store=&#123;store&#125; routes=&#123;routes&#125; /&gt;, //注入 MOUNT_NODE )&#125; redux的store也随着页面分割而分割：​ 不同页面下的modules下的文件只负责本页面所需的所有action和reducer，并通过加载页面inject主reducer里，然后在src/store/reduce.js文件里combine,最后被引入到src/store/createStore里和同时引入的redux中间件一起创建store： src/store目录下的reducer.js：12345678910111213export const makeRootReducer = (asyncReducers) =&gt; &#123; return combineReducers(&#123; auth: auth, form: formReducer, location: locationReducer, ...asyncReducers // 各页面下的reducer注入到这里 &#125;)&#125;export const injectReducer = (store, &#123; key, reducer &#125;) =&gt; &#123; store.asyncReducers[key] = reducer store.replaceReducer(makeRootReducer(store.asyncReducers))//注入时更新&#125; 以及src/store下的createStore文件：12345678const store = createStore( makeRootReducer(), initialState, compose( applyMiddleware(...middleware), ...enhancers ) ) routes目录下有一个index.js文件，它使用plain object的写法集合各路由对应的页面； routes下的index.js文件：（用来包含各页面）src/routes/index.js:(采用React router plain object写法) 12345678910111213141516171819202122import CoreLayout from '../layouts/CoreLayout'import Home from './Home'import FollowRoute from './Follow'import SignRoute from './Sign'import HallRoute from './Hall'import UserPageRoute from './UserPage'import PageNotFound from './PageNotFound'import Redirect from './PageNotFound/redirect'export const createRoutes = (store) =&gt; (&#123; path: '/', component: CoreLayout, indexRoute: Home, childRoutes: [ // 各页面 FollowRoute(store), SignRoute(store), HallRoute(store), UserPageRoute(store), PageNotFound(), Redirect ]&#125;) 每个页面目录下也有一个index.js文件并使用getComponent + webpack ensure按需加载页面的container和reducer： 每个页面下的index.js文件：(负责输出这个页面)src/routes/sign/index.js（其他页面差不多，举个例子） 12345678910111213import &#123; injectReducer &#125; from '../../store/reducers'// 引入注入reducer函数export default (store) =&gt; (&#123; path: 'sign', //页面路由 getComponent (nextState, cb) &#123; require.ensure([], (require) =&gt; &#123; // webpack按需加载 const Sign = require('./containers/SignContainer').default //引入总container const reducer = require('./modules/index').default//引入总reducer injectReducer(store, &#123; key: 'sign', reducer &#125;)// 加载时注入页面reducer到主reducer cb(null, Sign)// 返回页面 &#125;) &#125;&#125;) 在每个页面下，index.js是获得每个页面的入口，每个页面都有自己的components和containers以及actions和reducers，目录看起来像这样： components和containers都是这个页面下的组件和容器，如果其他页面也会使用里面的组件和容器，就会把他们放在src/component和src/containers下共用。modules下的文件是这个页面所有的action和reducer。如果页面逻辑可以分离，会把各逻辑下的reducer抽离并单开一个index.js，并在其中combine： ​ =&gt; 总结与反思通过上述架构，项目代码逻辑变得很清晰，每一个文件都有其专属的功能，互不影响，开发过程变得工程化、流程化，思路很清晰，代码出错率大大降低，开发速度大大提高。React router plain object+redux combineReducer的组合很好的将代码按不同页面做了分割;而 getComponent + webpack ensure又做到了页面的按需加载，项目页面运行速度提升了不少。但是有一个问题，在react route4.0版本中getComponent被移除了，并提供了更加简洁的方式（实际上就是替你做了按需加载）：Bundle组件+webpack 加载器undle-loader。使用这种方式的话，目录结构将会变得更简单、更容易理解，避免了多层嵌套，因此，项目还需要改善。","tags":[{"name":"架构","slug":"架构","permalink":"http://realtcg.com/tags/架构/"}]},{"title":"JavaScript常用函数总结(一)","date":"2017-05-12T16:00:44.000Z","path":"2017/05/13/JavaScript常用函数总结-一/","text":"前言最近在使用React技术栈时并没有选用jQuery,想借此巩固一下原生API,提高原生开发能力,毕竟这才是内功。 概述本文总结了JavaScript常用函数，这些函数包括Array常用函数以及String常用函数 JavaScript原生函数Array常用函数 isArray() -判断某个值是不是数组类型 123if(Array.isArray(value))&#123; //对数组进行操作&#125; join(&quot;分隔符&quot;) 12var a = [1,2,3,4,5]; var b = a.join(\"|\"); //a：[1,2,3,4,5] b：\"1|2|3|4|5\" 栈方法 push() -可以接受任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度： 1234var colors = new Array();var count = colors.push(\"red\",\"green\");console.log(colors);//[\"red\",\"green\"]console.log(count);//2 pop() -从数组末尾移除最后一项，减少数组length值，然后返回移除的项 123var item = colors.pop();console.log(item);//\"green\"console.log(colors.length);//1 队列方法 shift() -移除数组的第一项并返回该项，同时将数组长度减一 123var item = colors.shift();console.log(item);//\"red\"console.log(colors.length);//1 unshift() -在数组前端添加任意个项并返回新数组的长度 12var count = colors.unshift(\"yellow\",\"black\");console.log(colors);//[\"yellow\",\"black\",\"red\",\"green\"] 重排序方法 reverse() -反转数组项的顺序 12var values = [1,2,3,4,5];console.log(values.reverse());//5,4,3,2,1 sort() -默认情况下按升序排列数组项，即最小的值在前。为了实现排序，sort方法会调用每个数组项的toString(),然后比较字符串，以确定排序。即使数值项是数字，比较的也是字符串，这通常不是最佳方案，因此sort()可以接受一个比较函数作为参数，返回经过排序后的数组 1234567var values = [0,1,5,10,15];console.log(values.sort());//0,1,10,15,5function compare(value1,value2)&#123;return value2 - value1;&#125;console.log(values.sort(compare));//0,1,5,10,15 操作方法 concat() -合并数组的意思,可以接受n个字符串或数组。 123var colors = [\"red\",\"green\",\"pink\"];var color2 = colors.concat(\"bliue\",[\"black\",\"yellow\"]);//[\"red\",\"green\",\"pink\",\"blue\",\"black\",\"yellow\"] 先创建一个数组副本，然后将接受到的参数添加到副本末尾，最后返回新构建的数组，原数组不会受到影响。 slice() -切数组的意思，接受一到两个数值型参数表示切下的起始结束位置 123var colors = [\"red\",\"green\",\"pink\"];var color1 = colors.slice(1);//[\"green\",\"pink\"]var color2 = colors.slice(1,2); //[\"green\"] slice()同样不会对原数组产生影响，它会创建一个副本操作后返回。参数可以为负数。 splice() -剪接的意思，可以实现数组的删除、插入、替换。 splice(起始位置,删除的项数,插入的项(可以多个项,可选)) 返回从原始数组中删除的项,对原数组直接操作 123var colors = [\"red\",\"green\",\"pink\"];var color1 = colors.splice(0,1);//[\"green\",\"pink\"],删除第一项var color2 = colors.splice(1,0,\"black\"); //[\"green\",“black”,\"pink\"] indexOf() -返回查找的项的位置，接受两个参数，indexOf(要查找的项(可选),查找起点位置索引),它会使用===来查 1234var colors = [\"red\",\"green\"];console.log(colors);//[\"red\",\"green\"]console.log(color2);/ 迭代方法 以下每个迭代函数都会接受两个参数，一个是要在每一项运行的函数和运行在该函数的作用域对象——影响this的值，为数组的每一项运行的给定函数接受三个参数：function(数组的项,该项在对象的位置,数组本身){} every() -如果该函数对每一项都返回true，则返回true filter() -返回该函数会返回true的项组成的数组 forEach() -单纯运行给定函数，无返回值 map() -返回给定函数运行在数组中的每个项的结果组成的数组 some() -如果该函数对任一项返回true，则返回true 1234567891011121314151617181920 var values = [1,2,3,4,5]; console.log(values.every(function(item)&#123; return (item&gt;2); &#125;));//false console.log(values.some(function(item)&#123; return (item&gt;2); &#125;));//true console.log(values.filter(function(item)&#123; return (item&gt;2); &#125;));//[3,4,5] console.log(values.map(function(item)&#123; return (item*2); &#125;));//[2,4,6,8,10] console.log(values.forEach(function(item)&#123; //执行某些操作&#125;)); 归并方法 reduce() -浓缩的意思，接受一个给定函数（function(pre,cur,index,array){}）和作为归并基础的值（可选），迭代数组所有项，返回一个构建的值 1234var values = [1,2,3,4,5];console.log(values.reduce(function(pre,cur,index,array)&#123;return pre + cur;&#125;));//15 String常用函数 查找方法 字符串方法 charAt(n)返回字符串中第n(0~length-1)个字符； charCodeAt(n)返回字符串中第n个字符的Unicode编码； fromCharCode(0或多个字符的Unicode编码)返回根据字符编码创建的字符串 位置方法 indexOf(要查找的字符串,开始查找位置（可选）)返回找到的子串首次出现的索引或-1（未找到）。可以用于数组查找项，不能查找对象。 匹配方法 match(正则表达式)返回存放匹配结果的数组，正则如果没有加全局标记g那么这个数组会有个input属性，它指向调用match()的字符串对象.未找到返回null. 12345var str = \"hello,world\";str.match(\"he\");[\"he\", index: 0, input: \"hello,world\"]str.match(/he/);//[\"he\", index: 0, input: \"hello,world\"]str.match(/he/g);//[\"he\"]str.match(/l/g);//[\"l\", \"l\", \"l\"] search(正则表达式)返回字符串中第一个与正则表达式相匹配的子串的索引，忽略全局标记g和lastIndex属性 12345var str = \"hello,world\";str.search(\"he\");//0str.search(/he/);//0str.search(/he/g);//0str.match(/l/g);//2 replace(正则(字符串),替换文本或函数)创建一个原字符串副本，替代后返回 123var str = \"hello,world\";str.replace(/l/g,\"b\");//\"hebbo,worbd\"console.log(str);//\"hello,world\" split(分隔符,(数组长度))返回根据指定分隔符将字符串分割成多个子串组成的数组,这个分隔符必须是原字符串里的某个字符，否则返回原字符串 123var str = \"hello,world\";str.split(\"\");//[\"h\", \"e\", \"l\", \"l\", \"o\", \",\", \"w\", \"o\", \"r\", \"l\", \"d\"]str.split(\"o\");//[\"hell\", \",w\", \"rld\"] 操作方法 concat(string,...)返回把所有参数都连接到原字符串后形成的字符串 slice(剪切的起始位置,结束位置)返回剪切后的字符串，创建副本，原字符串不变 substring()功能与slice相同，不同的是参数不能为负 trim()清楚字符串（注意不是字符）前后的空格 编码方法 escape(string)、unescape(string)返回字符串常规编码（解码） encodeURI(string)、decodeURI(string)URI字符串编码与解码 转换方法 toUpperCase()、toLocaleUpperCase()转为大写 toLowerCase()、toLocaleLowerCase()转为小写","tags":[{"name":"JavaScript,JavaScript函数","slug":"JavaScript-JavaScript函数","permalink":"http://realtcg.com/tags/JavaScript-JavaScript函数/"}]},{"title":"我对JavaScript对象的理解","date":"2017-04-16T04:53:16.000Z","path":"2017/04/16/我对JavaScript对象的理解/","text":"前言JavaScript这门语言除了基本类型都是对象，可以说JavaScript核心就是对象，因此理解JavaScript对象及其种种特性至关重要，这是内功。本文介绍了我对es5对象，原型, 原型链,以及继承的理解 注意（这篇文章特别长）这篇文章仅仅是我个人对于JavaScript对象的理解，并不是教程。这篇文章写于我刚了解js对象之后。文章肯定有错误之处，还望读者费心指出，在下方评论即可^-^ 什么是JavaScript对象12345678910111213141516var person = &#123; //person就是对象，对象都有各种属性，每个属性又都对应着自己的值 //键值对形式 name: \"Mofan\",//可以包含字符串 age: 20,//数字 parents: [ //数组 \"Daddy\", \"Mami\", ] sayName: function()&#123; //函数 console.log(this.name); &#125;, features: &#123; //对象 height: \"178cm\", weight: \"60kg\", &#125;&#125; js里除了基本类型外所有事物都是对象： 函数是对象：function sayName(){} ` `——sayName是函数对象 数组是对象：var arr = new Array() ——arr是数组对象 为什么JavaScript要这么设计呢？我觉得首先这样一来，统一了数据结构，使JavaScript成为一门编程风格非常自由化的脚本语言：无论定义什么变量，统统var；其次，JavaScript对象都有属性和方法，函数数组都是对象，调用引用就会非常灵活方便；再者，为了构建原型链？ 创建对象的几种方式 Object()模式使用对象字面量：var obj={...}就像上面那样或者使用原生构造函数Object()： 1234567var person = new Object();person.name = \"Mofan\";person.sayName = function()&#123; console.log(this.name); &#125;;console.log(person.name);//Mofanobj.sayName();//Mofan 利用函数作用域使用自定义构造函数模式模仿类（构造器模式）： 12345678910function Person(name,age)&#123; this.name = name; this.age = age; this.print = function()&#123; console.log(this.name + this.age) &#125;;&#125;var person = new Person(\"Mofan\",19);console.log(person.name+person.age);//Mofan19person.print();//Mofan19 原型模式： 12345678910111213141516171819function Person()&#123;&#125;//可以这样写/*Person.prototype.name = \"Mofan\";Person.prototype.age = 19;Person.prototype.print = function()&#123; console.log(this.name+this.age);&#125;*///推荐下面这样写，但两种方式不能混用！因为下面这种方式实际上重写了//Person原型对象，如果两者混用，后面赋值方式会覆盖前面赋值方式Person.prototype = &#123; name:\"Mofan\", age:19, print:function()&#123; console.log(this.name+this.age); &#125;&#125;var person = new Person();console.log(person.name+person.age);//Mofan19person.print();//Mofan19 组合构造函数模式和原型模式： 12345678910111213141516function Person(name,age)&#123; //这里面初始化属性 this.name = name; this.age = age; ...&#125;Person.prototype = &#123; //这里面定义公有方法 print:function()&#123; console.log(this.name+this.age); &#125;, ...&#125;var person = new Person(\"Mofan\",19);console.log(person.name+person.age);//Mofan19person.print();//Mofan19 动态创建原型模式： 1234567891011121314151617181920function Person(name,age)&#123; //初始化属性 this.name = name; this.age = age; //在创建第一个对象（第一次被调用）时定义所有公有方法,以后不再调用 if(typeof this.print !=\"function\")&#123; Person.prototype.print =function()&#123; console.log(this.name+this.age); &#125;; Person.prototype.introduction=function()&#123; console.log(\"Hi!I'm \"+this.name+\",I'm \"+this.age); &#125;; //如果采用对象字面量对原型添加方法的话，第一次创建的对象将不会有这些方法 &#125;; &#125;var person = new Person(\"Mofan\",19);person.print();//Mofan19person.introduction();//Hi!I'm Mofan,I'm 19 还有一些模式用的场景比较少 这些模式的应用场景怎么会有这么多的创建模式？其实是因为js语言太灵活了，因此前辈们总结出这几种创建方式以应对不同的场景，它们各有利弊。 第一种方式，使用字面量或者使用构造函数Object()常用于创建普通对象存储数据等。它们的原型都是Object，彼此之间没有什么关联。事实上，下面创建方式都是一样的： 123456var o1 = &#123;&#125;;//字面量的表现形式var o2 = new Object;var o3 = new Object();var o4 = new Object(null);var o5 = new Object(undefined);var o6 = Object.create(Object.prototype);//等价于 var o = &#123;&#125;;//即以 Object.prototype 对象为一个原型模板,新建一个以这个原型模板为原型的对象 第二种方式，利用函数作用域模仿类，这样就可以在创建对象时传参了，可以创建不同属性值得对象，实现对象定制。不过print方法也定义在了构造函数里面，如果要把它当做公有方法的话，这样每new一个对象，都会有这个方法，太浪费内存了。可以这样修改一下构造器模式： 1234567891011121314//构造器方法2function print()&#123; //定义一个全局的 Function 对象,把要公有的方法拿出来 console.log(this.name + this.age);&#125;function Person(name,age)&#123; this.name = name; this.age = age; this.print = print.bind(this);//每个 Person 对象共享同一个print 方法版本(方法有自己的作用域，不用担心变量被共享)&#125;var person = new Person(\"Mofan\",19); console.log(person.name+person.age);//Mofan19 person.print();//Mofan19 然而这样看起来很乱，也谈不上类的封装性。还是使用原型吧 第三种方式，纯原型模式，不管是属性还是方法都添加到原型里面去了，这样做好处是很省内存，但是应用范围就少了，更多的对象 内部的属性是需要定制的，而且一旦更改原型，所有这个原型实例都会跟着改变。因此可以结合构造函数方式来实现对对象的定制，于是就有了第四种方式——组合构造函数模式与原型模式，可以定制的放在构造器里，共有的放在原型里，这也符合构造器和原型的特性。 “这是es5中使用最广泛、认同度最高的创建自定义类型的方法”—《JavaScript高级程序设计》第三版 第五种方式，动态原型模式，出现这种方式是因为有些面向对象开发人员习惯了类构造函数，于是对这种独立出来的构造函数和原型感到困惑和不习惯。于是，就出现了把定义原型也写进构造函数里的动态原型模式。上面在动态原型模式程序里面讲“如果采用对象字面量对原型添加方法的话，第一次创建的对象将不会有这些方法”这是因为在if语句执行以前，第一个对象已经被创建了，然后执行if里面的语句，如果采用对象字面量给原型赋值，就会导致原型在实例创建之后被重写，创建的第一个实例就会失去与原型的链接，也就没有原型里的方法了。不过以后创建的对象就可以使用原型里的方法了，因为它们都是原型被修改后创建的。 原型是什么在JavaScript中，原型就是一个对象，没必要把原型和其他对象区别对待，只是通过它可以实现对象之间属性的继承。任何一个对象也可以成为原型。之所以经常说对象的原型，实际上就是想找对象继承的上一级对象。对象与原型的称呼是相对的，也就是说，一个对象，它称呼继承的上一级对象为原型，它自己也可以称作原型链下一级对象的原型。 一个对象内部的[[Prototype]]属性生来就被创建，它指向继承的上一级对象，称为原型。函数对象内部的prototype属性也是生来就被创建（只有函数对象有prototype属性），它指向函数的原型对象（不是函数的原型！）。当使用var instance = new Class();这样每new一个函数（函数被当做构造函数来使用）创建实例时，JavaScript就会把这个原型的引用赋值给实例的原型属性，于是实例内部的[[Prototype]]属性就指向了函数的原型对象，也就是prototype属性。 原型真正意义上指的是一个对象内部的[[Prototype]]属性，而不是函数对象内部的prototype属性，这两者之间没有关系！对于一个对象内部的[[Prototype]]属性，不同浏览器有不同的实现： 12345678910 var a = &#123;&#125;; //Firefox 3.6+ and Chrome 5+ Object.getPrototypeOf(a); //[object Object] //Firefox 3.6+, Chrome 5+ and Safari 4+ a.__proto__; //[object Object] //all browsers a.constructor.prototype; //[object Object] 之所以函数对象内部存在prototype属性，并且可以用这个属性创建一个原型，是因为这样以来，每new一个这样的函数（函数被当做构造函数来使用）创建实例，JavaScript就会把这个原型的引用赋值给实例的原型属性，这样以来，在原型中定义的方法等都会被所有实例共用，而且，一旦原型中的某个属性被定义，就会被所有实例所继承（就像上面的例子）。这种操作在性能和维护方面其意义是不言自明的。这也正是构造函数存在的意义（JavaScript并没有定义构造函数，更没有区分构造函数和普通函数，是开发人员约定俗成）。下面是一些例子： 1234567891011121314var a = &#123;&#125; //一个普通的对象function fun()&#123;&#125; //一个普通的函数//普通对象没有prototype属性console.log(a.prototype);//undefinedconsole.log(a.__proto__===Object.prototype);//true//只有函数对象有prototype属性console.log(fun.prototype);//Objectconsole.log(fun.__proto__===Function.prototype);//trueconsole.log(fun.prototype.__proto__===Object.prototype);//trueconsole.log(fun.__proto__.__proto__===Object.prototype);//trueconsole.log(Function.prototype.__proto__===Object.prototype);//trueconsole.log(Object.prototype.__proto__);//null 当执行console.log(fun.prototype);输出为可以看到，每创建一个函数，就会创建prototype属性，这个属性指向函数的原型对象（不是函数的原型），并且这个原型对象会自动获得constructor属性，这个属性是指向prototype属性所在函数的指针。而__proto__属性是每个对象都有的。 接着上面再看： 123456789101112function Person()&#123;&#125;//构造函数,约定首字母大写var person1 = new Person();//person1为Person的实例console.log(person1.prototype);//undefinedconsole.log(person1.__proto__===Person.prototype);//trueconsole.log(person1.__proto__.__proto__===Object.prototype);//trueconsole.log(person1.constructor);//function Person()&#123;&#125;//函数Person是Function构造函数的实例console.log(Person.__proto__===Function.prototype);//true//Person的原型对象是构造函数Object的实例console.log(Person.prototype.__proto__===Object.prototype);//true person1和上面那个普通的对象a有区别，它是构造函数Person的实例。前面讲过： 当使用var instance = new Class();这样每new一个函数（函数被当做构造函数来使用）创建实例时，JavaScript就会把这个原型的引用赋值给实例的原型属性，于是实例内部的[[Prototype]]属性就指向了函数的原型对象，也就是prototype属性。 因此person1内部的[[Prototype]]属性就指向了Person的原型对象，然后Person的原型对象内部的[[Prototype]]属性再指向Object.prototype，相当于在原型链中加了一个对象。通过这种操作，person1就有了构造函数的原型对象里的方法。 另外，上面代码console.log(person1.constructor);//function Person(){}中，person1内部并没有constructor属性，它只是顺着原型链往上找，在person1.__proto__里面找到的。 可以用下面这张图理清原型、构造函数、实例之间的关系： 继承JavaScript并没有继承这一现有的机制，但可以利用函数、原型、原型链模仿。下面是三种继承方式： 类式继承1234567891011121314151617181920212223//父类function SuperClass()&#123; this.superValue = \"super\";&#125;SuperClass.prototype.getSuperValue = function()&#123; return this.superValue;&#125;;//子类function SubClass()&#123; this.subValue = \"sub\";&#125;//类式继承,将父类实例赋值给子类原型，子类原型和子类实例可以访问到父类原型上以及从父类构造函数中复制的属性和方法SubClass.prototype = new SuperClass();//为子类添加方法SubClass.prototype.getSubValue = function()&#123; return this.subValue;&#125;//使用var instance = new SubClass();console.log(instance.getSuperValue);//superconsole.log(instance.getSubValue);//sub 这种继承方式有很明显的两个缺点： 实例化子类时无法向父类构造函数传参 如果父类中的共有属性有引用类型，就会在子类中被所有实例所共用，那么任何一个子类的实例更改这个引用类型就会影响其他子类实例,可以使用构造函数继承方式解决这一问题 构造函数继承1234567891011121314151617181920212223 //父类 function SuperClass(id)&#123; this.superValue = [\"big\",\"large\"];//引用类型 this.id = id; &#125; SuperClass.prototype.getSuperValue = function()&#123; return this.superValue; &#125;; //子类 function SubClass(id)&#123; SuperClass.call(this,id);//调用父类构造函数并传参 this.subValue = \"sub\"; &#125; var instance1 = new SubClass(10);//可以向父类传参 var instance2 = new SubClass(11); instance1.superValue.push(\"super\");console.log(instance1.superValue);//[\"big\", \"large\", \"super\"]console.log(instance1.id);//10console.log(instance2.superValue);[\"big\", \"large\"]console.log(instance2.id);//11console.log(instance1.getSuperValue());//error 这种方式是解决了类式继承的缺点，不过在代码的最后一行你也看到了，没有涉及父类原型，因此违背了代码复用的原则。所以组合它们： 组合继承123456789101112131415161718192021222324252627282930function SuperClass(id)&#123; this.superValue = [\"big\",\"large\"];//引用类型 this.id = id; &#125; SuperClass.prototype.getSuperValue = function()&#123; return this.superValue; &#125;; //子类 function SubClass(id,subValue)&#123; SuperClass.call(this,id);//调用父类构造函数并传参 this.subValue = subValue; &#125; SubClass.prototype = new SuperClass(); SubClass.prototype.getSubValue = function()&#123; return this.subValue; &#125; var instance1 = new SubClass(10,\"sub\");//可以向父类传参 var instance2 = new SubClass(11,\"sub-sub\"); instance1.superValue.push(\"super\"); console.log(instance1.superValue);//[\"big\", \"large\", \"super\"] console.log(instance1.id);//10 console.log(instance2.superValue);[\"big\", \"large\"] console.log(instance2.id);//11 console.log(instance1.getSuperValue());[\"big\", \"large\", \"super\"] console.log(instance1.getSubValue());//sub console.log(instance2.getSuperValue());//[\"big\", \"large\"] console.log(instance2.getSubValue());//sub-sub 嗯，比较完美了，但是有一点，父类构造函数被调用了两次，这就导致第二次调用也就是创建实例时重写了原型属性，原型和实例都有这些属性，显然性能并不好。先来看看克罗克福德的寄生式继承： 12345678910111213141516171819 function object(o)&#123; function F()&#123;&#125;; F.prototype = o; return new F(); &#125; function createAnnther(original)&#123; var clone = object(original); clone.sayName = function()&#123; console.log(this.name); &#125; return clone; &#125; var person = &#123; name:\"Mofan\", friends:[\"xiaoM\",\"Alice\",\"Neo\"], &#125;; var anotherPerson = createAnnther(person); anotherPerson.sayName();//\"Mofan\"&#125; 就是让一个已有对象变成新对象的原型，然后再在createAnother函数里加强。你也看到了，person就是一个普通对象，所以这种寄生式继承适合于根据已有对象创建一个加强版的对象，在主要考虑通过已有对象来继承而不是构造函数的情况下，这种方式的确很方便。但缺点也是明显的，createAnother函数不能复用，我如果想给另外一个新创建的对象定义其他方法，还得再写一个函数。仔细观察一下，其实寄生模式就是把原型给了新对象，对象再加强。 等等，写到这个地方，我脑子有点乱，让我们回到原点：继承的目的是什么？应该继承父类哪些东西？我觉得取决于我们想要父类的什么，我想要父类全部的共有属性（原型里）并且可以自定义继承的父类私有属性（构造函数里）！前面那么多模式它们的缺点主要是因为这个： 1SubClass.prototype = new SuperClass(); 那为什么要写这一句呢？是只想要继承父类的原型吗？如果是为什么不这么写： 1SubClass.prototype = SuperClass.prototype; 这样写是可以继承父类原型，但是风险极大：SuperClass.prototype属性它是一个指针，指向SuperClass的原型，如果把这个指针赋给子类prototype属性，那么子类prototype也会指向父类原型。对SubClass.prototype任何更改，就是对父类原型的更改，这显然是不行的。 寄生组合式继承但出发点没错，可以换种继承方式，看看上面的寄生式继承里的object()函数，如果把父类原型作为参数，它返回的对象实现了对父类原型的继承，没有调用父类构造函数，也不会对父类原型产生影响，堪称完美。 12345678910111213141516171819202122232425262728293031323334353637383940function object(o)&#123; function F()&#123;&#125;; F.prototype = o; return new F(); &#125;function inheritPrototype(subType,superType)&#123; var proto = object(superType.prototype); proto.constructor = subType;//矫正一下construcor属性 subType.prototype = proto; &#125; function SuperClass(id)&#123; this.superValue = [\"big\",\"large\"];//引用类型 this.id = id; &#125; SuperClass.prototype.getSuperValue = function()&#123; return this.superValue; &#125;; //子类 function SubClass(id,subValue)&#123; SuperClass.call(this,id);//调用父类构造函数并传参 this.subValue = subValue; &#125; inheritPrototype(SubClass,SuperClass);//继承父类原型 SubClass.prototype.getSubValue = function()&#123; return this.subValue; &#125; var instance1 = new SubClass(10,\"sub\");//可以向父类传参 var instance2 = new SubClass(11,\"sub-sub\"); instance1.superValue.push(\"super\"); console.log(instance1.superValue);//[\"big\", \"large\", \"super\"] console.log(instance1.id);//10 console.log(instance2.superValue);//[\"big\", \"large\"] console.log(instance2.id);//11 console.log(instance1.getSuperValue());//[\"big\", \"large\", \"super\"] console.log(instance1.getSubValue());//sub console.log(instance2.getSuperValue());//[\"big\", \"large\"] console.log(instance2.getSubValue());//sub-sub 解决了组合继承的问题，只调用了一次父类构造函数，而且还能保持原型链不变，为什么这么说，看对寄生组合的测试： 12console.log(SubClass.prototype.__proto__===SuperClass.prototype);//ture console.log(SubClass.prototype.hasOwnProperty(\"getSuperValue\"));//false 因此，这是引用类型最理想的继承方式。 总结创建用于继承的对象最理想的方式是组合构造函数模式和原型模式（或者动态原型模式），就是让可定义的私有属性放在构造函数里，共有的放在原型里；继承最理想的方式是寄生式组合，就是让子类的原型的[[prototype]]属性指向父类原型，然后在子类构造函数里调用父类构造函数实现自定义继承的父类属性。 JavaScript对象总有一些让我困惑的地方，不过我还会继续探索。我在此先把我了解的记录下来，与各位共勉。错误的地方请费心指出，我将感谢您的批评指正。 本文为作者原创，转载请注明本文链接，作者保留权利。 参考文献：[1] http://www.cnblogs.com/chuaWeb/p/5039232.html[2] http://www.cnblogs.com/xjser/p/4962821.html[3] https://javascriptweblog.wordpress.com/2010/06/07/understanding-javascript-prototypes/","tags":[{"name":"JavaScript对象","slug":"JavaScript对象","permalink":"http://realtcg.com/tags/JavaScript对象/"}]},{"title":"今天我20岁","date":"2017-03-08T15:37:45.000Z","path":"2017/03/08/20/","text":"今天，我来到地球整整20年了。 本来还想大过一回，好好庆祝一下，但想想《好先生》里陆远说的那句话：“男人需要一辈子来成熟”也就作罢了。可今天毕竟是意义非凡的一天，所以我决定在今天把这些天我想说的话，我心里的话都写下来，以后多少有个纪念。 20岁了，不是十几岁了，想想都觉得可怕，想想都觉得时间过的飞快。以前还在想:我什么时候才能到20岁，我20多岁会是什么样子。喏，这不就20岁了么。 上了大学以来，可以说我的心态和三观发生了不小的变化，自己也默默承受着变化带来的副作用。也不跟人说，跟谁说呢？跟父母说？让他们担心你？跟远方的好朋友说？算了，没多大事，跟周围的人说？别开玩笑了，我可说不出口，他们也没兴趣听。还是憋在心里慢慢消化吧.. 梦想20岁，还年轻，不过我急于证明自己，想尽快有所成就，不再依靠父母，早日让他们享福。所以我大一就想好了不读研，大学毕业尽快工作。先让这个家庭富裕起来，再去实现我的梦想吧。有时候觉得一个人的发展很多受家庭的影响:就像我的家庭并不富裕，而且在整个家族里都是最不富裕的，我就想长大挣大钱，先过上富裕的生活，再做自己想做的事。尤其这两年，我见识外面精彩的世界越多，我就越向往，然后就越来越感到与现实的差距，这种差距感不断地督促我，加快我朝着梦想的步伐。 20岁，我一无所有，却想要一切。 所以我对自己的要求越来越严格，越来越自律。不打游戏，不看剧，不出去浪，甚至连谈恋爱都觉得是奢望。每天看书，敲代码，清心寡欲，干一点别的事都觉得有愧疚感。没事，哪怕我舍弃别的东西，我学有所成也行啊，至少有一件事做成了也能给我安慰啊。然而事情总是不像我想象的那样好，有时候光靠努力是不行的，还要有方法、运气、效率… 我最害怕的就是，我舍弃了别的东西，还没弄好一直投入精力去做的事情。 所以每当我学习不顺的时候，我的心情就糟糕到了极点。原本我可以花时间多交几个朋友，我们一起吃饭，一起出去玩，一起打球，放假一块出去旅游;说不定我还会遇到我生命中的那个她，我们互相爱着对方，照顾对方，给予对方心灵的慰藉和归属感，一起享受和对方快乐美好的时光…这才是我心目中的那个青春。 可是我总是强行打破幻想:度过了这些快乐时光之后呢？你是快乐了四年，你是有了一个美好的青春，可你拿什么养活自己？你拿什么支撑自己的梦想？你忘了你的家庭情况了吗？ 没办法，生活就是这样，时间就那么多，我必须做出选择，必须懂得舍得。 “要好身材就得保持锻炼，要身体健康就要注意饮食，想多看书就得放弃其它时间。其它的也一样，要安逸就不要羡慕动荡，管不住嘴就得接受体重。其实无论过什么样的生活都要付出代价，或者是牺牲一些别的什么。没那么多两全其美的事，选择归根结底都是考验你是否能为了你所坚持的去背负那些代价。” 我强烈感觉我现在处在这样一种情况:我努力，我就能得到我想要的生活，它近在咫尺;我苟活，我只能碌碌无为，随遇而安。也许大学就是这样，你有无限可能，这也可能正是大学毕业后每个人的发展差距很大的原因。 我选择在这个时候朝着我的梦想前进，我选择为之付出大部分的精力，必要时我会全身心投入，我选择舍弃一些做其他事情的时间和精力。我问过自己的内心，实现梦想，才是我真正想要的。 可有时候，那些你忽略的东西也很重要，我现在也逐渐地意识到了。以前忽略它们，是因为太年轻，没有意识到。它们就是亲情，友情，人际关系，待人处世、团队合作、组织、表达的能力… 忽略它们给我带来了许多不好的后果，例如在做项目的时候，整天想的都是项目的事情，走路想，吃饭想，上课想，每天还一副忧心忡忡、严肃的样子，忽略了好多人好多事，忽略了人际交往。久而久之，人家就觉得你这个人是不是真的性格内向，不好相处，也就不跟你相处了(其实我老好相处了心塞(´-ωก`))。这样的事还有很多。 所以啊，我应该尽量平衡好学习和生活以及人际交往冲突的地方，再忙也不忘生活。这也是一种重要的能力。 迷茫到选择20岁，面临越来越多的选择，我内心很挣扎，仿佛20岁所做的每个决定，都会对未来产生重大影响。 20岁了，不能任性了，今后所做的任何事都要有所考虑，所做的任何选择都要慎重。因为过了20，我已经没有可以浪费的资本了。或许正是我觉得选择要慎重，我用了整整一年的时间想清楚我到底是读研、出国还是工作，用了一年时间去发现我今后到底要从事什么样的工作。选择初期，我内心很挣扎，因为我真的不清楚我选那条路好。有时候，看到什么心动的东西，或者前辈们的几句话，或者有感触的事就忽然做出选择，但过一段时间后，又开始怀疑这个选择，进而又回到了原点…有时挣扎到深处，甚至开始思考一些更”底层””的问题: 人生的意义是什么？我该活出什么样子？… 后来，我还是做出了选择，”Follow my heart”，接受我自己。 追随我的心，接受我自己。可能没有其他的路好，但我肯定不会后悔，还会因此感到快乐和安心。 烦恼总有一段时间感觉生活好没意思。每天起床，吃饭，没精打采的上课，下课，吃饭，上课，下课，回来敲代码…更重要的是，那个时候我什么都不想做，什么都不感兴趣。我有时候都羡慕室友，天天打游戏也不烦，还快快乐乐，至少能有一个爱好，找点乐子，消磨消磨时间。我有什么爱好啊？天呐，我都不知道我有什么爱好。或许正是因为我清心寡欲，没什么爱好，我才老是觉得生活没有什么意思，才老是思考人生的意义到底是什么。 总有一段时间，感到很孤独，莫名的孤独，突然的孤独。感觉自己没有一个知心的朋友，没有可以倾诉的人。我开始越来越喜欢听伤感的歌，听的时候一边伤感，一边疗伤，也算是发泄了。长大了，烦恼多了，却少了可以倾诉的人，自己也不想倾诉了。我觉得以前的我很开心，我没有烦恼，我喜欢的人和我的朋友都在身边，最重要的是，那时我擅长自娱。现在我好像变得多愁善感了，变得敏感了，变得沉默了。我身边好像少了一些东西，生活没有那么精彩丰富了。也许我睡一觉就不那么觉得了，但是我肯定还会感到孤独，在某个时候。这一年我在外面过得并不开心。 不过我还是想到了一些方法来消解郁闷，简单但有效果的方法就是跑步！ 我发现我跑步的时候，心里面很平静，再听着歌，内心就更加放松。我很喜欢晚上跑到筋疲力竭的时候，边听歌边走在跑道上，四周无人，尽情地放松我自己…这对我来说的确是一种非常有效果的发泄方式，每次跑完回来后，我的步伐就会变得更加坚定，内心照样如此。我想我会坚持下去的，因为我喜欢跑步时和跑步后的那种释放的感觉。跑步给我带来的不仅是身体上的健康，最重要的是让我的心态逐渐变得阳光，自信。 向往的生活哈哈，我向往有一天，我和我的家庭在欧洲或者美国的某个风景美丽的小镇定居了下来，我们有一个不大不小但温馨漂亮的房子，房子有一片绿地，还有菜园。我和我的爱人有两个可爱的孩子，一男一女，还有一只狗狗。我做着我喜欢的工作，我妻子专心地照顾家庭，孩子们接受着最好的教育。每天我们互道早安晚安，一起吃饭，每到周末，我们一起驾着车出去郊游，我们和孩子们还有狗狗尽情地玩耍…哈哈哈哈哈哈 先写这么多！晚安~","tags":[{"name":"感想","slug":"感想","permalink":"http://realtcg.com/tags/感想/"}]}]