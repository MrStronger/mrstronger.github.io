[{"title":"窥探React-源码分析(三)-全面剖析组件更新机制","date":"2018-04-17T08:16:33.000Z","path":"2018/04/17/窥探React-源码分析-三-update/","text":"React 把组件看作状态机(有限状态机), 使用state来控制本地状态, 使用props来传递状态. 前面我们探讨了 React 如何映射状态到 UI 上(初始渲染), 那么接下来我们谈谈 React 时如何同步状态到 UI 上的, 也就是: React 是如何更新组件的? React 是如何对比出页面变化最小的部分? 这篇文章会为你解答这些问题. 在这之前你已经了解了React (15-stable版本)内部的一些基本概念, 包括不同类型的组件实例、mount过程、事务、批量更新的大致过程(还没有? 不用担心, 为你准备好了从源码看组件初始渲染-%E8%B0%83%E7%94%A8ReactDOM.render%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/)、接着从源码看组件初始渲染-%E7%BB%84%E4%BB%B6%E7%9A%84%E5%88%9D%E5%A7%8B%E6%B8%B2%E6%9F%93/); 准备一个demo, 调试源码, 以便更好理解; Keep calm and make a big deal ! React 是如何更新组件的?TL;DR 依靠事务进行批量更新; 一次batch(批量)的生命周期就是从ReactDefaultBatchingStrategy事务perform之前(调用ReactUpdates.batchUpdates)到这个事务的最后一个close方法调用后结束; 事务启动后, 遇到 setState 则将 partial state 存到组件实例的_pendingStateQueue上, 然后将这个组件存到dirtyComponents 数组中, 等到 ReactDefaultBatchingStrategy事务结束时调用runBatchedUpdates批量更新所有组件; 组件的更新是递归的, 三种不同类型的组件都有自己的updateComponent方法来决定自己的组件如何更新, 其中 ReactDOMComponent 会采用diff算法对比子元素中最小的变化, 再批量处理. 这个更新过程像是一套流程, 无论你通过setState(或者replaceState)还是新的props去更新一个组件, 都会起作用. 那么具体是什么?让我们从这套更新流程的开始部分讲起… 调用 setState 之前首先, 开始一次batch的入口是在ReactDefaultBatchingStrategy里, 调用里面的batchedUpdates便可以开启一次batch: 123456789101112131415// 批处理策略var ReactDefaultBatchingStrategy = &#123; isBatchingUpdates: false, batchedUpdates: function(callback, a, b, c, d, e) &#123; var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates; ReactDefaultBatchingStrategy.isBatchingUpdates = true; // 开启一次batch if (alreadyBatchingUpdates) &#123; return callback(a, b, c, d, e); &#125; else &#123; // 启动事务, 将callback放进事务里执行 return transaction.perform(callback, null, a, b, c, d, e); &#125; &#125;,&#125;; 在 React 中, 调用batchedUpdates有很多地方, 与更新流程相关的如下 123456789101112131415161718// ReactMount.jsReactUpdates.batchedUpdates( batchedMountComponentIntoNode, // 负责初始渲染 componentInstance, container, shouldReuseMarkup, context,);// ReactEventListener.jsdispatchEvent: function(topLevelType, nativeEvent) &#123; ... try &#123; ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping); // 处理事件 &#125; finally &#123; TopLevelCallbackBookKeeping.release(bookKeeping); &#125;&#125;, 第一种情况, React 在首次渲染组件的时候会调用batchedUpdates, 然后开始渲染组件. 那么为什么要在这个时候启动一次batch呢? 不是因为要批量插入, 因为插入过程是递归的, 而是因为组件在渲染的过程中, 会依顺序调用各种生命周期函数, 开发者很可能在生命周期函数中(如componentWillMount或者componentDidMount)调用setState. 因此, 开启一次batch就是要存储更新(放入dirtyComponents), 然后在事务结束时批量更新. 这样以来, 在初始渲染流程中, 任何setState都会生效, 用户看到的始终是最新的状态. 第二种情况, 如果你在HTML元素上或者组件上绑定了事件, 那么你有可能在事件的监听函数中调用setState, 因此, 同样为了存储更新(放入dirtyComponents), 需要启动批量更新策略. 在回调函数被调用之前, React事件系统中的dispatchEvent函数负责事件的分发, 在dispatchEvent中启动了事务, 开启了一次batch, 随后调用了回调函数. 这样一来, 在事件的监听函数中调用的setState就会生效. 也就是说, 任何可能调用 setState 的地方, 在调用之前, React 都会启动批量更新策略以提前应对可能的setState 那么调用 batchedUpdates 后发生了什么?React 调用batchedUpdates时会传进去一个函数, batchedUpdates会启动ReactDefaultBatchingStrategyTransaction事务, 这个函数就会被放在事务里执行: 123456789// ReactDefaultBatchingStrategy.jsvar transaction = new ReactDefaultBatchingStrategyTransaction(); // 实例化事务var ReactDefaultBatchingStrategy = &#123; ... batchedUpdates: function(callback, a, b, c, d, e) &#123; ... return transaction.perform(callback, null, a, b, c, d, e); // 将callback放进事务里执行 ...&#125;; ReactDefaultBatchingStrategyTransaction这个事务控制了批量策略的生命周期: 123456789101112// ReactDefaultBatchingStrategy.jsvar FLUSH_BATCHED_UPDATES = &#123; initialize: emptyFunction, close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates), // 批量更新&#125;;var RESET_BATCHED_UPDATES = &#123; initialize: emptyFunction, close: function() &#123; ReactDefaultBatchingStrategy.isBatchingUpdates = false; // 结束本次batch &#125;,&#125;;var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES]; 无论你传进去的函数是什么, 无论这个函数后续会做什么, 都会在执行完后调用上面事务的close方法, 先调用flushBatchedUpdates批量更新, 再结束本次batch. 调用 setState 后发生了什么12345678910111213141516171819202122232425262728293031323334353637// ReactBaseClasses.js :ReactComponent.prototype.setState = function(partialState, callback) &#123; this.updater.enqueueSetState(this, partialState); if (callback) &#123; this.updater.enqueueCallback(this, callback, 'setState'); &#125;&#125;;// =&gt; ReactUpdateQueue.js:enqueueSetState: function(publicInstance, partialState) &#123; // 根据 this.setState 中的 this 拿到内部实例, 也就是组件实例 var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState'); // 取得组件实例的_pendingStateQueue var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []); // 将partial state存到_pendingStateQueue queue.push(partialState); // 调用enqueueUpdate enqueueUpdate(internalInstance); &#125;// =&gt; ReactUpdate.js:function enqueueUpdate(component) &#123; ensureInjected(); // 注入默认策略 // 如果没有开启batch(或当前batch已结束)就开启一次batch再执行, 这通常发生在异步回调中调用 setState // 的情况 if (!batchingStrategy.isBatchingUpdates) &#123; batchingStrategy.batchedUpdates(enqueueUpdate, component); return; &#125; // 如果batch已经开启就存储更新 dirtyComponents.push(component); if (component._updateBatchNumber == null) &#123; component._updateBatchNumber = updateBatchNumber + 1; &#125;&#125; 也就是说, 调用 setState 会首先拿到内部组件实例, 然后把要更新的partial state存到其_pendingStateQueue中, 然后标记当前组件为dirtyComponent, 存到dirtyComponents数组中. 然后就接着继续做下面的事情了, 并没有立即更新, 这是因为接下来要执行的代码里有可能还会调用 setState, 因此只做存储处理. 什么时候批量更新?首先, 一个事务在执行的时候(包括initialize、perform、close阶段), 任何一阶段都有可能调用一系列函数, 并且开启了另一些事务. 那么只有等后续开启的事务执行完, 之前开启的事务才继续执行. 下图是我们刚才所说的第一种情况, 在初始渲染组件期间 setState 后, React 启动的各种事务和执行的顺序: 从图中可以看到, 批量更新是在ReactDefaultBatchingStrategyTransaction事务的close阶段, 在flushBatchedUpdates函数中启动了ReactUpdatesFlushTransaction事务负责批量更新. 怎么批量更新的?开启批量更新事务、批量处理callback我们接着看flushBatchedUpdates函数, 在ReactUpdates.js中 123456789101112131415161718var flushBatchedUpdates = function () &#123; // 启动批量更新事务 while (dirtyComponents.length || asapEnqueued) &#123; if (dirtyComponents.length) &#123; var transaction = ReactUpdatesFlushTransaction.getPooled(); transaction.perform(runBatchedUpdates, null, transaction); ReactUpdatesFlushTransaction.release(transaction); &#125;// 批量处理callback if (asapEnqueued) &#123; asapEnqueued = false; var queue = asapCallbackQueue; asapCallbackQueue = CallbackQueue.getPooled(); queue.notifyAll(); CallbackQueue.release(queue); &#125; &#125;&#125;; 遍历dirtyComponentsflushBatchedUpdates启动了一个更新事务, 这个事务执行了runBatchedUpdates进行批量更新: 123456789101112131415161718192021222324252627282930313233// ReactUpdates.jsfunction runBatchedUpdates(transaction) &#123; var len = transaction.dirtyComponentsLength; // 排序保证父组件优先于子组件更新 dirtyComponents.sort(mountOrderComparator); // 代表批量更新的次数, 保证每个组件只更新一次 updateBatchNumber++; // 遍历 dirtyComponents for (var i = 0; i &lt; len; i++) &#123; var component = dirtyComponents[i]; var callbacks = component._pendingCallbacks; component._pendingCallbacks = null; ... // 执行更新 ReactReconciler.performUpdateIfNecessary( component, transaction.reconcileTransaction, updateBatchNumber, ); ... // 存储 callback以便后续按顺序调用 if (callbacks) &#123; for (var j = 0; j &lt; callbacks.length; j++) &#123; transaction.callbackQueue.enqueue( callbacks[j], component.getPublicInstance(), ); &#125; &#125; &#125;&#125; 前面 setState 后将组件推入了dirtyComponents, 现在就是要遍历dirtyComponents数组进行更新了. 根据不同情况执行更新ReactReconciler会调用组件实例的performUpdateIfNecessary. 如果接收了props, 就会调用此组件的receiveComponent, 再在里面调用updateComponent更新组件; 如果没有接受props, 但是有新的要更新的状态(_pendingStateQueue不为空)就会直接调用updateComponent来更新: 12345678910// ReactCompositeComponent.jsperformUpdateIfNecessary: function (transaction) &#123; if (this._pendingElement != null) &#123; ReactReconciler.receiveComponent(this, this._pendingElement, transaction, this._context); &#125; else if (this._pendingStateQueue !== null || this._pendingForceUpdate) &#123; this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context); &#125; else &#123; this._updateBatchNumber = null; &#125;&#125; 调用组件实例的updateComponent接下里就是重头戏updateComponent了, 它决定了组件如果更新自己和它的后代们. 需要特别注意的是, React 内部三种不同的组件类型, 每种组件都有自己的updateComponent, 有不同的行为. 对于 ReactCompositeComponent (矢量图): updateComponent所做的事情 : 调用此层级组件的一系列生命周期函数, 并且在合适的时机更新props、state、context; re-render, 与之前 render 的 element 比较, 如果两者key &amp;&amp; element.type 相等, 则进入下一层进行更新; 如果不等, 直接移除重新mount 对于 ReactDOMComponent: updateComponent所做的事情 : 更新这一层级DOM元素属性; 更新子元素, 调用 ReactMultiChild 的 updateChildren, 对比前后变化、标记变化类型、存到updates中(diff算法主要部分); 批量处理updates 对于 ReactDOMTextComponent : 上面只是每个组件自己更新的过程, 那么 React 是如何一次性更新所有组件的 ? 答案是递归. 递归调用组件的updateComponent观察 ReactCompositeComponent 和 ReactDOMComponent 的更新流程, 我们发现 React 每次走到一个组件更新过程的最后部分, 都会有一个判断 : 如果 nextELement 和 prevElement key 和 type 相等, 就会调用receiveComponent. receiveComponent和updateComponent一样, 每种组件都有一个, 作用就相当于updateComponent 接受了新 props 的版本. 而这里调用的就是子元素的receiveComponent, 进而进行子元素的更新, 于是就形成了递归更新、递归diff. 因此, 整个流程就像这样(矢量图) : 这种更新完一级、diff完一级再进入下一级的过程保证 React 只遍历一次组件树就能完成更新, 但代价就是只要前后 render 出元素的 type 和 key 有一个不同就删除重造, 因此, React 建议页面要尽量保持稳定的结构. React 是如何对比出页面变化最小的部分?你可能会说 React 用 virtual DOM 表示了页面结构, 每次更新, React 都会re-render出新的 virtual DOM, 再通过 diff 算法对比出前后变化, 最后批量更新. 没错, 很好, 这就是大致过程, 但这里存在着一些隐藏的深层问题值得探讨 : React 是如何用 virtual DOM 表示了页面结构, 从而使任何页面变化都能被 diff 出来? React 是如何 diff 出页面变化最小的部分? React 如何表示页面结构123456789101112131415161718192021222324252627282930class C extends React.Component &#123; render () &#123; return ( &lt;div className='container'&gt; \"dscsdcsd\" &lt;i onClick=&#123;(e) =&gt; console.log(e)&#125;&gt;&#123;this.state.val&#125;&lt;/i&gt; &lt;Children val=&#123;this.state.val&#125;/&gt; &lt;/div&gt; ) &#125;&#125;// virtual DOM(React element)&#123; $$typeof: Symbol(react.element) key: null props: &#123; // props 代表元素上的所有属性, 有children属性, 描述子组件, 同样是元素 children: [ \"\"dscsdcsd\"\", &#123;$$typeof: Symbol(react.element), type: \"i\", key: null, ref: null, props: &#123;…&#125;, …&#125;, &#123;$$typeof: Symbol(react.element), type: class Children, props: &#123;…&#125;, …&#125; ] className: 'container' &#125; ref: null type: \"div\" _owner: ReactCompositeComponentWrapper &#123;...&#125; // class C 实例化后的对象 _store: &#123;validated: false&#125; _self: null _source: null&#125; 每个标签, 无论是DOM元素还是自定义组件, 都会有 key、type、props、ref 等属性. key 代表元素唯一id值, 意味着只要id改变, 就算前后元素种类相同, 元素也肯定不一样了; type 代表元素种类, 有 function(空的wrapper)、class(自定义类)、string(具体的DOM元素名称)类型, 与key一样, 只要改变, 元素肯定不一样; props 是元素的属性, 任何写在标签上的属性(如className=’container’)都会被存在这里, 如果这个元素有子元素(包括文本内容), props就会有children属性, 存储子元素; children属性是递归插入、递归更新的依据; 也就是说, 如果元素唯一标识符或者类别或者属性有变化, 那么它们re-render后对应的 key、type 和props里面的属性也会改变, 前后一对比即可找出变化. 综上来看, React 这么表示页面结构确实能够反映前后所有变化. 那么 React 是如何 diff 的?React diff 每次只对同一层级的节点进行比对 : 上图的数字表示遍历更新的次序. 从父节点开始, 每一层 diff 包括两个地方 element diff—— 前后 render 出来的 element 的对比, 这个对比是为了找出前后节点是不是同一节点, 会对比前后render出来的元素它们的 key 和 type. element diff 包括两个地方, 组件顶层DOM元素对比和子元素的对比: 组件顶层DOM元素对比 : 123456789101112131415161718// ReactCompositeComponent.js/updateComponent =&gt; _updateRenderedComponent_updateRenderedComponent: function(transaction, context) &#123; // re-render 出element var nextRenderedElement = this._renderValidatedComponent(); // 对比前后变化 if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) &#123; // 如果 key &amp;&amp; type 没变进行下一级更新 ReactReconciler.receiveComponent(...); &#125; else &#123; // 如果变了移除重造 ReactReconciler.unmountComponent(prevComponentInstance, false); ... var child = this._instantiateReactComponent(...); var nextMarkup = ReactReconciler.mountComponent(...); this._replaceNodeWithMarkup(...); &#125;&#125; 子元素的对比: 12345678910111213141516171819202122232425262728293031323334353637// ReactChildReconciler.jsupdateChildren: function(...) &#123; ... for (name in nextChildren) &#123; // 遍历 re-render 出的elements ... if ( prevChild != null &amp;&amp; shouldUpdateReactComponent(prevElement, nextElement) ) &#123; // 如果key &amp;&amp; type 没变进行下一级更新 ReactReconciler.receiveComponent(...); nextChildren[name] = prevChild; // 更新完放入 nextChildren, 注意放入的是组件实例 &#125; else &#123; // 如果变了则移除重建 if (prevChild) &#123; removedNodes[name] = ReactReconciler.getHostNode(prevChild); ReactReconciler.unmountComponent(prevChild, false); &#125; var nextChildInstance = instantiateReactComponent(nextElement, true); nextChildren[name] = nextChildInstance; var nextChildMountImage = ReactReconciler.mountComponent(...); mountImages.push(nextChildMountImage); &#125; &#125; // 再除掉 prevChildren 里有, nextChildren 里没有的组件 for (name in prevChildren) &#123; if ( prevChildren.hasOwnProperty(name) &amp;&amp; !(nextChildren &amp;&amp; nextChildren.hasOwnProperty(name)) ) &#123; prevChild = prevChildren[name]; removedNodes[name] = ReactReconciler.getHostNode(prevChild); ReactReconciler.unmountComponent(prevChild, false); &#125; &#125; &#125;, shouldComponentUpdate 函数: 12345678910111213141516171819202122function shouldUpdateReactComponent(prevElement, nextElement) &#123; var prevEmpty = prevElement === null || prevElement === false; var nextEmpty = nextElement === null || nextElement === false; if (prevEmpty || nextEmpty) &#123; return prevEmpty === nextEmpty; &#125; var prevType = typeof prevElement; var nextType = typeof nextElement; // 如果前后变化都是字符串、数字类型的则允许更新 if (prevType === 'string' || prevType === 'number') &#123; return nextType === 'string' || nextType === 'number'; &#125; else &#123; // 否则检查 type &amp;&amp; key return ( nextType === 'object' &amp;&amp; prevElement.type === nextElement.type &amp;&amp; prevElement.key === nextElement.key ); &#125;&#125; element diff 检测 type &amp;&amp; key 都没变时会进入下一级更新, 如果变化则直接移除重造新元素, 然后遍历同级的下一个. subtree diff ——组件顶层DOM元素包裹的所有子元素(也就是props.children里的元素)与之前版本的对比, 这个对比是为了找出同级所有子节点的变化, 包括移除、新建、同级范围的移动; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// ReactMultiChild.js_updateChildren: function(...) &#123; var prevChildren = this._renderedChildren; var removedNodes = &#123;&#125;; var mountImages = []; // 拿到更新后子组件实例 var nextChildren = this._reconcilerUpdateChildren(); ... // 遍历子组件实例 for (name in nextChildren) &#123; ... var prevChild = prevChildren &amp;&amp; prevChildren[name]; var nextChild = nextChildren[name]; // 因为子组件的更新是在原组件实例上更改的, 因此与之前的组件作引用比较即可判断 if (prevChild === nextChild) &#123; // 发生了移动 updates = enqueue( updates, this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex), ); lastIndex = Math.max(prevChild._mountIndex, lastIndex); prevChild._mountIndex = nextIndex; &#125; else &#123; ... // 有新的组件 updates = enqueue( updates, this._mountChildAtIndex( nextChild, mountImages[nextMountIndex], lastPlacedNode, nextIndex, transaction, context, ), ); nextMountIndex++; &#125; nextIndex++; lastPlacedNode = ReactReconciler.getHostNode(nextChild); &#125; // Remove children that are no longer present. for (name in removedNodes) &#123; // removedNodes 记录了所有的移除节点 if (removedNodes.hasOwnProperty(name)) &#123; updates = enqueue( updates, this._unmountChild(prevChildren[name], removedNodes[name]), ); &#125; &#125; if (updates) &#123; processQueue(this, updates); // 批量处理 &#125; this._renderedChildren = nextChildren; &#125;, React 会将同一层级的变化标记, 如 MOVE_EXISTING、REMOVE_NODE、TEXT_CONTENT、INSERT_MARKUP 等, 统一放到 updates 数组中然后批量处理. And that‘s it !React 是一个激动人心的库, 它给我们带来了前所未有的开发体验, 但当我们沉浸在使用 React 快速实现需求的喜悦中时, 有必要去探究两个问题 : Why and How? 为什么 React 会如此流行, 原因是什么? 组件化、快速、足够简单、all in js、容易扩展、生态丰富、社区强大… React 反映了哪些思想/理念/思路 ? 状态机、webComponents、virtual DOM、virtual stack、异步渲染、多端渲染、单向数据流、反应式更新、函数式编程… React 这些理念/思路受什么启发 ? 怎么想到的 ? 又怎么实现的? …","tags":[{"name":"React","slug":"React","permalink":"http://realtcg.com/tags/React/"},{"name":"源码分析","slug":"源码分析","permalink":"http://realtcg.com/tags/源码分析/"}]},{"title":"窥探React-源码分析(二)-组件的初始渲染","date":"2018-03-17T10:21:34.000Z","path":"2018/03/17/窥探React-源码分析(二)-initial render/","text":"上一篇文章讲到了React 调用ReactDOM.render首次渲染组件的前几个过程的源码, 包括创建元素、根据元素实例化对应组件, 利用事务来进行批量更新. 我们还穿插介绍了React 事务的实现以及如何利用事务进行批量更新的实现. 这篇文章我们接着分析后面的过程, 包括调用了哪些事务, 组件插入的过程, 组件生命周期方法什么时候被调用等. 正文在React 源码中, 首次渲染组件有一个重要的过程, mount, 插入, 即插入到DOM中, 发生在实例化组件之后. 这是一个不断生成(render)不断插入、类似递归的过程. 让我们一步一步来分析. 使用事务执行插入过程我们来看首先在插入之前的准备, ReactMount.js中, batchedMountComponentIntoNode被放到了批量策略batchedUpdates中执行, batchedMountComponentIntoNode 函数正是执行插入过程的第一步 123456// 放在批量策略batchedUpdates中执行插入ReactUpdates.batchedUpdates( batchedMountComponentIntoNode, componentInstance, ...); 这个batchingStrategy就是ReactDefaultBatchingStrategy, 因此调用了ReactDefaultBatchingStrategy的batchedUpdates, 并将batchedMountComponentIntoNode当作callback. 在ReactDefaultBatchingStrategy.js中启动了ReactDefaultBatchingStrategyTransaction事务去执行batchedMountComponentIntoNode, 以便利用策略控制更新, 而在这个函数中又启动了一个调和(Reconcile)事务, 执行mountComponentIntoNode进行插入. 1234567891011121314151617181920212223242526// ReactDefaultBatchingStrategy.jsvar transaction = new ReactDefaultBatchingStrategyTransaction();...var ReactDefaultBatchingStrategy = &#123; ... batchedUpdates: function(callback, a, b, c, d, e) &#123; ... // 启动ReactDefaultBatchingStrategy事务 return transaction.perform(callback, null, a, b, c, d, e); &#125;,&#125;;// ReactMount.jsfunction batchedMountComponentIntoNode( ...) &#123; var transaction = ReactUpdates.ReactReconcileTransaction.getPooled( !shouldReuseMarkup &amp;&amp; ReactDOMFeatureFlags.useCreateElement, ); // 启动Reconcile事务 transaction.perform( mountComponentIntoNode, ... ); ...&#125; 相信你注意到了 ReactUpdates.ReactReconcileTransaction.getPooled, 这个函数的作用就是从对象池里拿到ReactReconcileTransaction 对象重用. React优化策略——对象池在ReactMount.js : 1234567891011121314151617181920212223function batchedMountComponentIntoNode( componentInstance, container, shouldReuseMarkup, context,) &#123; // 从对象池中拿到ReactReconcileTransaction事务 var transaction = ReactUpdates.ReactReconcileTransaction.getPooled( !shouldReuseMarkup &amp;&amp; ReactDOMFeatureFlags.useCreateElement, ); // 启动事务执行mountComponentIntoNode transaction.perform( mountComponentIntoNode, null, componentInstance, container, transaction, shouldReuseMarkup, context, ); // 释放事务 ReactUpdates.ReactReconcileTransaction.release(transaction);&#125; React 在启动另一个事务之前拿到了这个事务, 从哪里拿到的呢? 这里就涉及到了React 优化策略之一——对象池 GC很慢首先你用JavaScript声明的变量不再使用时, js引擎会在某些时间回收它们, 这个回收时间是耗时的. 资料显示: Marking latency depends on the number of live objects that have to be marked, with marking of the whole heap potentially taking more than 100 ms for large webpages. 整个堆的标记对于大型网页很可能需要超过100毫秒 尽管V8引擎对垃圾回收有优化, 但为了避免重复创建临时对象造成GC不断启动以及复用对象, React使用了对象池来复用对象, 对GC表明, 我一直在使用它们, 请不要启动回收. React 实现的对象池其实就是对类进行了包装, 给类添加一个实例队列, 用时取, 不用时再放回, 防止重复实例化: PooledClass.js : 12345678910111213141516171819202122232425262728293031323334353637383940414243// 添加对象池, 实质就是对类包装var addPoolingTo = function (CopyConstructor, pooler) &#123; // 拿到类 var NewKlass = CopyConstructor; // 添加实例队列属性 NewKlass.instancePool = []; // 添加拿到实例方法 NewKlass.getPooled = pooler || DEFAULT_POOLER; // 实例队列默认为10个 if (!NewKlass.poolSize) &#123; NewKlass.poolSize = DEFAULT_POOL_SIZE; &#125; // 将实例放回队列 NewKlass.release = standardReleaser; return NewKlass;&#125;;// 从对象池申请一个实例.对于不同参数数量的类,React分别处理, 这里是一个参数的类的申请实例的方法, 其他一样var oneArgumentPooler = function(copyFieldsFrom) &#123; // this 指的就是传进来的类 var Klass = this; // 如果类的实例队列有实例, 则拿出来一个 if (Klass.instancePool.length) &#123; var instance = Klass.instancePool.pop(); Klass.call(instance, copyFieldsFrom); return instance; &#125; else &#123; // 否则说明是第一次实例化, new 一个 return new Klass(copyFieldsFrom); &#125;&#125;;// 释放实例到类的队列中var standardReleaser = function(instance) &#123; var Klass = this; ... // 调用类的解构函数 instance.destructor(); // 放到队列 if (Klass.instancePool.length &lt; Klass.poolSize) &#123; Klass.instancePool.push(instance); &#125;&#125;;// 使用时将类传进去即可PooledClass.addPoolingTo(ReactReconcileTransaction); 可以看到, React对象池就是给类维护一个实例队列, 用到就pop一个, 不用就push回去. 在React源码中, 用完实例后要立即释放, 也就是申请和释放成对出现, 达到优化性能的目的. 插入过程在ReactMount.js中, mountComponentIntoNode函数执行了组件实例的mountComponent, 不同的组件实例有自己的mountComponent方法, 做的也是不同的事情. (源码我就不上了, 太TM…) ReactCompositeComponent类型的mountComponent方法: ReactDOMComponent类型: ReactDOMTextComponent类型: 整个mount过程是递归渲染的(矢量图): 刚开始, React给要渲染的组件从最顶层加了一个ReactCompositeComponent类型的 topLevelWrapper来方便的存储所有更新, 因此初次递归是从 ReactCompositeComponent 的mountComponent 开始的, 这个过程会调用组件的render函数(如果有的话), 根据render出来的elements再调用instantiateReactComponent实例化不同类型的组件, 再调用组件的 mountComponent, 因此这是一个不断渲染不断插入、递归的过程. 总结React 初始渲染主要分为以下几个步骤: 构建一个组件的elements tree(subtree)—— 从组件嵌套的最里层(转换JSX后最里层的createElements函数)开始层层调用createElements创建这个组件elements tree. 在这个subtree中, 里层创建出来的元素作为包裹层的props.children; 实例化组件——根据当前元素的类型创建对应类型的组件实例; 利用多种事务执行组件实例的mountComponent. 首先执行topLevelWrapper(ReactCompositeComponent)的mountComponent; ReactCompositeComponent的mountComponent过程中会先调用render(Composite类型 )生成组件的elements tree, 然后顺着props.children, 不断实例化, 不断调用各自组件的mountComponent 形成循环 在以上过程中, 依靠事务进行存储更新、回调队列, 在事务结束时批量更新.","tags":[{"name":"React","slug":"React","permalink":"http://realtcg.com/tags/React/"},{"name":"源码分析","slug":"源码分析","permalink":"http://realtcg.com/tags/源码分析/"}]},{"title":"窥探React-源码分析(一)-调用ReactDOM.render后发生了什么","date":"2018-02-11T13:23:41.000Z","path":"2018/02/11/窥探React-源码分析(一)-after ReactDOM.render/","text":"所谓知其然还要知其所以然. 本系列文章将分析 React 15-stable的部分源码, 包括组件初始渲染的过程、组件更新的过程等. 这篇文章先介绍组件初始渲染的过程的几个重要概念, 包括大致过程、创建元素、实例化组件、事务、批量更新策略等. 在这之前, 假设读者已经: 对React有一定了解 知道React element、component、class区别 了解生命周期、事务、批量更新、virtual DOM大致概念等 如何分析 React 源码代码架构预览 首先, 我们找到React在Github上的地址, 把15-stable版本的源码copy下来, 观察它的整体架构, 这里首先阅读关于源码介绍的官方文档, 再接着看. 我们 要分析的源码在 src 目录下: 12345678910// src 部分目录├── ReactVersion.js # React版本号├── addons # 插件├── isomorphic # 同构代码,作为react-core, 提供顶级API├── node_modules├── package.json├── renderers # 渲染器, 包括DOM,Native,art,test等├── shared # 子目录之间需要共享的代码,提到父级目录shared├── test # 测试代码 分析方法 1、首先看一些网上分析的文章, 对重点部分的源码有个印象, 知道一些关键词意思, 避免在无关的代码上迷惑、耗费时间; 2、准备一个demo, 无任何功能代码, 只安装react,react-dom, Babel转义包, 避免分析无关代码; 3、打debugger; 利用Chrome devtool一步一步走, 打断点, 看调用栈,看函数返回值, 看作用域变量值; 4、利用编辑器查找代码、阅读代码等 正文我们知道, 对于一般的React 应用, 浏览器会首先执行代码 ReactDOM.render来渲染顶层组件, 在这个过程中递归渲染嵌套的子组件, 最终所有组件被插入到DOM中. 我们来看看 调用ReactDOM.render 发生了什么大致过程(只展示主要的函数调用): 如果看不清这有矢量图 让我们来分析一下具体过程: 1、创建元素首先, 对于你写的jsx, Babel会把这种语法糖转义成这样: 1234567891011// jsxReactDOM.render( &lt;C /&gt;, document.getElementById('app'))// 转义后ReactDOM.render( React.createElement(C, null), document.getElementById('app')); 没错, 就是调用React.createElement来创建元素. 元素是什么? 元素只是一个对象描述了DOM树, 它像这样: 1234567891011&#123; $$typeof: Symbol(react.element) key: null props: &#123;&#125; // props有child属性, 描述子组件, 同样是元素 ref: null type: class C // type可以是类(自定义组件)、函数(wrapper)、string(DOM节点) _owner: null _store: &#123;validated: false&#125; _self: null _source: null&#125; React.createElement源码在ReactElement.js中, 其他逻辑比较简单, 值得说的是props属性, 这个props属性里面包含的就是我们给组件传的各种属性: 1234567891011121314151617181920212223242526272829303132333435363738// jsxreturn ( &lt;div className='container'&gt; \"dscsdcsd\" &lt;i onClick=&#123;(e) =&gt; console.log(e)&#125;&gt;&#123;this.state.val&#125;&lt;/i&gt; &lt;Children val=&#123;this.state.val&#125;/&gt; &lt;/div&gt;)// bable 转义后// createElement(type, props, children)return React.createElement( 'div', &#123; className: 'container' &#125;, '\"dscsdcsd\"', React.createElement('i', &#123; onClick: e =&gt; console.log(e) &#125;, this.state.val), React.createElement(Children, &#123; val: this.state.val &#125;));// 对应的元素树&#123; $$typeof: Symbol(react.element) key: null props: &#123; // props有children属性, 描述子组件, 同样是元素 children: [ \"\"dscsdcsd\"\", // 子元素 &#123;$$typeof: Symbol(react.element), type: \"i\", key: null, ref: null, props: &#123;…&#125;, …&#125;, &#123;$$typeof: Symbol(react.element), type: class Children, props: &#123;…&#125;, …&#125; ] className: 'container' &#125; ref: null type: 'div' _owner: null _store: &#123;validated: false&#125; _self: null _source: null&#125; 2、创建对应类型的React组件创建出来的元素被当作参数和指定的 DOM container 一起传进ReactDOM.render. 接下来会调用一些内部方法, 接着调用了 instantiateReactComponent, 这个函数根据element的类型实例化对应的component. 当element的类型为: string时, 说明是文本, 创建ReactDOMTextComponent; ReactElement时, 说明是react元素, 进一步判断element.type的类型, 当为 string时, 为DOM原生节点, 创建ReactDOMComponent; 函数或类时, 为react 组件, 创建ReactCompositeComponent instantiateReactComponent函数在instantiateReactComponent.js : 1234567891011121314151617181920212223242526272829303132/** * Given a ReactNode, create an instance that will actually be mounted. */function instantiateReactComponent(node(这里node指element), shouldHaveDebugID) &#123; ... // 如果element为空 if (node === null || node === false) &#123; // 创建空component instance = ReactEmptyComponent.create(instantiateReactComponent); &#125; else if (typeof node === 'object') &#123; // 如果是对象 ... // 这里是类型检查 // 如果element.type是字符串 if (typeof element.type === 'string') &#123; //实例化 宿主组件, 也就是DOM节点 instance = ReactHostComponent.createInternalComponent(element); &#125; else if (isInternalComponentType(element.type)) &#123; // 保留给以后版本使用，此处暂时不会涉及到 &#125; else &#123; // 否则就实例化ReactCompositeComponent instance = new ReactCompositeComponentWrapper(element); &#125; // 如果element是string或number &#125; else if (typeof node === 'string' || typeof node === 'number') &#123; // 实例化ReactDOMTextComponent instance = ReactHostComponent.createInstanceForText(node); &#125; else &#123; invariant(false, 'Encountered invalid React node of type %s', typeof node); &#125; ... return instance;&#125; 3、开启批量更新以应对可能的setState在调用instantiateReactComponent拿到组件实例后, React 接着调用了batchingStrategy.batchedUpdates并将组件实例当作参数执行批量更新(首次渲染为批量插入). 批量更新是一种优化策略, 避免重复渲染, 在很多框架都存在这种机制. 其实现要点是要弄清楚何时存储更新, 何时批量更新. 在React中, 批量更新受batchingStrategy控制,而这个策略除了server端都是ReactDefaultBatchingStrategy: 不信你看, 在ReactUpdates.js中 : 123456789var ReactUpdatesInjection = &#123; ... // 注入批量策略的函数声明 injectBatchingStrategy: function(_batchingStrategy) &#123; ... batchingStrategy = _batchingStrategy; &#125;,&#125;; 在ReactDefaultInjection.js中注入ReactDefaultBatchingStrategy : 1ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy); // 注入 那么React是如何实现批量更新的? 在ReactDefaultBatchingStrategy.js我们看到, 它的实现依靠了事务. 3.1 我们先介绍一下事务.在 Transaction.js中, React 介绍了事务: 123456789101112131415161718192021222324* &lt;pre&gt; * wrappers (injected at creation time) * + + * | | * +-----------------|--------|--------------+ * | v | | * | +---------------+ | | * | +--| wrapper1 |---|----+ | * | | +---------------+ v | | * | | +-------------+ | | * | | +----| wrapper2 |--------+ | * | | | +-------------+ | | | * | | | | | | * | v v v v | wrapper * | +---+ +---+ +---------+ +---+ +---+ | invariants * perform(anyMethod) | | | | | | | | | | | | maintained * +-----------------&gt;|-|---|-|---|--&gt;|anyMethod|---|---|-|---|-|--------&gt; * | | | | | | | | | | | | * | | | | | | | | | | | | * | | | | | | | | | | | | * | +---+ +---+ +---------+ +---+ +---+ | * | initialize close | * +-----------------------------------------+ * &lt;/pre&gt; React 把要调用的函数封装一层wrapper, 这个wrapper一般是一个对象, 里面有initialize方法, 在调用函数前调用;有close方法, 在函数执行后调用. 这样封装的目的是为了, 在要调用的函数执行前后某些不变性约束条件(invariant)仍然成立. 这里的不变性约束条件(invariant), 我把它理解为 “真命题”, 因此前面那句话意思就是, 函数调用前后某些规则仍然成立. 比如, 在调和(reconciliation)前后保留UI组件一些状态. React 中, 事务就像一个黑盒, 函数在这个黑盒里被执行, 执行前后某些规则仍然成立, 即使函数报错. 事务提供了函数执行的一个安全环境. 继续看Transaction.js对事务的抽象实现: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// 事务的抽象实现, 作为基类var TransactionImpl = &#123; // 初始化/重置实例属性, 给实例添加/重置几个属性, 实例化事务时会调用 reinitializeTransaction: function () &#123; this.transactionWrappers = this.getTransactionWrappers(); if (this.wrapperInitData) &#123; this.wrapperInitData.length = 0; &#125; else &#123; this.wrapperInitData = []; &#125; this._isInTransaction = false; &#125;, _isInTransaction: false, // 这个函数会交给具体的事务实例化时定义, 初始设为null getTransactionWrappers: null, // 判断是否已经在这个事务中, 保证当前的Transaction正在perform的同时不会再次被perform isInTransaction: function () &#123; return !!this._isInTransaction; &#125;, // 顶级API, 事务的主要实现, 用来在安全的窗口下执行函数 perform: function (method, scope, a, b, c, d, e, f) &#123; var ret; var errorThrown; try &#123; this._isInTransaction = true; errorThrown = true; this.initializeAll(0); // 调用所有wrapper的initialize方法 ret = method.call(scope, a, b, c, d, e, f); // 调用要执行的函数 errorThrown = false; &#125; finally &#123; // 调用所有wrapper的close方法, 利用errorThrown标志位保证只捕获函数执行时的错误, 对initialize // 和close抛出的错误不做处理 try &#123; if (errorThrown) &#123; try &#123; this.closeAll(0); &#125; catch (err) &#123;&#125; &#125; else &#123; this.closeAll(0); &#125; &#125; finally &#123; this._isInTransaction = false; &#125; &#125; return ret; &#125;, // 调用所有wrapper的initialize方法的函数定义 initializeAll: function (startIndex) &#123; var transactionWrappers = this.transactionWrappers; // 得到wrapper // 遍历依次调用 for (var i = startIndex; i &lt; transactionWrappers.length; i++) &#123; var wrapper = transactionWrappers[i]; try &#123; ... this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this):null; &#125; finally &#123; if (this.wrapperInitData[i] === OBSERVED_ERROR) &#123; try &#123; this.initializeAll(i + 1); &#125; catch (err) &#123;&#125; &#125; &#125; &#125; &#125;, // 调用所有wrapper的close方法的函数定义 closeAll: function (startIndex) &#123; ... var transactionWrappers = this.transactionWrappers; // 拿到wrapper // 遍历依次调用 for (var i = startIndex; i &lt; transactionWrappers.length; i++) &#123; var wrapper = transactionWrappers[i]; var initData = this.wrapperInitData[i]; var errorThrown; try &#123; ... if (initData !== OBSERVED_ERROR &amp;&amp; wrapper.close) &#123; wrapper.close.call(this, initData); &#125; errorThrown = false; &#125; finally &#123; if (errorThrown) &#123; ... try &#123; this.closeAll(i + 1); &#125; catch (e) &#123;&#125; &#125; &#125; &#125; this.wrapperInitData.length = 0; &#125;&#125;; 这只是React事务的抽象实现(基类), 还需要实例化事务并对其加强的配合, 才能发挥事务的真正作用. 另外, 在React 中, 一个事务里开启另一个事务很普遍, 这说明事务是有粒度大小的, 就像进程和线程一样. 3.2 批量更新依靠了事务刚讲到, 在React中, 批量更新受batchingStrategy控制,而这个策略除了server端都是ReactDefaultBatchingStrategy, 而在ReactDefaultBatchingStrategy.js中, 批量更新的实现依靠了事务: ReactDefaultBatchingStrategy.js : 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051...var Transaction = require('Transaction');// 引入事务...var RESET_BATCHED_UPDATES = &#123; // 重置的 wrapper initialize: emptyFunction, close: function() &#123; ReactDefaultBatchingStrategy.isBatchingUpdates = false; // 事务结束即一次batch结束 &#125;,&#125;;var FLUSH_BATCHED_UPDATES = &#123; // 批处理的 wrapper initialize: emptyFunction, close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates),&#125;;// 组合成 ReactDefaultBatchingStrategyTransaction 事务的wrappervar TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES]; // 调用 reinitializeTransaction 初始化function ReactDefaultBatchingStrategyTransaction() &#123; this.reinitializeTransaction();&#125;// 参数中依赖了事务Object.assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, &#123; getTransactionWrappers: function() &#123; return TRANSACTION_WRAPPERS; &#125;,&#125;);var transaction = new ReactDefaultBatchingStrategyTransaction(); // 实例化这类事务// 批处理策略var ReactDefaultBatchingStrategy = &#123; isBatchingUpdates: false, // 是否处在一次BatchingUpdates标志位 // 批量更新策略调用的就是这个方法 batchedUpdates: function(callback, a, b, c, d, e) &#123; var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates; // 一旦调用批处理, 重置isBatchingUpdates标志位, 表示正处在一次BatchingUpdates中 ReactDefaultBatchingStrategy.isBatchingUpdates = true; // 避免重复分配事务 if (alreadyBatchingUpdates) &#123; return callback(a, b, c, d, e); &#125; else &#123; return transaction.perform(callback, null, a, b, c, d, e); // 将callback放进事务里执行 &#125; &#125;,&#125;; 那么, 为什么批量更新的实现依靠了事务呢? 还记得实现批量更新的两个要点吗? 何时存储更新 何时批处理 对于这两个问题, React 在执行事务时调用wrappers的initialize方法, 建立更新队列, 然后执行函数, 接着 : 何时存储更新—— 在执行函数时遇到更新请求就存到这个队列中 何时批处理—— 函数执行后调用wrappers的close方法, 在close方法中调用批量处理函数 口说无凭, 得有证据. 我们拿ReactDOM.render会调用的事务ReactReconcileTransaction来看看是不是这样: ReactReconcileTransaction.js 里有个wrapper, 它是这样定义的(英文是官方注释) : 123456789101112131415var ON_DOM_READY_QUEUEING = &#123; /** * Initializes the internal `onDOMReady` queue. */ initialize: function() &#123; this.reactMountReady.reset(); &#125;, /** * After DOM is flushed, invoke all registered `onDOMReady` callbacks. */ close: function() &#123; this.reactMountReady.notifyAll(); &#125;,&#125;; 我们再看ReactReconcileTransaction事务会执行的函数mountComponent, 它在 ReactCompositeComponent.js : 123456789101112131415161718192021222324252627/* * Initializes the component, renders markup, and registers event listeners.*/ mountComponent: function( transaction, hostParent, hostContainerInfo, context, ) &#123; ... if (inst.componentDidMount) &#123; if (__DEV__) &#123; transaction.getReactMountReady().enqueue(() =&gt; &#123; // 将要调用的callback存起来 measureLifeCyclePerf( () =&gt; inst.componentDidMount(), this._debugID, 'componentDidMount', ); &#125;); &#125; else &#123; transaction.getReactMountReady().enqueue(inst.componentDidMount, inst); &#125; &#125; ... &#125; 而上述wrapper定义的close方法调用的this.reactMountReady.notifyAll()在这 CallbackQueue.js : 1234567891011121314/** * Invokes all enqueued callbacks and clears the queue. This is invoked after * the DOM representation of a component has been created or updated. */ notifyAll() &#123; ... // 遍历调用存储的callback for (var i = 0; i &lt; callbacks.length; i++) &#123; callbacks[i].call(contexts[i], arg); &#125; callbacks.length = 0; contexts.length = 0; &#125; &#125; 即证. 你竟然读到这了好累(笑哭), 先写到这吧. 我本来还想一篇文章就把组件初始渲染的过程和组件更新的过程讲完, 现在看来要分开讲了… React 细节太多了, 蕴含的信息量也很大…说博大精深一点不夸张…向React的作者们以及社区的人们致敬! 我觉得读源码是一件很费力但是非常值得的事情. 刚开始读的时候一点头绪也没有, 不知道它是什么样的过程, 不知道为什么要这么写, 有时候还会因为断点没打好绕了很多弯路…也是硬着头皮一遍一遍看, 结合网上的文章, 就这样云里雾里的慢慢摸索, 不断更正自己的认知.后来看多了, 就经常会有大彻大悟的感觉, 零碎的认知开始连通起来, 逐渐摸清了来龙去脉. 现在觉得确实很值得, 自己学到了不少. 看源码的过程就感觉是跟作者们交流讨论一样, 思想在碰撞! 强烈推荐前端的同学们阅读React源码, 大神们智慧的结晶! 未完待续…","tags":[{"name":"React","slug":"React","permalink":"http://realtcg.com/tags/React/"},{"name":"源码分析","slug":"源码分析","permalink":"http://realtcg.com/tags/源码分析/"}]},{"title":"认识node核心模块--网络编程","date":"2017-11-21T12:23:02.000Z","path":"2017/11/21/认识node核心模块-网络编程/","text":"在构建网络通信服务方面，相比于其他老牌后端语言，Node.js 同样能够胜任(也许更胜一筹)，并且有自己独特的处理方式。node是一个面向网络而生的平台，它的事件驱动、非阻塞、单线程使node应用程序具有低内存、高并发、伸缩性强的优良特性，适合在分布式网络大展身手。Node底层实现了传输层TCP/UDP、应用层HTTP/HTTPS的功能并封装成贴合网络的API，并且可以自己创建服务器而不依赖三方服务，使用起来非常方便、简单、灵活。对于网络编程，node提供了net、dgram、http、https 4个模块，分别用于处理TCP、UDP、HTTP、HTTPS。本文将介绍这些模块并利用这些模块提供的API构建简单的网络服务。 正文其实无论什么语言、什么平台，实现网络编程都需要遵循网络标准规范，只不过具体实现或者提供的API不同而已。因此，在探讨node网络编程之前，我们需要了解用于网络通信的网络协议(推荐阅读《图解HTTP》)。理解了网络通信的规范和机制，再熟悉一下API就可以了。 TCP/UDPTCP(Transmission Control Protocol)传输控制协议是面向连接的协议，也就是必须建立连接才能发送数据。TCP在传输之前需要与服务器端进行3次握手形成会话(SYN是同步信号，ACK是确认信号)： TCP传送数据比较可靠，如果丢失数据会重传，并且会对传送数据进行排序。适用于重要、有序数据的传送。 UDP(User Datagram Protocol)用户数据报协议是无连接协议，不面向连接，面向事务，创建过程相对简单，占用内存底，处理快速且灵活，发送数据不需要与另一端建立连接，且不分客户端、服务器端，在一端即可以发送数据也可以接收数据。传送的数据是无序的，网络中断会导致丢包。UDP的简单不可靠特性适用于丢失一部分数据不会造成太大影响的场景，如音视频数据传送等。 socket 网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket(套接字)，因此建立网络通信连接至少要一对端口号(socket)。socket本质是对TCP/IP协议栈的封装，它提供了一个针对TCP或者UDP编程的接口，并不是另一种协议。通过socket，你可以使用TCP/IP协议。 Socket的英文原义是“孔”或“插座”。作为BSD UNIX的进程通信机制，取后一种意思。通常也称作”套接字“，用于描述IP地址和端口，是一个通信链的句柄，可以用来实现不同虚拟机或不同计算机之间的通信。在Internet上的主机一般运行了多个服务软件，同时提供几种服务。每种服务都打开一个Socket，并绑定到一个端口上，不同的端口对应于不同的服务。Socket正如其英文原意那样，像一个多孔插座。一台主机犹如布满各种插座的房间，每个插座有一个编号，有的插座提供220伏交流电， 有的提供110伏交流电，有的则提供有线电视节目。 客户软件将插头插到不同编号的插座，就可以得到不同的服务。 ​ ——百度百科 创建TCP、UDP客户端和服务端 在node中，net模块提供创建基于TCP协议的网络通信的API，net.Socket类提供了 TCP 或 UNIX Socket 的抽象，net.createServer用于创建服务端，net.Socket和net.connect用于创建客户端。 dgram模块用于创建基于UDP协议的网络服务，创建不分客户端不分客户端、服务器端，在一端使用dgram.createSocket即可发送数据也可以接收数据。 http/httpshttp是应用层协议，建立在TCP/IP之上，https则建立在TLS、SSL加密层协议之上，现代web基本都是http/https应用。TCP在建立连接要发送报文，http也是，http报文分为请求报文和响应报文，报文格式如下： 123456HTTP/1.0 200 OK //起始行Content-type:text/plain //头部Content-length:19 //头部 Hi I&apos;m a message! //主体 其中最重要的莫过于头部报文了，它定义了请求或响应的行为方式，是客户端与服务器端交流的重要信息。http报文头部的属性多达几十个，而且越来越多，保证客户端与服务器端充分交流。 现代浏览器，集成了HTTP代理功能，用户点击链接等行为会由浏览器生成HTTP请求报文发送给服务器端，收到响应后会解析报文，渲染报文中的主体内容。 node中的http node中http模块提供创建基于http协议的网络通信应用的接口，继承于net模块，采用事件驱动机制，能与多个客户端保持连接，并不为每个连接开启新的进程或线程，低内存、高并发，性能优良。 “http模块将连接所用套接字(socket)的读写抽象为ServerRequest和ServerResponse对象，它们分别对应请求和响应操作。在请求产生的过程中，http模块拿到连接中传来的数据，调用二进制模块http_parser进行解析，在解析完请求报文的报头后，触发request事件，调用用户的业务逻辑。” ​ ——朴灵《深入浅出Node.js》 从上图可以看到，node中http模块所做的事情就是继承net模块使用TCP协议、封装http请求、产生http事件、响应事件绑定的处理程序。 http代理 node中http模块提供了一个类http.Agent，它称为http代理，它的作用就是为了重用TCP连接，减少资源浪费。那么http代理是如何重用TCP连接呢？http代理维护一个连接池，从客户端发起的http请求都经由代理管理： 它为一个给定的主机与端口维护着一个等待请求的队列，且为每个请求重复使用一个单一的 socket(TCP) 连接直到队列为空，此时 socket(TCP 连接) 会被销毁或被放入一个连接池中，在连接池中等待被有着相同主机与端口的请求再次使用。 是否被销毁或被放入连接池取决于 keepAlive选项 ​ ——Node.js 8.9.0中文文档 连接池如何管理连接还得取决于服务器： 即便连接池中的连接的 TCP Keep-Alive 是开启的，服务器仍然可能关闭闲置的连接，在这种情况下，这些连接会被移出连接池，且当一个新的 HTTP 请求被创建时再为指定的主机与端口创建一个新的连接。 服务器也可能拒绝允许同一连接上有多个请求，在这种情况下，连接会为每个请求重新创建，且不能被放入连接池。Agent 仍然会创建请求到服务器，但每个请求会出现在一个新的连接。 但一个连接被客户端或服务器关闭时，它会被移出连接池。 连接池中任何未被使用的 socket 会被释放，从而使 Node.js 进程在没有请求时不用保持运行。 ​ ——Node.js 8.9.0中文文档 http模块除了提供代理类，还提供了： http.ClientRequest类—— 表示一个正在处理的请求，这个请求还能设置请求头 http.Server类——继承net.Server，并添加了一些事件 http.ServerResponse类——代表响应 http.createServer方法——创建服务器，返回http.Server实例 http.request方法——显式发出请求 各种请求、响应对应的事件 创建http服务器 1234567// node创建服务器非常简单，不需要任何三方代理var http = require('http');http.createServer(function (req, res) &#123; res.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;) res.end('Hello World\\n');&#125;).listen(8880, '127.0.0.1');console.log('Server running at http://127.0.0.1:8880/') 创建http请求 使用http.request即可发送请求。 WebSocket一问一答是HTTP协议的特点，然而服务器主动向客户端推送数据的场景也是常见的、被需要的。在WebSocket出现之前，实现客户端和服务器端双工通信一般只能通过多开几个HTTP连接、以轮询方式来实现。由于HTTP一问一答的特点不适合这种场景，就算HTTP1.1新增的Keep-Alive也不能很好的解决这种问题，于是WebSocket协议就出现了。 WebSocket协议可以让客户端与服务器端实现双向通信，服务端可以主动发送数据到客户端。建立WebSocket协议连接时，客户端会发送一条HTTP请求，请求服务器端切换协议为WebSocket，服务器端如果支持WebSocket协议，就会返回一条HTTP响应表示正在切换WebSocket协议并切换。之后就可以互相发送数据了。 使用WebSocket协议构建应用有以下优点： 客户端可以与服务器端实现双向通信，服务端可以主动发送数据到客户端 通过第一个request建立了TCP连接之后，之后交换的数据都不需要发送 HTTP header就能交换数据 目前大多数浏览器已经实现WebSocket，可以直接使用： 1234567var socket = new WebSocket('ws://localhost:3000/') // 路径中的协议改为ws(WebSocket)socket.onopen = function () &#123; // 连接打开要做的事&#125;;socket.onmessage = function (event) &#123; // 接收到服务端的信息（event.data）&#125;; 调用WebSocket后浏览器会发送一个HTTP请求，请求报文如下： 1234567GET /chat HTTP/1.1Host: server.example.comUpgrade: websocket // 请求协议升级为websocketConnection: UpgradeSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ== //校验值Sec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13 在Node原生模块中没有支持WebSocket协议连接功能的模块，但Node有很多三方模块来帮助做这件事，常用的ws模块方法如下： 12345678910111213141516171819202122// 导入WebSocket模块:const WebSocket = require('ws');// 引用Server类:const WebSocketServer = WebSocket.Server;// 实例化:const wss = new WebSocketServer(&#123; // 在本地3000端口打开一个WebSocket Server port: 3000&#125;);wss.on('connection', function (ws) &#123; console.log(`[SERVER] connection()`); ws.on('message', function (message) &#123; console.log(`[SERVER] Received: $&#123;message&#125;`); ws.send(`ECHO: $&#123;message&#125;`, (err) =&gt; &#123; if (err) &#123; console.log(`[SERVER] error: $&#123;err&#125;`); &#125; &#125;); &#125;)&#125;); 服务器返回的响应报文如下： 12345HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo= // 返回经过计算得出的校验值 Sec-WebSocket-Protocol: chat 使用框架进行网络编程Node网络模块中提供的API较为底层，有时在构建网络应用程序并不需要关心底层实现，这时就可以借助三方框架封装好的API来帮助我们，常用的框架包括express、koa、connect等。","tags":[{"name":"node","slug":"node","permalink":"http://realtcg.com/tags/node/"},{"name":"node基础","slug":"node基础","permalink":"http://realtcg.com/tags/node基础/"}]},{"title":"认识node核心模块--从Buffer、Stream到fs","date":"2017-11-10T13:03:07.000Z","path":"2017/11/10/认识node核心模块-从Buffer、Stream到fs/","text":"node中的Buffer和Stream会给刚接触Node的前端工程师们带来困惑，原因是前端并没有类似概念(or 有我们也没意识到)。然而，在后端，在node中，Buffer和Stream处处体现。Buffer是缓冲区的意思，Stream是流的意思。在计算机中，缓冲区是存储中间变量，方便CPU读取数据的一块存储区域；流是类比水流形容数据的流动。Buffer和Stream一般都是字节级操作。本文将介绍这两个模块的具体细节后再介绍文件模块，以让读者有更清晰的认识。 正文二进制缓冲区Buffer在前端，我们只需做字符串级别的操作，很少接触字节、进制等底层操作，一方面这足以满足日常需求，另一方面Javascript这种应用层语言并不是干这个的；然而在后端，处理文件、网络协议、图片、视频等时是非常常见的，尤其像文件、网络流等操作处理的都是二进制数据。为了让javascript能够处理二进制数据，node封装了一个Buffer类，主要用于操作字节，处理二进制数据。 123456789// 创建一个长度为 10、且用 30 填充的 Buffer。const buf1 = Buffer.alloc(10, 30)console.log(buf1)// &lt;Buffer 1e 1e 1e 1e 1e 1e 1e 1e 1e 1e&gt;// 字符串转Bufferconst buf2 = Buffer.from('javascript')console.log(buf2)// &lt;Buffer 6a 61 76 61 73 63 72 69 70 74&gt;// 字符串转 bufferconsole.log(buf2.toString())// javascriptconsole.log(buf2.toString('hex')) //6a617661736372697074 一个 Buffer 类似于一个整数数组，可以取下标，有length属性，有剪切复制操作等，很多API也类似数组，但Buffer的大小在被创建时确定，且无法调整。Buffer处理的是字节，两位十六进制，因此在整数范围就是0～255。 可以看到，Buffer可以与string互相转化，还可以设置字符集编码。Buffer用来处理文件I／O、网络I/O传输的二进制数据，string用来呈现。在处理文件I／O、网络I/O传输的二进制数据时，应该尽量以Buffer形式直接传输，速度会得到很好的提升，但操作字符串比操作Buffer还是快很多的。 Buffer内存分配与性能优化 Buffer是一个典型的javascript与C++结合的模块，与性能有关的用C++来实现，javascript 负责衔接和提供接口。Buffer所占的内存不是V8分配的，是独立于V8堆内存之外的内存，通过C++层面实现内存申请、javascript 分配内存。值得一提的是，每当我们使用Buffer.alloc(size)请求一个Buffer内存时，Buffer会以8KB为界限来判断分配的是大对象还是小对象，小对象存入剩余内存池，不够再申请一个8KB的内存池；大对象直接采用C++层面申请的内存。因此，对于一个大尺寸对象，申请一个大内存比申请众多小内存池快很多。 流Stream前面讲到，流类比水流形容数据的流动，在文件I/O、网络I／O中数据的传输都可以称之为流，流是能统一描述所有常见输入输出类型的模型，是顺序读写字节序列的抽象表示。数据从A端流向B端与从B端流向A端是不一样的，因此，流是有方向的。A端输入数据到B端，对B就是输入流，得到的对象就是可读流；对A就是输出端、得到的对象是可写流。有的流即可以读又可以写，如TCP连接，Socket连接等，称为读写流(Duplex)。还有一种在读写过程中可以修改和变换数据的读写流称为Transform流。 在node中，这些流中的数据就是Buffer对象，可读、可写流会将数据存储到内部的缓存中，等待被消费；Duplex 和 Transform 则是都维护了两个相互独立的缓存用于读和写。 在维持了合理高效的数据流的同时，也使得对于读和写可以独立进行而互不影响。 在node中，这四种流都是EventEmitter的实例，它们都有close、error事件，可读流具有监听数据到来的data事件等，可写流则具有监听数据已传给低层系统的finish事件等，Duplex 和 Transform 都同时实现了 Readable 和 Writable 的事件和接口 。 值得一提的是writable的drain事件，这个事件表示缓存的数据被排空了。为什么有这个事件呢？起因是调用可写流的write和可读流的read都会有一个缓存区用来缓存写／读的数据，缓存区是有大小的，一旦写的内容超过这个大小，write方法就会返回false，表示写入停止，这时如果继续read完缓存区数据，缓存区被排空，就会触发drain事件，可以这样来防止缓存区爆仓： 12345678910111213141516var rs = fs.createReadStream(src);var ws = fs.createWriteStream(dst);rs.on('data', function (chunk) &#123; if (ws.write(chunk) === false) &#123; rs.pause(); &#125;&#125;);rs.on('end', function () &#123; ws.end();&#125;);ws.on('drain', function () &#123; rs.resume();&#125;); 一些常见流分类： 可写流：HTTP requests, on the client、HTTP responses, on the server、fs write streams、zlib streams、crypto streams、TCP sockets、child process stdin、process.stdout, process.stderr 可读流：HTTP responses, on the client、HTTP requests, on the server、fs read streams、zlib streams、crypto streams、TCP sockets、child process stdout and stderr、process.stdin 可读可写流：TCP sockets、zlib streams、crypto streams 变换流：zlib streams、crypto streams 另外，提到流就不得不提到管道的概念，这个概念也非常形象：水流从一端到另一端流动需要管道作为通道或媒介。流也是这样，数据在端之间的传送也需要管道，在node中是这样的： 1234567891011// 将 readable 中的所有数据通过管道传递给名为 file.txt 的文件const readable = getReadableStreamSomehow();const writable = getWritableStreamSomehow('file.txt');// readable 中的所有数据都传给了 'file.txt'readable.pipe(writable);// 对流进行链式地管道操作const r = fs.createReadStream('file.txt');const z = zlib.createGzip();const w = fs.createWriteStream('file.txt.gz');r.pipe(z).pipe(w); 注意，只有可读流才具有pipe能力，可写流作为目的地。 pipe不仅可以作为通道，还能很好的控制管道里的流，控制读和写的平衡，不让任一方过度操作。另外，pipe可以监听可读流的data、end事件，这样就可以构建快速的响应： 123456789101112131415161718// 一个文件下载的例子，使用回调函数的话需要等到服务器读取完文件才能向浏览器发送数据var http = require('http') ;var fs = require('fs') ;var server = http.createServer(function (req, res) &#123; fs.readFile(__dirname + '/data.txt', function (err, data) &#123; res.end(data); &#125;) ;&#125;) ;server.listen(8888) ;// 而采用流的方式，只要建立连接，就会接受到数据，不用等到服务器缓存完data.txtvar http = require('http') var fs = require('fs') var server = http.createServer(function (req, res) &#123; var stream = fs.createReadStream(__dirname + '/data.txt') stream.pipe(res) &#125;) server.listen(8888) 因此，使用pipe即可解决上面那个爆仓问题。 fs文件模块fs文件模块是高阶模块，继承了EventEmitter、stream、path等底层模块，提供了对文件的操作，包括文件的读取、写入、更名、删除、遍历目录、链接POSIX文件系统等操作。与node设计思想和其他模块不同的是，fs模块中的所有操作都提供了异步和同步两个版本。fs模块主要由下面几部分组成: 对底层POSIX文件系统的封装,对应于操作系统的原生文件操作 继承Stream的文件流 fs.createReadStream和fs.createWriteStream 同步文件操作方法，如fs.readFileSync、fs.writeFileSync 异步文件操作方法， fs.readFile和fs.writeFile 模块API架构如下： 读写操作： 12345678910111213141516171819202122232425262728const fs = require('fs'); // 引入fs模块/* 读文件 */// 使用流const read = fs.createReadStream('sam.js',&#123;encoding:'utf8'&#125;);read.on('data',(str)=&gt;&#123; console.log(str);&#125;)// 使用readFilefs.readFile('test.txt', &#123;&#125;, function(err, data) &#123; if (err) &#123; throw err; &#125; console.log(data);&#125;);// open + readfs.open('test.txt','r',(err, fd) =&gt; &#123; fs.fstat(fd,(err,stat)=&gt;&#123; var len = stat.size; //检测文件长度 var buf = new Buffer(len); fs.read(fd,buf,0,len,0,(err,bw,buf)=&gt;&#123; console.log(buf.toString('utf8')); fs.close(fd); &#125;) &#125;);&#125;);/* 写文件与读取文件API形式类似 */ 读/写文件都有三种方式，那么区别是什么呢？ createReadStream/createWriteStream创建一个将文件内容读取为流数据的ReadStream对象，这个方法主要目的就是把数据读入到流中，得到是可读流，方便以流进行操作 readFile/writeFile：Node.js会将文件内容视为一个整体，为其分配缓存区并且一次性将文件内容读/写取到缓存区中，在这个期间，Node.js将不能执行任何其他处理，所以当读写大文件的时候，有可能造成缓存区“爆仓” read/write读/写文件内容是不断地将文件中的一小块内容读/写入缓存区，最后从该缓存区中读取文件内容 同步API也是如此。其中最常用的是readFile，读取大文件则采取用，read则提供更为细节、底层的操作，而且read要配合open。 获取文件的状态： 1234567891011121314151617181920212223242526fs.stat('eda.txt', (err, stat) =&gt; &#123; if (err) throw err console.log(stat)&#125;)/* Stats &#123; dev: 16777220, mode: 33279, nlink: 1, uid: 501, gid: 20, rdev: 0, blksize: 4194304, ino: 4298136825, size: 0, blocks: 0, atimeMs: 1510317983760.94, - 文件数据最近被访问的时间 mtimeMs: 1510317983760.94, - 文件数据最近被修改的时间。 ctimeMs: 1510317983777.8538, - 文件状态最近更改的时间 birthtimeMs: 1509537398000, atime: 2017-11-10T12:46:23.761Z, mtime: 2017-11-10T12:46:23.761Z, ctime: 2017-11-10T12:46:23.778Z, birthtime: 2017-11-01T11:56:38.000Z &#125;*/ 监听文件： 123456789101112const FSWatcher = fs.watch('eda.txt', (eventType, filename) =&gt; &#123; console.log(`$&#123;eventType&#125;`)&#125;)FSWatcher.on('change', (eventType, filename) =&gt; &#123; console.log(`$&#123;filename&#125;`)&#125;)// watch和返回的FSWatcher实例的回调函数都绑定在了 change 事件上fs.watchFile('message.text', (curr, prev) =&gt; &#123; console.log(`the current mtime is: $&#123;curr.mtime&#125;`); console.log(`the previous mtime was: $&#123;prev.mtime&#125;`);&#125;) 监听文件仍然有两种方法： watch 调用的是底层的API来监视文件，很快，可靠性也较高 watchFile 是通过不断轮询 fs.Stat （文件的统计数据）来获取被监视文件的变化，较慢，可靠性较低，另外回调函数的参数是 fs.Stat 实例 因此尽可能多的使用watch，watchFile 用于需要得到文件更多信息的场景。 其他 创建、删除、复制、移动、重命名、检查文件、修改权限… 总结由Buffer到Stream，再到fs文件模块，将它们串联起来能对整块知识有更清晰的认识，也对webpack、gulp等前端自动化工具构建工作流的机制和实现有了更深的了解。学习其他知识亦是如此——知道来龙去脉，知道为什么会存在，知道它们之间的联系，就能让碎片化的知识串联起来，能让它们make sense，能够让自己“上的厅堂、下得厨房”。 参考： nodeJs高阶模块–fs deep into node","tags":[{"name":"node","slug":"node","permalink":"http://realtcg.com/tags/node/"},{"name":"node基础","slug":"node基础","permalink":"http://realtcg.com/tags/node基础/"}]},{"title":"认识node核心模块--深入EventEmitter","date":"2017-11-03T13:03:07.000Z","path":"2017/11/03/认识node核心模块-深入EventEmitter/","text":"node 采用了事件驱动机制，而EventEmitter 就是node实现事件驱动的基础。在EventEmitter的基础上，node 几乎所有的模块都继承了这个类，以实现异步事件驱动架构。继承了EventEmitter的模块，拥有了自己的事件，可以绑定／触发监听器，实现了异步操作。EventEmitter是node事件模型的根基，由EventEmitter为基础构建的事件驱动架构处处体现着异步编程的思想，因此，我们在构建node程序时也要遵循这种思想。EventEmitter实现的原理是观察者模式，这也是实现事件驱动的基本模式。本文将围绕EventEmitter，从中探讨它的原理观察者模式、体现的异步编程思想以及应用。 正文events模块的EventEmitter类node 的events模块只提供了一个EventEmitter类，这个类实现了node异步事件驱动架构的基本模式——观察者模式，提供了绑定事件和触发事件等事件监听器模式一般都会提供的API： 1234567891011const EventEmitter = require('events')class MyEmitter extends EventEmitter &#123;&#125;const myEmitter = new MyEmitter()function callback() &#123; console.log('触发了event事件！')&#125;myEmitter.on('event', callback)myEmitter.emit('event')myEmitter.removeListener('event', callback); 只要继承EventEmitter类就可以拥有事件、触发事件等，所有能触发事件的对象都是 EventEmitter 类的实例。 而观察者模式(事件发布／订阅模式)就是实现EventEmitter类的基本原理，也是事件驱动机制基本模式。 事件驱动原理：观察者模式在事件驱动系统里，事件是如何产生的？一个事件发生为什么能”自动”调用回调函数？我们先看看观察者模式。 观察者(Observer)模式是一种设计模式，应用场景是当一个对象的变化需要通知其他多个对象而且这些对象之间需要松散耦合时。在这种模式中，被观察者(主体)维护着一组其他对象派来(注册)的观察者，有新的对象对主体感兴趣就注册观察者，不感兴趣就取消订阅，主体有更新的话就依次通知观察者们。说猿话就是： 1234567891011121314151617181920212223242526272829303132333435363738function Subject() &#123; this.listeners = &#123;&#125;&#125;Subject.prototype = &#123; // 增加事件监听器 addListener: function(eventName, callback) &#123; if(typeof callback !== 'function') throw new TypeError('\"listener\" argument must be a function') if(typeof this.listeners[eventName] === 'undefined') &#123; this.listeners[eventName] = [] &#125; this.listeners[eventName].push(callback) // 放到观察者对象中 &#125;, // 取消监听某个回调 removeListener: function(eventName, callback) &#123; if(typeof callback !== 'function') throw new TypeError('\"listener\" argument must be a function') if(Array.isArray(this.listeners[eventName]) &amp;&amp; this.listeners[eventName].length !== 0) &#123; var callbackList = this.listeners[eventName] for (var i = 0, len=callbackList.length; i &lt; len; i++) &#123; if(callbackList[i] === callback) &#123; this.listeners[eventName].splice(i,1) // 找到监听器并从观察者对象中删除 &#125; &#125; &#125; &#125;, // 触发事件：在观察者对象里找到这个事件对应的回调函数队列，依次执行 triggerEvent: function(eventName,...args) &#123; if(this.listeners[eventName]) &#123; for(var i=0, len=this.listeners[eventName].length; i&lt;len; i++)&#123; this.listeners[eventName][i](...args) &#125; &#125; &#125;&#125; OK，我们现在来添加监听器和发送事件： 12345678var event = new Subject()function hello() &#123; console.log('hello, there')&#125;event.addListener('hello', hello)event.triggerEvent('hello') // 输出 hello, thereevent.removeListener('hello', hello) // 取消监听setTimeout(() =&gt; event.triggerEvent('hello'),1000) // 过了一秒什么也没输出 在观察者模式中，注册的回调函数即事件监听器，触发事件调用各个回调函数即是发布消息。 你可以看到，观察者模式只不过维护一个信号对应函数的列表，可以存，可以除，你只要给它信号(索引)，它就按照这个信号执行对应的函数，也就相当于间接调用了。那直接调用函数不就行了，干嘛写的那么拐弯抹角？刚才也说了，这是因为观察者模式能够解耦对象之间的关系，实现了表示层和数据逻辑层的分离，并定义了稳定的更新消息传递机制。 回到开始的问题，事件是如何产生又“自动”被调用的？是像上面那样当调用event.triggerEvent的时侯产生的吗？并不是，调用event.triggerEvent就相当于调用了回调函数，是事件执行过程，而事件产生过程则更多由底层来产生并通知给node的。我们拿node的全局变量 process来举例，process是EventEmitter的实例： 123process.on('exit', (code) =&gt; &#123; console.log(`About to exit with code: $&#123;code&#125;`);&#125;); node执行时会在process的exit事件上绑定你指定的回调，相当于调用了上面的addListener，而当你退出进程时，你会发现你指定的函数被执行了，但是你没有手动调用触发exit事件的方法，也就是上面的triggerEvent，这是因为node底层帮你调用了——操作系统底层使这个进程退出了，node会得到这个信息，然后触发事先定义好的触发方法，回调函数就因此依次执行了。像这样的内置事件是node模块事先写好并开放出来的，使用时直接绑定回调函数即可，如果要自定义事件，那就得自己发送信号了。 上面代码实现了最基本的观察者模式，node 源码中EventEmitter的实现原理跟这差不多，除了这些还加入了其他有用的特性，而且各种实现都尽可能使用性能最好的方式(node源码真是处处反映着智慧的光芒)。 node中众多模块都继承了EventEmitter，比如文件模块系统下的FSWatcher： 123456789const EventEmitter = require('events')const util = require('util')...function FSWatcher() &#123; EventEmitter.call(this);// 调用构造函数 ...&#125;util.inherits(FSWatcher, EventEmitter); // 继承 EventEmitter 其他模块也是如此。它们一同组成了node的异步事件驱动架构。 异步编程范式可以看到，由于采用事件模型和异步I／O，node中大量模块的API采用了异步回调函数的方式，底层也处处体现了异步编程的方式。虽然异步也带来了很多问题——理解困难、回调嵌套过深、错误难以捕捉、多线程编程困难等，不过相比于异步带来的高性能，加上这些问题都有比较好的解决方案，异步编程范式还是很值得尝试的，尤其对于利用node构建应用程序的时候。 从最基本的回调函数开始 回调函数是异步编程的体现，而回调函数的实现离不开高阶函数。得益于javascript语言的灵活性，函数作为参数或返回值，而将函数作为参数或返回值的函数就是高阶函数： 12345678910function foo(x,bar) &#123; return bar(x)&#125;// 对于相同的foo，传进去不同的bar就有不同的操作结果var arr = [2,3,4,5]arr.forEach(function(item,index)&#123; // do something for every item&#125;) // 数组的高阶函数event.addListener('hello', hello) // 还有上面观察者模式实现的addListener 基于高阶函数的特性，就可以实现回调函数的模式。实际上，正式因为javascript函数用法非常灵活，才有高阶函数和众多设计模式。 采用事件发布／订阅模式(观察者模式) 单纯地使用高阶函数特性不足以构建简单、灵活、强大的异步编程模式的应用程序，我们需要从其他语言借鉴一些设计模式。就像上面提到的，node的events模块实现了事件发布／订阅模式，这是一种广泛用于异步编程的模式。它将回调函数事件化，将事件与各回调函数相关联，注册回调函数就是添加事件监听器，这些事件监听器可以很方便的添加、删除、被执行，使得事件和处理逻辑（注册的回调函数）之间轻松实现关联和解耦——事件发布者无需关注监听器是如何实现业务逻辑的，也不用关注有多少个事件监听器，只需按照消息执行即可，而且数据通过这种消息的方式可以灵活的传递。 不仅如此，这种模式还可以实现像类一样的对功能进行封装：将不变的逻辑封装在内部，将需要自定义、容易变化的部分通过事件暴露给外部定义。Node中很多对象大多都有这样黑盒子的特点，通过事件钩子，可以使使用者不用关注这个对象是如何启动的，只需关注自己关注的事件即可。 像大多数node核心模块一样，继承EventEmitter，我们就可以使用这种模式，帮助我们以异步编程方式构建node程序。 利用Promise Promise是CommonJs发布的一个规范，它的出现给异步编程带来了方便。Promise所作的只是封装了异步调用、嵌套回调，使得原本复杂嵌套逻辑不清的回调变得优雅和容易理解。有了Promise的封装，你可以这样写异步调用： 1234567891011121314151617181920212223function fn1(resolve, reject) &#123; setTimeout(function() &#123; console.log('步骤一：执行'); resolve('1'); &#125;,500);&#125;function fn2(resolve, reject) &#123; setTimeout(function() &#123; console.log('步骤二：执行'); resolve('2'); &#125;,100);&#125;new Promise(fn1).then(function(val)&#123; console.log(val); return new Promise(fn2);&#125;).then(function(val)&#123; console.log(val); return 33;&#125;).then(function(val)&#123; console.log(val);&#125;); 那Promise是如何封装的呢？ 首先，Promise经常用于处理异步、延时操作，为了放在then里面的”接下来要做的事“以正确的顺序被执行，Promise被设计为状态机，状态变化为pending =&gt; resolve（成功）、pending =&gt; reject（失败），而且，Promise还维护成功或失败时要执行的函数List，List中的回调正是Promise处在pending状态时将then中注册的回调push进去的；Promise内部有一个resolve和reject函数，分别在成功／失败时执行函数List，并且这两个函数会传递给回调函数，由用户决定什么时候resolve/reject；为了实现链式调用，then中返回的是promise： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778function getUserId() &#123; return new Promise(function(resolve, i) &#123; //异步请求 setTimeout(function()&#123; console.log('异步操作成功，下一步执行promise的'+i+'的resolve') resolve('Fuck you Promise!', i) &#125;,1000) &#125;, 1)&#125;getUserId().then(function(words) &#123; console.log(words)&#125;)// 实现function Promise(fn, i) &#123; var i = i var state = 'pending' var result = null var promises = [] console.log('Promise' + i + 'constructing') this.then = function(onFulfilled) &#123; console.log('then被调用') return new Promise(function(resolve) &#123; console.log('返回一个promise') handle(&#123; onFulfilled: onFulfilled || null, resolve: function(ret, i) &#123;resolve(ret,i)&#125; &#125;) &#125;,2) &#125; function handle(promise) &#123; if(state === 'pending') &#123; console.log('promise' + i + '还在pending中') promises.push(promise) console.log('注册回调') return &#125; if(!promise.onFulfilled) &#123; console.log('回调为空，resolve结果') promise.resolve(result, i) return &#125; console.log('执行回调') var ret = promise.onFulfilled(result) console.log('处理回调返回的值(可能是另一个promise)') promise.resolve(ret, 2) &#125; function resolve (newResult, i) &#123; console.log('执行promise' + i + '的resolve') if(newResult &amp;&amp; (typeof newResult === 'object' || typeof newResult === 'function')) &#123; console.log('then中注册的回调返回了promise') var then = newResult.then if(typeof then === 'function') &#123; console.log('调用then') then.call(newResult, resolve) &#125; &#125; console.log('设置promise' + i + '的状态为fulfilled') state = 'fulfilled' result = newResult setTimeout(function()&#123; console.log('遍历promise' + i + '注册的回调执行') console.log(promises[0]) promises.forEach(function(promise) &#123; handle(promise) &#125;); &#125;,0) &#125; console.log('传resolve到promise' + i + '函数参数') fn(resolve, i)&#125; 注意，这是Promise/A+规范的简单实现，还有reject原理一样的。我在这里为了更好的理解promise，不至于弄混乱，加入了标号，方便理解，Promise/A+规范里并没有。 实际上，node高版本已经支持promise了，可以直接使用，但不如Bluebird这类三方库快，而且Bluebird扩展了很多Promise/A+没有的方法。 使用第三方库Async/Step async是著名的流程控制库，经常被npm install，它提供了20多个方法帮助我们处理异步协作模式。比如： series ——异步任务的串行执行，就像Promise一样，只不过形式不同 parallel——异步任务并行执行，相当于Promise.all waterfall——处理具有依赖关系的异步调用，比如前一个结果是后一个输入 auto——自动分析异步调用的依赖关系，参数是一个依赖关系对象 … Step比async更轻量、更简单，只有一个接口Step, 在接口里可以调用Step提供的方法，功能与async差不多。 异步编程范式远不止这么多，还有很多重要的思想、设计模式，还有一些需要在实践中去发现、总结。 总结EventEmitter提供的接口非常简单，但是它背后体现的思想贯穿了Node整个架构。Node不是第一个使用异步编程的平台，但异步架构在Node中处处体现，是Node设计的基本思想。在学习node时，透过现象看本质、深入浅出，是一个明智的方法，对待任何事物也是如此。 参考文献： https://segmentfault.com/a/1190000009478377 【朴灵】《深入浅出Node.Js》","tags":[{"name":"node","slug":"node","permalink":"http://realtcg.com/tags/node/"},{"name":"node基础","slug":"node基础","permalink":"http://realtcg.com/tags/node基础/"}]},{"title":"认识node核心模块--全局对象及Cluster","date":"2017-10-25T12:59:29.000Z","path":"2017/10/25/认识node核心模块-全局对象及Cluster/","text":"node 模块是node 完成强大功能的实现者。node 的核心模块包括events、fs、buffer、stream、cluster、http、net、一些操作OS和工具模块、全局对象等。本文将在node核心特性理解的基础上进一步深入探讨node核心模块的具体细节。本文主要探讨的模块有：全局对象global及其重要属性、多进程cluster、events重要类EventEmitter、流Stream、文件系统fs、网络http，还会介绍node框架express相关。 概述本文先来介绍全局对象global及其重要属性、多进程cluster模块。 正文node全局对象global与浏览器对应的window一样，在node中global是全局对象，在全局作用域定义的任何变量都会保存为global的属性，称为全局变量。下面是global一些重要的属性： 模块：module、require、exports 这三个全局变量组成了node 的模块定义和引入，是 commonJS 的实现。node将每个文件视为一个模块，在执行到每个模块之前都会定义好上述三个变量，因此可以直接使用。来看它们之间的协作： 12345678// module1.jsexports.fun = function(a,b) &#123; return a + b;&#125; //绑定在exports的属性可以被其他模块引入使用//module2.jsvar module1 = require('./module1')module1.fun(3,2) //5 相关机制： module 表示对这个模块的引用，因此module 实际上不是全局的，而是每个模块本地的。module除了exports 还有其他关于模块的属性，例如module.children exports 其实是module.exports的简写，表示这个模块的输出。有一点需要注意，对exports直接赋值exports = {...}并不会被输出，因为exports事先已经被定义了，再次这样赋值会被覆盖，需要带上module：module.exports = {...} require 表示引入某个模块，填写模块路径即可，在node_modules里面的模块填写名字即可，js文件可以不用写扩展名。 另外，由于V8引擎对ES6的不断支持，node 中也可以直接使用ES6的一些特性、例如promise、class等，ES6的模块也被node 实验性的引入并且是稳定的。详情见nodejs中文网。可以在node.green查看支持的特性 异步操作 setTimeout、setInterval、setImmediate、process.nextTick setTimeout和setInterval跟浏览器端一样，不同的是，node实现了setImmediate（目前浏览器端只有 IE实现了该方法）。它表示在 Node.js 事件循环的当前回合结束时要调用的函数，用来把一些需要长时间运行的操作放在一个回调函数里,在node主线程完成后面的其他语句后,就立刻执行这个回调函数，参数是一个函数和用作这个函数的参数，作用跟setTimeout(fn,0)差不多，都是相当于立即在事件队列末尾插入一个事件，但也有差别。 process.nextTick(fn,...args)表示在当前调用栈结束后，在下一个事件执行前调用回调函数。node 提供这个API是为了把复杂耗时的任务放到最后去处理，以便优先执行简单的任务。来看它们之间的比较： 1234setTimeout(() =&gt; console.log(\"setTimeout0\"),0)setImmediate(() =&gt; console.log(\"setImmediate\"))process.nextTick(() =&gt; console.log(\"nextTick\"))//输出nextTick setTimeout0 setImmediate 或者 nextTick setImmediate setTimeout0 无论process.nextTick写在什么地方，它总是第一个输出。无论setTimeout和setImmediate谁先谁后，都可能出现两种结果，其中setTimeout(fn,0)先于setImmediate多一点。这是因为它们三个产生的事件推入到了不同的watcher（观察者）中—— setTimeout推入到了定时器观察者，setImmediate是check观察者，而process.nextTick()是idle观察者 ，而node主线程在事件循环时调用watcher 的顺序一般是 idle观察者 &gt; check观察者，idle观察者 &gt; 定时器观察者，check 和定时器不分先后，但定时器先于check的概率大一点。 node进程： process process 是node对进程的表示，提供了操作进程的接口，可以用process来提供进程有关信息，控制进程 。 process提供的接口包括 描述进程的一些状态（事件）：exit、beforeExit、uncaughtException、Signal 进程退出返回的状态码：Uncaught Fatal Exception、Signal Exits、Unused等 进程的相关信息：stdout、stderr、config、stdin、exitCode、pid(进程编号)等 操作进程的方法：abort、chdir、cwd、kill(发送信号给进程)、exit、nextTick、getgid、setgid、uptime等 其他： console、__filename、 __dirname 这些都是全局变量，可以在任何地方引用 node 子进程：child_process模块一个进程只能利用一个CPU时间分片，为了高效利用多核CPU，node 提供了可以创建子进程(注意不是子线程)的child_process模块，来帮助主进程高效利用多核CPU完成其他复杂的任务。之所以提供创建子进程而不是子线程的接口，是因为这让我们的程序状态单一，不用在意状态同步、死锁、上下文切换开销等等多线程编程中的头疼问题。这样以来一个进程只有一个线程。虽然单线程也会带来一些问题，如错误会引起整个应用退出等，但这都有了很好的解决方案。 创建子进程 node有三种创建子进程的接口： exec / execFile: 这两者都会创建子进程来执行，执行的结果会存储在Buffer中。不同的是前者创建一个shell进程来执行命令，后者直接创建一个进程用来执行可执行文件，因此前者适合用来执行shell命令然后获取输出，后者效率较高。这两者因为输出的结果存储在Buffer中，因此只适合输出轻量的数据。 spawn：适合用于进程输入、输出数据量比较大的情况，因为它支持以 stream 的形式输入输出，可以用于任何命令。spawn的参数option有一个stdio配置项，用来配置子进程与父进程之间的IO通道，还有一个detached来配置子进程是否独立运行，可以创建常驻后台进程。总之，给予了子进程更多的灵活性。 fork：fork 其实是spawn的特例，它会创建一个V8实例，只能用来运行node.js程序，并且与上面两种方法不同的是，fork会在父子进程间建立 IPC 通道，父子进程之间可以互相收发消息——通过监听 message 事件和调用 send 方法，就可以在父子进程间进行通信了。 父子进程通信 首先，这三种API都返回ChildProcess实例，因此都可以通过访问stdout属性来得到输出，exec/execFile 接口还可以在参数里绑定回调函数拿到子进程的stdout 。 123456789101112131415161718192021const &#123; exec, execFile, spawn, fork &#125; = require(\"child_process\")// exec/execFile 接口既可以在参数里绑定回调函数拿到输出流，也可以利用返回的ChildProcess实例const exec_process = exec(\"node child_process.js\", &#123;&#125;, (err, stdout, stderr) =&gt; &#123; if (err) &#123; console.log(err) &#125; else if(stdout) &#123; console.log(stdout) &#125; else &#123; console.log(stderr) &#125;&#125;)exec_process.stdout.on('data',(data) =&gt; console.log(`$&#123;data&#125;`))// spawn 接口没有回调函数，只能利用返回的ChildProcess实例绑定监听数据函数拿到子进程的输出const spawn_process = spawn('node',['child_process'], &#123;&#125;)spawn_process.stdout.on('data', (data) =&gt; console.log(`$&#123;data&#125;`))//fork 也可以利用返回的ChildProcess实例，注意配置项silent要设为trueconst fork_process = fork('child_process.js', [], &#123;'silent': true&#125;)fork_process.stdout.on('data' ,(data) =&gt; console.log(`$&#123;data&#125;`)) 其次， fork返回的ChildProcess实例有一个额外的内置的通信通道IPC，它允许消息在父进程和子进程之间来回传递。 12345678910111213141516171819// child_process.jsprocess.on('message', (data) =&gt; &#123; console.log(`message from Parent: $&#123;data&#125;`);&#125;)setTimeout(() =&gt; &#123; process.send('send from child');&#125;, 2000)// parent.jsconst &#123; fork &#125; = require(\"child_process\")const p = fork( 'child_process.js', // 需要执行的脚本路径 [], // 传递的参数 &#123;&#125;)p.on('message', data =&gt; &#123; //监听子进程消息 console.log(`message from child: $&#123;data&#125;`)&#125;)p.send('send from parent') //发送消息给子进程 集群：Cluster 模块 cluster模块是对child_process模块的进一步封装，专用于解决单进程NodeJS Web服务器无法充分利用多核CPU的问题。使用该模块可以简化多进程服务器程序的开发，让每个核上运行一个工作进程，并统一通过主进程监听端口和分发请求。 ——七天学会node.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const cluster = require('cluster');const http = require('http');const numCPUs = require('os').cpus().length;console.log(numCPUs)if (cluster.isMaster) &#123; console.log(`主进程 $&#123;process.pid&#125; 正在运行`); // 衍生工作进程。 for (let i = 0; i &lt; numCPUs; i++) &#123; cluster.fork(); // 调用了 child_process.fork()方法创建工作进程 &#125; cluster.on('exit', (worker, code, signal) =&gt; &#123; console.log(`工作进程 $&#123;worker.process.pid&#125; 已退出`); &#125;);&#125; else &#123; // 工作进程可以共享任何 TCP 连接。 // 在本例子中，共享的是一个 HTTP 服务器。 http.createServer((req, res) =&gt; &#123; res.writeHead(200); res.end('你好世界\\n'); &#125;).listen(8000); console.log(`工作进程 $&#123;process.pid&#125; 已启动`);&#125;console.log(\"WOW\")// 输出（Mac OS）4主进程 55570 正在运行WOW4工作进程 55571 已启动WOW4工作进程 55572 已启动WOW4工作进程 55573 已启动WOW4工作进程 55574 已启动WOW//可以看到 fork 是异步创建的，调用时请求创建进程并立即返回，系统创建好进程后会加入到事件队列，执行到事件就调用回调函数，这个回调函数包括执行一遍这个文件 cluster.fork()实际调用了child_process.fork()，因此建立了IPC通道与父进程通信。它会创建一个进程并返回cluster.worker实例。创建的每个进程之间都是独立的，一个进程的开启和关闭不影响其他进程。只要有存活的进程，服务器就可以继续处理连接。 主进程负责监听端口，接收新连接后会自动将连接循环（默认）分发给cluster.fork()创建的工作进程来帮忙处理，因此可以使用cluster模块来实现简单的负载均衡。 注意： cluster.fork()返回cluster.worker实例可能会引起困惑，困惑的原因把主进程和工作进程做了master和worker的区分，这里不用这么区分，既然主进程也是进程，那么也可以看作worker，调用cluster.fork().send(message)就可以向子进程发送信息，同样监听信息也是cluster.fork().on(&#39;message&#39;, (data) =&gt; {...})。 worker 和 process 都是相对的，如果当前执行进程是主进程就代表主进程，是工作进程就代表工作进程。 cluster代表整个集群，也就是主进程和工作进程，随着当前执行进程的变化，cluster的属性也在变化。在cluster上面绑定的事件对每个进程都起作用。cluster有一些API 是只对于主进程或只对于工作进程的，例如只能在主进程而不能在工作进程中调用的：fork、cluster.workers等，只能在工作进程不能在主进程调用的：cluster.worker等。 跟上面child_process模块不一样的是，cluster.fork()只有增加进程环境变量的参数(一般是不带的)，没有要执行文件路径的参数，因此像上面代码那样主进程做的事和工作进程做的事写在同一文件(if-else语句里)是合理的。","tags":[{"name":"node","slug":"node","permalink":"http://realtcg.com/tags/node/"},{"name":"node基础","slug":"node基础","permalink":"http://realtcg.com/tags/node基础/"}]},{"title":"node核心特性理解","date":"2017-10-14T14:03:16.000Z","path":"2017/10/14/node核心特性理解/","text":"node是在前端领域经常看到的词。node对于前端的重要性已经不言而喻，掌握node也是作为合格的前端工程师一项基本功了。知道node、知道后端的一些东西，才能更好的与别人合作，发挥更大的价值。 概述本文主要介绍了我对node的一些核心特性的理解，包括node架构、特点、机制、核心模块与简单应用。 正文从浏览器到node首先，node是一个平台，使用javascript作为编程语言，运行在服务端。服务端语言能做的，node一般都能做，而且有些情况下做的更好，因为它具有自己的特色。 node是javascript运行环境（runtime），就像浏览器一样，是一个平台。在浏览器中，V8引擎负责解释javascript，你在javascript调用的接口都是浏览器实现并提供的，浏览器会调用底层的、由其他语言（C++）实现并封装好的接口来完成任务；同样，在node中，也是V8引擎负责解释javascript，而你在javascript调用的浏览器提供的接口就不能用了，因为它脱离了浏览器的环境，但是因为你在node环境中，你就可以使用node提供的由C++语言实现的、由javascript封装好的各种接口来完成后端任务。浏览器提供的API用于处理前端任务，比如弹个窗，换个主题，处理用户操作等，而node因为服务后端，因此提供的API则用来处理后端任务，比如响应请求，读取文件等，这些API由不同的模块提供。因为关注领域不一样，因此所做的任务就不一样，提供的API就不一样，但是原理、相关实现大致与浏览器端相同。 从浏览器到node这一块如果想了解更多，推荐IBM的文章node.js到底是什么？ node 架构node架构分为三层（参考链接）： 图片来源 Node standard library：node标准库，也就是node模块提供各种接口的javascript实现，任何javascript代码、npm install 或者你写的模块都在这里 Node bindings：包括C/C++ bindings（胶水代码）和Add on（添加其他C/C++库时需要自己写的Bindings），这一层向下封装了V8和libuv接口，向上提供了基础API接口，是连接javascript和C++的桥梁 第三层是支撑 Node.js 运行的关键，由 C/C++ 实现。 V8 是Google开发的JavaScript引擎，提供JavaScript运行环境，可以说它就是 Node.js 的发动机，负责解释javascript，与chrome浏览器相同。 Libuv 是专门为Node.js开发的一个封装库，提供跨平台的异步I/O能力，负责node运行时的线程池调度。 C-ares：提供了异步处理 DNS 相关的能力。 http_parser、OpenSSL、zlib 等：提供包括 http 解析、SSL、数据压缩等系统底层的访问。 平常我们用到的也就是第一层node各个模块实现的接口。 那他们之间时如何协作的呢 程序启动，V8引擎会首先解析javascript代码，通过Node bindings来调用C/C++库。执行到当前事件时，会把事件放在调用堆栈（stack和heap）处理（可以理解为放进一个工作空间，如上图），在堆栈中的任何I/O请求都会交给libuv来处理，libuv维持一个线程池，里面是一些工作线程(如下图)，请求会调用这些线程来完成任务，这些线程则调用底层的C/C++库。完成时，libuv再把结果返回事件队列等待主线程执行。在此期间，主线程继续执行其他任务。 node 执行特性单线程、非阻塞型I／O单线程的意思就是只在一个线程上运行javascript。首先，javascript 在浏览器端是单线程的，这是为了避免多线程产生任务冲突的情况；其次，java和PHP这类多线程后端语言，为避免同步I/O阻塞，每处理一个连接都会产生一个新线程，这样的话在遇到大量并发请求时就会受到物理内存的限制。node 延续了浏览器端单线程javascript，只用一个主线程执行javascript，不断循环遍历事件队列，执行事件。事实上，主线程发出的I/O请求，都会交给其他线程去完成，其他线程完成后悔返回结果放到事件队列。在此期间，主线程会继续执行其他任务，也就是在交给libuv后直接返回，继续执行下面的任务，主线程只负责循环执行事件队列，因此这种模式称为非阻塞型I／O，性能很好，适用于处理大量并发请求，还能简化开发。 事件驱动机制还是跟浏览器的差不多。总的来说就是，浏览器端把鼠标点击、键盘按键等定义为事件，而node把网络请求、I／O操作等也看作事件，严格来说，一切动作都是事件，这就是事件驱动的思想。在程序启动时，便进入事件循环，不断遍历执行事件队列中产生的事件，而在执行过程中，又会产生新的事件，因此称为事件循环。主线程执行事件时，遇到麻烦的I/O请求会交给libuv来调度其他工作线程来帮忙，忙完后就会形成事件返回结果到事件队列等待主线程处理。在此期间，主线程会继续执行其他任务。 mbp 曾经做过一个巧妙的比喻，把 Node.js 看成一家餐厅。我在此借用下他的例子，稍作修改来阐述下 Node.js 的执行情况： 把 Node.js 应用程序想象成一家星巴克，一个训练有素的前台服务生（唯一的主线程）在柜台前接受订单。当很多顾客同时光临的时候，他们排队（进入事件队列）等候接待；每当服务生接待一位顾客，服务生会把订单告知给经理（libuv），经理安排相应的专职人员去烹制咖啡（工作线程或者系统特性）。这个专职人员会使用不同的原料和咖啡机（底层 C/C++ 组件）按订单要求制作咖啡或甜点，通常会有四个这样的专职人员保持在岗待命（线程池），高峰期的时候也可以安排更多（不过需要在一早就安排人员来上班，而不能中午临时通知）。服务生把订单转交给经理之后不需要等着咖啡制作完成，而是直接开始接待下一位顾客（事件循环放进调用堆栈的另一个事件），你可以把当前调用堆栈里的事件看成是站在柜台前正在接受服务的顾客。 当咖啡完成时，会被发送到顾客队列的最后位置，等它移动到柜台前服务生会叫相应顾客的名字，顾客就来取走咖啡（最后这部分在真实生活中听起来有点怪，不过你从程序执行的角度理解就比较合乎情理了）。 ​ ——By Amio 如果你想进一步了解javascript 事件驱动机制，推荐深入理解 javascript 事件循环机制 node 模块node 模块机制是CommonJs 的实现。起初，javascript 标准一片混沌，并没有其他成熟语言（例如C++）的模块机制、标准库、接口等，为了让javascript 具备开发大型应用的能力，为了让 javascript 能在后端运行，CommonJS 就制定了javascript 模块规范。node 借鉴了这个规范，让javascript 以模块形式组织起来。模块机制是一个成熟语言必备的，一个模块代表一个功能的封装，它就像搭积木一样，不同模块可以衔接在一块，使语言具有极强的可扩展型。node 模块机制同时制定了模块规范，能让全球的开发者都可以在node官网上传自己的包。此外，node 社区又实现了node 包管理器npm，使用npm可以轻松管理各种包。 node 的模块分为核心模块和用户模块，前者是底层的、自带的，后者是第三方。 核心模块有Global(全局对象)、Http、fs(文件系统)、Buffer、Stream、Events、URL、path等，这些模块提供了后端服务的基本功能，都提供自己关注功能的API。 在使用模块时，require 即可。但在require背后，node 有一套寻找模块的机制： 从上图可以看到，node 优先从缓存区读取，缓存区有直接读取，没有则加载并缓存，这样做不用一遍一遍去找了，非常高效。node 在缓存区没有发现模块时，会分析require 的路径和文件后缀，node 有个模块路径的查找策略，我们可以在名为module_paths 的js文件里console.log(module.paths)然后node module_paths.js运行来间接查看node 寻找文件模块的具体文件的方式： 123456[ '/home/username/nodeProject/node_modules', '/home/username/node_modules', '/home/node_modules', '/node_modules' ] //Linux下的数组输出(/home/username因电脑不同而异)[ 'c:\\\\nodeProject\\\\node_modules', 'c:\\\\node_modules' ] //Windows 也就是按照下面的顺序： 当前文件目录下的node_modules目录。 父目录下的node_modules目录。 父目录的父目录下的node_modules目录。 沿路径向上逐级递归，直到根目录下的node_modules目录。 这些顺序都是在查找缓存之后的。 在找到模块后，node 将在引入之前对这个模块进行编译执行，编译成功后会缓存，执行的结果会返回给调用者。 简单应用有了node 自带核心模块的基础功能，就可以进一步封装更强大、容易操作的功能了，就像jQuery 对于javascript 基础API 一样，node 社区也诞生了像 Express、KOA等框架来构建node.js程序 这些框架的详情移步2017 Node.js 开发框架比较 另外，node 还可以连接MySQL，MangoDB进行数据库操作。 下面是使用express 脚手架生成的基本 node应用结构： 1234567891011121314151617.├── app.js //程序入口├── bin│ └── www //二机制文件├── package.json //项目配置文件├── public│ ├── images │ ├── javascripts│ └── stylesheets│ └── style.css├── routes│ ├── index.js //路由文件入口│ └── users.js└── views ├── error.jade //界面模板 ├── index.jade └── layout.jade 现在使用 node作为后端语言通常都要配合类库和框架使用。 node 的单线程、非阻塞型特点让它非常适合高并发的应用，适合处理大量重复的、简单的逻辑，适合构建Rest/JSON API服务；同时，也正是因为这些特性，node 不适合CPU使用率较重、IO使用率较轻的偏计算应用。缺点是因为单线程，一个进程挂就全挂了，可靠性低，但这是可以避免的。node 更多的应用是在前端、中间件、前后端分离等。 由于 node 的诸多优点，现在越来越多大公司开始使用node、深度使用node。 总结node 的核心概念、思想远不止这么多，应用更是多了去了，无奈本人水平有限，只能说个浅层，还有很多像进程管理、异步编程、异常调试、部署、性能调优、与集群、CDN协调等都值得深入探索一下。无论如何，node 是让javascript 迈向企业级开发语言重要的一步（也许已经是了），前端工程师从未像现在这样的powerful，能做的事情越来越多，所能涉及的领域也越来越多。前端这行越来越令人兴奋了。","tags":[{"name":"node","slug":"node","permalink":"http://realtcg.com/tags/node/"},{"name":"node基础","slug":"node基础","permalink":"http://realtcg.com/tags/node基础/"}]},{"title":"我对前端工程师这个职业的看法","date":"2017-09-26T16:01:56.000Z","path":"2017/09/27/我对前端工程师这个职业的看法/","text":"最近刚刚实习结束回到学校，陆续见到了很多朋友和同学。在与他们的交谈中，很多都会问我实习时在做什么，这时，我就很不好意思地、委婉地说，我主要的工作是用编程来实现产品需求。然后他们就会说：哦！原来就是敲代码，码农啊！ 为什么我会很不好意思、要委婉着说，就是因为我每次只要说我在做编程，都被他们冠以程序猿、码农的称号，而且我感觉他们的脑海里也浮现出天天熬夜加班、熊猫眼、凌乱头发、屌丝一样的画面。 我就会感觉我很冤，我就会感觉他们误解很深，我就会感觉很失落。 这个行业不是外行人想的那样，网上说程序员天天熬夜加班、熊猫眼、凌乱头发、屌丝一样等等，这之中有一部分是程序员自黑，有一部分是真的，但只是一小部分、条件差的情况，这个每个行业都有啊。我认识的这个行业的人，有一部分在BAT这样的大公司上班，有一部分是在C／D轮公司上班，还有在创业公司上班。大公司几乎都是每天10点上班，6点下班，周末双休；创业公司可能比较忙，但也不会强制天天熬夜加班，而且上班时间不打卡，是自由的。我之前实习时，我对面的一位同事每天11点来。工资福利就不用说了，其他行业很少能比的。 这个行业工作内容确实有点枯燥（对外行人来说），大部分时间面对的是机器，不是人。但也不能一概而论，尤其是前端这个方向，需要经常跟产品、设计、后端同学交流，因为前端所处的是一个承上启下的位置。而且还有很多活动，比如开会、讨论方案、团建什么的，交流还是挺多的。 不像教师、医生那么受人尊敬，不像金融、管理那么高大上，但是我认为这个新兴的行业在未来会同样值得人尊敬。代码改变了世界。我们用代码教会了机器像人一样思考，我们也是老师；我们用代码识别了患者体内异常的情况，我们也是医生；我们还能让代码运行在每个人的移动设备上，连接每个人，赋能每个人，服务每个人，能让你足不出户, get everything。哦，by the way, 还顺便帮助人类登上了月球…你看见的，看不见的，也许都有我们的努力，你口中的码农都有崇高的理想，他们不在乎吃穿，不在乎外貌，他们正在通过自己的努力，通过自己的方式，改变着世界。乔布斯、扎克伯格、李彦宏、雷军等科技界大佬，都是编程过来的。我不觉得这个工作有什么枯燥的地方，就算有，想想它给人们带来的便利，想想它将服务亿万用户，想想就激动。 前端工程师，这个我热爱的职业，我就更想说一下了。这个职业面向用户，工作内容相对后端和其他编程领域的职业更加人性化、更加丰富多彩。我一直把这个职业视作一个魔术师，它把产品经理脑海里的想法、设计师的设计稿变成了现实，变成了可操作、可以服务每个人的、绚丽多彩、体验友好的web／APP产品。给人便利，给人信息、给人视觉、体验上的享受。所以，我一直觉得，好的web产品除了服务、传递信息，还应该给人良好的用户体验、完美的视觉体验，给人以舒服流畅的操作、美的享受，这才符合魔术师的职业素养。 前端近几年发展比其他领域要快很多，前端能做的事情也越来越多——前端、后端、移动端、嵌入式设备、VR、动画、甚至深度学习，前端都能做。我感兴趣的方向是图形、动画、webGL、甚至VR等方向，因此我觉得将来自己还是个动画师，设计师…这一切的工作，都伴随着美，都在与美打交道，何谈枯燥呢？ 我不再花费力气去劝说那些不了解这行却以为自己了解、带有偏见的人了，我热爱我从事的工作，管他们怎么说呢。","tags":[{"name":"前端工程师","slug":"前端工程师","permalink":"http://realtcg.com/tags/前端工程师/"},{"name":"职业规划","slug":"职业规划","permalink":"http://realtcg.com/tags/职业规划/"}]},{"title":"浏览器中的事件循环机制","date":"2017-09-21T08:23:17.000Z","path":"2017/09/21/浏览器中的事件循环机制/","text":"网上一搜事件循环, 很多文章标题的前面会加上 JavaScript, 但是我觉得事件循环机制跟 JavaScript 没什么关系, JavaScript 只是一门解释型语言, 方便开发和理解的, 由V8 JIT将 JavaScript 编译成机器语言来调用底层, 至于浏览器怎么执行 JavaScript 代码, JavaScript 管不着也不关心. 因此, “JavaScript事件循环机制”这种说法是不合理的. 事件循环机制是由运行时环境实现的, 具体来说有浏览器、Node等. 这篇文章就先来说说浏览器中实现的事件循环机制. 正文首先，javascript 在浏览器端运行是单线程的，这是由浏览器决定的，这是为了避免多线程执行不同任务会发生冲突的情况。也就是说我们写的javascript 代码只在一个线程上运行，称之为主线程（HTML5提供了web worker API可以让浏览器开一个线程运行比较复杂耗时的 javascript任务，但是这个线程仍受主线程的控制）。单线程的话，如果我们做一些“sleep”的操作比如说： 1234var now = + new Date()while (+new Date() &lt;= now + 1000)&#123;//这是一个耗时的操所&#125; 那么在这将近一秒内，线程就会被阻塞，无法继续执行下面的任务。 还有些操作比如说获取远程数据、I/O操作等，他们都很耗时，如果采用同步的方式，那么进程在执行这些操作时就会因为耗时而等待，就像上面那样，下面的任务也只能等待，这样效率并不高。 那浏览器是怎么做的呢? 我们找到WHATWG规范对Event loop的介绍: 为了协调事件，用户交互，脚本，渲染，网络等，用户代理必须使用事件循环。 事件循环的主要机制就是任务队列机制: 一个事件循环有一个或者多个任务队列（task queues）。任务队列是task的有序列表，task是调度Events，Parsing，Callbacks，Using a resource，Reacting to DOM manipulation这些任务的算法; 每个任务都来自一个特定的任务源（task source）(比如鼠标键盘事件)。来自同一个特定任务源且属于特定事件循环的任务必须被加入到同一个任务队列中，来自不同任务源的任务可以放在不同的任务队列中; 浏览器调用这些队列中的任务时采取这样的做法: 相同队列中的任务按照先进先出的顺序, 不同的队列按照提前设置的队列优先级来调用. 例如，用户代理可以有一个用于鼠标和键盘事件的任务队列（用户交互任务源），另一个用于其他任务。然后，用户代理75%概率调用键盘和鼠标事件任务队列，25%调用其他队列, 这样的话就保持界面响应而且不会饿死其他任务队列. 但是相同队列中的任务要按照先进先出的顺序。也就是说单独的任务队列中的任务总是按先进先出的顺序执行，但是不保证多个任务队列中的任务优先级，具体实现可能会交叉执行 在调用任务的过程中, 会产生新的任务, 浏览器就会不断执行任务, 因此称为事件循环. microtask queue 微任务队列 还有一些特殊任务, 它们不会被放在task queues中, 会放在一个叫做microtask(微任务) queue中, 继续看标准: Each event loop has a microtask queue. A microtask is a task that is originally to be queued on the microtask queue rather than a task queue. 任务队列可以有多个, 但是微任务队列只有一个. 那么哪些任务是放在task queue, 哪些放在microtask queue呢? 通常对浏览器和Node.js来说: macrotask(宏任务): script（整体代码）, setTimeout, setInterval, setImmediate, I/O, UI rendering等 microtask(微任务): process.nextTick, Promises（这里指浏览器实现的原生 Promise）, Object.observe, MutationObserver等 请尤其注意macrotask中执行整体代码也是一个宏任务 事件循环处理过程 总体来说, 浏览器端事件循环的一个回合(go-around或者叫cycle)就是: 从macrotask队列中(task queue)取一个宏任务执行, 执行完后, 取出所有的microtask执行. 重复回合 无论在执行macrotask还是microtask, 都有可能产生新的macrotask或者microtask, 就这样继续执行. 用任务队列机制解释异步操作顺序 这里有一些常见异步操作: 1234567891011121314151617181920212223242526272829const interval = setInterval(() =&gt; &#123; console.log('setInterval')&#125;, 0)setTimeout(() =&gt; &#123; console.log('setTimeout 1') Promise.resolve().then(() =&gt; &#123; console.log('promise 3') &#125;).then(() =&gt; &#123; console.log('promise 4') &#125;).then(() =&gt; &#123; setTimeout(() =&gt; &#123; console.log('setTimeout 2') Promise.resolve().then(() =&gt; &#123; console.log('promise 5') &#125;).then(() =&gt; &#123; console.log('promise 6') &#125;).then(() =&gt; &#123; clearInterval(interval) &#125;) &#125;, 0) &#125;)&#125;, 0)Promise.resolve().then(() =&gt; &#123; console.log('promise 1')&#125;).then(() =&gt; &#123; console.log('promise 2')&#125;) 结果(Chrome 63.0.3239.84; Mac OS): 12345678910promise 1promise 2setIntervalsetTimeout 1promise 3promise 4setInterval // 大部分情况下2次, 少数情况下一次setTimeout 2promise 5promise 6 这个顺序是如何得来的? 我们先讲promise 4后面只出现一次setInterval的情况, 画个图简单表示一下这个过程: 注意 本图为了方便把各时间段(Cycle)队列的任务都画在队列中去了, 实际上执行一个task 和 microtask 后就会把这个任务从相应队列中删除 首先, 主任务就是执行脚本, 也就是执行上述代码, 这也是一个task. 在执行代码过程中, 遇到setTimeout、setInterval 就会将回调函数添加到task queue中, 遇到 promise 就会将then回调添加到 microtask 中去. Task执行完, 接着取所有 microtask 执行, 所有microtask 执行完了, microtask queue也就空了, 接着再取task执行, 如果microtask queue为空, 没有任务, 则继续取下一个task执行, 就这样循环执行. 图中箭头就表示执行的顺序. 那么为什么promise 4后面大部分情况下出现2次setInterval, 少数情况出现1次呢? 我猜测这是因为setInterval是有最短间隔时间的(chrome下4ms左右), 这个时间不同机子、不同浏览器都有可能不一样. 代码中的参数是0, 意味着尽可能短的时间内就会产生一个task加入到 task queue中. 浏览器在执行setInterval后到执行下一个task前, 时间间隔就可能超过这个最短时间, 因此会产生一个setInterval task. 我是这样论证的: 我把含有promise5、promise6回调函数的setTimeout的时间设置大一点, 让它推迟插入task queue中: 123456789101112... setTimeout(() =&gt; &#123; console.log('setTimeout 2') Promise.resolve().then(() =&gt; &#123; console.log('promise 5') &#125;).then(() =&gt; &#123; console.log('promise 6') &#125;).then(() =&gt; &#123; clearInterval(interval) &#125;)&#125;, 10) //这里加上10ms ... 结果是promise 4后面的setInterval出现了5次, 因此我觉得promise 4后面大部分情况下出现2次setInterval、少数情况出现一次的原因就是浏览器在执行setInterval回调函数后、执行setTimeout回调函数前, 时间间隔大部分情况超过了这个最短时间. 另外, 我试着再依次加上1ms, 直到14ms——也就是加上4ms时, promise 4后面的setInterval变成了6次, 可以认为setInterval最短间隔时间在Chrome下约为4ms(不考虑机子性能、设置). Node中的奇怪结果 首先说明一下, 在Node中也体现了任务队列的机制, 但是这不是Node实现的, 这是V8实现的, 由Node调用了V8任务队列机制的API. 至于为什么是V8实现的, 我们翻翻ECMA 262 标准对 Job 和 Job queue 的介绍就可以得知 但是让人摸不着头脑的是, 这段代码在node v8.5.0下有时会出现这样的结果: 1234567891011promise 1promise 2setIntervalsetTimeout 1promise 3promise 4setIntervalsetTimeout 2setInterval // 为什么会出现setInterval???promise 5promise 6 按理说应该是setTimeout 2 =&gt; promise 5 =&gt; promise 6, 因为输出setTimeout 2的回调函数是task, 执行完这个task后应该调用microtask 输出promise 5 =&gt; promise 6啊? 很奇怪! Node对V8确实有些改动, 不知道是不是这方面原因… 还请大神解惑! 你竟然读到这了总结一下: 学习技术还是有捷径的, 那就是读标准 ;)","tags":[{"name":"事件循环机制","slug":"事件循环机制","permalink":"http://realtcg.com/tags/事件循环机制/"}]},{"title":"面试&实习心得","date":"2017-09-19T15:15:13.000Z","path":"2017/09/19/面试-实习心得/","text":"从大二下学期放暑假开始（7.14）到8月初，我一直在寻找一份实习，锻炼一下自己，看看学的怎么样。这期间，我相继面试了小米、途牛、滴滴和百度，都拿了实习offer。其中百度拿了两次实习offer，但由于我自身一些原因，都爽约了。（在这里给百度真诚地道个歉，我非常珍视这两次机会，但无奈遇到了不可抗拒的原因，今后有机会还会再投的(˶‾᷄ ⁻̫ ‾᷅˵)）最后选择了在滴滴实习，很难得的经历。实习期间一直没空闲下来分享一下，结果拖到了现在…那么这篇文章就来分享一下我的面试和实习心得吧 面试有一些记不清了，毕竟时间太久了… 小米 说一下你的前端学习经历 css左右边固定宽，中间自适应，有几种方案 css3动画，transition属性知多少 说说你是如何配置你项目里的webpack 如何判断变量是true or false 数组去重，要求时间复杂度为O(n) http状态码，304什么情况 跨域方法 其他想不起来了… 途牛 typeof 都返回哪些类型 typeof null 返回什么，为什么？ cookie和session有什么区别 有没有实际写过、解决过跨域相关问题 使用过ES6／7哪些特性 说说 promise 几个常用API和原理 React的特性，接着问原理，接着问好在哪里 堆和栈的区别 其他想不起来了… 滴滴 React技术栈做项目用到了哪些东西 React特性、virtual dom、diff 、合成事件、调和等原理 为啥要给列表类组件设个key? 读过React源码吗？ 使用过哪些状态管理库，我说Redux，接着问Redux 是如何管理React 的，你又是如何使用Redux架构你的项目的 Redux 有哪些优缺点 了解数据可视化吗？做过之类的东西没有？ 了解node吗 其他记不起来了…总之都是围绕React技术栈来问的，上来就问框架很显然想让你进来直接干活：） 百度（地图事业部） 你在滴滴实习，为啥要来百度？（blablabla…夸了百度一番） 你在滴滴做什么东西？用了什么东西（数据可视化，还用了你们的echarts呢(/ω＼)） 那你知道echarts有哪些可以优化的地方？读过它的源码吗？ React 特性、原理，React 突出的思想 你是如何使用Redux架构技术栈的 我看你用了Redux-saga，它比thunk、promise有啥好处？ 你使用过哪些ES6 新特性、promise原理 跨域的几种方法 你这个项目有没有遇到什么你觉得难的问题，你怎么解决的？ 你有啥想问我的？（一般问部门技术栈、工作氛围） 其他记不起来了… 百度（校园品牌部） 介绍一下前端经历 你平常如何用css管理页面布局的，我说栅格，又问栅格怎么实现的 css3动画、transition、transform，canvas、svg sass跟less的区别？ javascript 有哪些特性，我说了弱类型、单线程、事件驱动，就有了下面的 你怎么理解事件驱动机制的？ 用过事件委托吗？怎么用的？ 嗯…ES6 用过哪些新特性？我提到了箭头函数，于是就问 箭头函数跟ES5匿名函数有什么区别？我提到了this指向，然后就接着问 箭头函数自动绑定this原理是什么？ 嗯…你这个项目怎么配置webpack的？用过gulp吗？webpack跟gulp有啥区别？ React 突出的特性 怎么用git建立一个远程分支 Linux命令知多少？ 怎么把一个链表倒序？ 其他记不清了…. 总结 总的来说，由于面试的特殊时期，面试难度会比春招实习、校招要低很多。 面试会围绕你的简历来问，所以简历写好并且为简历做好准备很重要。 面试大多问的是基础，而且问的很细，经常围绕一个点来深挖，还会问一些经常用到的API，所以面试一定要准备，把一些零碎的知识温习一下，基础很重要。项目问的比较少，但项目决定你简历的质量。 前端要掌握的知识面比较广，但是有一些是构建工程所必须的，最好先培养自己比较全面的基础技术栈，可以足够形成构建一般工程项目的基本能力，然后再深挖。 照目前情况来看，深入理解一门框架是很有必要的，但也没必要多。 前端面试算法问题问的较少(大公司问的较多)，但别告诉我你不知道查找、排序、去重、遍历二叉树… 面试一定要保持平和心态，抱着我已经拿到BAT offer的心态，不紧不慢的交谈，用眼神、肢体语言帮助嘴巴说话；择机展示思考的过程，全程展示对这行的热情。 祝愿大家都能找到心仪的实习、工作。 实习我在滴滴实习了一个多月就走了，原因是学校课太多，导员不让出去，我也意识到了现在还是以学业为重… 实习期间，我参与了两个项目，一个是一个滴滴实时计算平台，另一个是 Druid 管理平台。 实时计算平台，面向滴滴内部工程师，是一个依靠滴滴海量数据完成实时计算、任务调度、自动报警监控等等，项目很大，做了一年了，业界少有吧….我所做的是将我负责的部分数据可视化及国际化； Druid 管理平台，仍面向内部工程师，是一个可视化数据库管理平台，前端由我和另一位实习生负责。我做的是一期核心模块的开发。 最大的体会就是 要对产品有极致追求，不能容忍错误，不能容忍繁琐的操作，还要兼顾所有可能的操作 体会到了海量数据下的性能的重要性，开始关注性能优化 要抱着后台什么数据都有可能产生的考虑，来写健壮的程序，类型检查、空值检测、try catch是必要的 做好渐进增强、功能解耦、组件分离很能体现一个人的编程能力和水平，最忌讳代码粘一块、写死，坑的都是自己,,, 调试很重要，要有写debugger的习惯 时刻准备迎接新技术，哪怕从未听说，只要项目需要，就得立刻上手(我所在的组还是很喜欢用新技术的，只要它好用，License符合) 前后端分离的接口文档遵循规范能少说很多废话 项目管理，敏捷开发是很好的方式 我所在的组开发项目的流程一般是：老大不知道从哪弄来一个需求(可能上级安排的，很多是自己想的…)，然后全员开会说需求、定任务，各成员写排期，后端定具体需求、接口，前端配合后端一同开始，每周报告任务进展… 对前端er来说，改需求不用那么在意，我们最终的目的都是让这个产品更好不是吗？ 实习生很少会接触to C产品，做的大多是面向内部人员，因为出bug好商量嘛… 我所在的部门女工程师还是挺多的，这个的确让我很惊讶(No Offense)… 想到再补充(/ω＼) 这次实习，确实比自学效率高多了，而且最重要的是，开阔了眼界，了解了这行业前沿是个什么情况，大公司又是如何部署前端技术栈开发项目的，以及我自身的不足。我也很幸运，找到了自己感兴趣的方向。","tags":[{"name":"实习","slug":"实习","permalink":"http://realtcg.com/tags/实习/"},{"name":"面试题","slug":"面试题","permalink":"http://realtcg.com/tags/面试题/"}]},{"title":"dva值得一试","date":"2017-08-25T13:30:07.000Z","path":"2017/08/25/dva值得一试/","text":"前言使用React技术栈管理大型复杂的应用往往要使用Redux来管理应用的状态，然而随着深度使用，Redux也暴露出了一些问题。如编写页面配套（action、reducer）过于繁琐、复杂，组件之间耦合较深、不够扁平化、调用action creator发起动作破坏action纯洁性且必须层层传递等。这些缺点迫使使用Redux的人开始探索好的架构方式，解决或减轻使用Redux的问题。业界标杆阿里为此推出了dva 和 Mirror两种改良Redux的架构方案，不过这两者类似，本文就介绍一下dva。 概述本文介绍了dva的产生背景，dva是什么，用来做什么，解决了什么问题，使用场景，原理，实践以及我的使用心得。 背景Redux 文档中介绍，我们需要编写页面的action creator来提交，需要写reducer来更新state，最好对action 和 reducer 做页面为单位的分割，利用redux 给的API 构建容器组件包裹父组件来connect store拿到数据，然后再向下传递给functional component 来渲染，整个过程就实现了单向数据流。当应用复杂起来，一般的做法是配合react-router 做页面分割，光这个分割，你就得 做redux store 的创建，中间件的配置，路由的初始化，Provider 的 store 的绑定，saga 的初始化，还要处理 reducer, component, saga之间的联系…这个没办法，Redux就这么复杂；但是每个页面下要有自己对应的action、reducer，一般还会有saga，这样的话每个页面下都要有四五个文件目录（还有components、containers），每个文件目录下估计还要有不同功能的action、reducer、saga…如果这能忍的话，你在组件里发起action有两个方案，第一：调用经过层层传递的action creator 或者 sagas，第二，让saga监听action，再在组件里直接dispatch相应action类型就行了，不用层层传递，但是得提前 fork -&gt; watcher -&gt; worker…..真的是非常复杂，容易出错。 dva 是什么dva名字取自游戏守望先锋里的一个驾驶机甲的韩国英雄叫dva，大概含义就是Redux的机甲吧… 确实, dva 是基于现有应用架构 (redux + react-router + redux-saga 等)的一层轻量封装，没有引入任何新概念，全部代码不到 100 行。( Inspired by elm and choo. ) dva 帮你自动化了Redux 架构一些繁琐的步骤，比如上面所说的redux store 的创建，中间件的配置，路由的初始化等等,没有什么魔法，只是帮你做了redux + react-router + redux-saga 架构的那些恶心、繁琐、容易出错的步骤，只需写几行代码就可以实现上述步骤，它解决了背景所说的所有缺点。dva介绍 此外，dva重要的特性就是把一个路由下的state、reducer、sagas 写到一块了，清晰明了 12345678910111213141516171819202122232425262728293031323334app.model(&#123; namespace: 'products', //分割的路由，对应要combine到root Reducer里的名字，这里就是state.products state: &#123; //这个路由下初始state list: [], loading: false, &#125;, subscriptions: [ //用来监听路径变化，这里就是当路由为products时dispatch一个获取数据的请求 setup(&#123; dispatch, history &#125;) &#123; return history.listen((&#123; pathname &#125;) =&gt; &#123; if (pathname === 'products') &#123; //dispatch(&#123; type: 'getUserInfo', payload: &#123;&#125; &#125;); &#125; &#125;); &#125;, &#125;, ], effects: &#123; //saga里的effects，里面的各种处理异步操作的saga ['products/query']: function*() &#123; yield call(delay(800)); yield put(&#123; type: 'products/query/success', payload: ['ant-tool', 'roof'], &#125;); &#125;, &#125;, reducers: &#123; // reducers ['products/query'](state) &#123; return &#123; ...state, loading: true, &#125;; &#125;, ['products/query/success'](state, &#123; payload &#125;) &#123; return &#123; ...state, loading: false, list: payload &#125;; &#125;, &#125;,&#125;); dva的思想官方文档 dva就是把之前Redux每个路由下的state、reducer、sagas写到一块去了，做了写到一块去也能做到以前redux能做的事，并且让思路变得很清晰 ： 每个路由下都有一个model，这个model掌管这个路由的所有状态（action、state、reducer、sagas），组件想改变状态dispatch type名字就行了。 实践搞懂框架的脚手架是快速上手这个框架的一个好方法，下面是dva-cli 项目架构123456789101112131415161718.├── src ├── assets # 图片、logo ├── components # 公用UI组件 ├── index.css # CSS for entry file ├── index.html # HTML for entry file ├── index.js # 入口文件 ├── models # 这里存放的就是上面说的dva的model，最好每个路由一个model ├── router.js # 路由文件 ├── routes # 路由组件，跟Redux相同 ├── services # 每个页面的services，通常是获取后端数据的接口定义 └── utils # 存放一些工具 └── request.js # 这里封装一个用来与后端通信的接口├── .editorconfig #├── .eslintrc # Eslint config├── .gitignore #├── .roadhogrc # Roadhog config└── package.json # 按照dva的架构，每个路由下都有个model层，在model定义好这个路由的initialstate、reducers、sagas、subscriptions；然后connect组件，当在组件里发起action时，直接dispatch就行了，dva会帮你自动调用sagas/reducers。当发起同步action时，type写成&#39;(namespace)/(reducer)&#39;dva就帮你调用对应名字的reducer直接更新state，当发起异步action，type就写成&#39;(namespace)/(saga)&#39;,dva就帮你调用对应名字的saga异步更新state，非常方便： 在组件里： 12345678...const &#123; dispatch &#125; = this.propsdispatch(&#123; type: 'namespace/sagas', //这里的type规范为model里面定义的namespace和effects下面定义的sagas或者 payload: &#123; // reducers,这样就能实现自动调用这些函数 ... &#125;&#125;) 注意，dispatch用来更新state某个数据后，下一步从state拿到的这个数据并不是更新后的： 12345678910... const &#123; dispatch, data &#125; = this.props dispatch(&#123; type: 'namespace/sagas', //这里的type规范为model里面定义的namespace和effects下面定义的sagas或者 payload: &#123; // reducers,这样就能实现自动调用这些函数 data //这里想更新data &#125; &#125;) console.log(data) // 仍然是之前的数据，并不是dispatch更新后的数据 // 因为dispatch是异步的，如同React的setState后面打印state 此外，由于不用层层传递action creator，mapDispatchToProps就不用再写了，组件之间的耦合度也降低了，或者说根本没有关系了，dva使组件之间的关系变得更加扁平化,没有什么父子、兄弟关系，这样组件就具有很高的可重用性。所有需要在组件里通信的数据都要放在state中，然后connect组件，只拿到组件关心的数据，就像这样： 123456789101112131415class App extends Component &#123; ...&#125; function mapStateToProps(state) &#123; const &#123; data &#125; = state.user; // user 对应namespace const loading = state.loading.effects['user/fetch']; return &#123; data, loading &#125;;&#125;export default connect(mapStateToProps)(User); 这样写，除了具有很高的重用性，也避免了父组件更新，子组件也会随之更新的缺点了！只要这个组件关心的数据没变，它就不会重新渲染，省掉了重写shouldComponentUpdate来提高性能，逻辑也变得清晰、简单起来！ 另外，model下有个subscriptions用于订阅一个数据源，可以在这里面监听路由变化，比如当路由跳转到本页面时，发起请求来获取初始数据： 12345678910111213subscriptions: &#123; setup: (&#123; history, dispatch &#125;) =&gt; history.listen((&#123; pathname, query &#125;) =&gt; &#123; if (pathname === '/user') &#123; dispatch(&#123; type: 'fetch', payload: &#123; query &#125; &#125;); &#125; &#125;), &#125;,&#125;; 问题使用没多久，了解较浅，暂时没发现什么问题 总结dva框架封装了Redux 架构一些繁琐、复杂的步骤和常用库，使用dva，不会构建Redux架构也可以，dva帮你做好了; dva 降低了组件之间的耦合度，没有父子、兄弟组件的关系，提高了组件可重用性以及渲染性能，使思路变得简单清晰； dva架构思路清晰，代码书写方式固定，有利于团队合作，但可扩展性不强","tags":[{"name":"React","slug":"React","permalink":"http://realtcg.com/tags/React/"},{"name":"dva","slug":"dva","permalink":"http://realtcg.com/tags/dva/"}]},{"title":"对使用Redux和Redux-saga管理状态的思考","date":"2017-08-12T10:32:45.000Z","path":"2017/08/12/对使用Redux和Redux-saga管理状态的思考/","text":"概述本文介绍了我对 Redux 状态管理的思想、原理、架构方法的认识和思考以及配合redux-saga处理异步操作的实践 前言You know, React 只是属于MV*架构模式的 view 层，是一种状态机，只使用 React 难以控制大型、复杂的应用，它需要一些框架来帮助管理状态，因此如何有效、简单、易于测试地管理这个状态机是各种架构框架感兴趣的。Facebook 早就意识到这个问题并提出了 Flux 架构，比较复杂; 后来出现了 Redux、Mobx 等。MobX 可以处理简单数据流的场景，可以实现精确更新; Redux 是从 Flux 和其他框架借鉴了一些思想， 它比 Flux 简单、易于理解、用于处理复杂数据流，并具有很强的扩展性，社区诞生了像redux-thunk、redux-promise、redux-saga等中间件用于方便地处理异步操作。最近也在项目中使用了 Redux 及其中间件 redux-saga 来管理状态和处理异步操作，这篇文章就来谈谈我对它们的思考和实践。 正文Redux 思想先来谈谈背景（需求） 我觉得理解Redux的思想，谈谈MV*架构模式的思路也许会有帮助。 MV*架构模式，它们的核心都是职责分离、解耦，不同的层次做不同的事，能让一个复杂、混乱的应用变得思路清晰，代码可以复用，并且易于测试，有利于分工合作，构建更大、更复杂的应用。 一个应用要包括哪些功能？表现（view）、处理数据的逻辑（model）以及数据映射到表现层的逻辑（presenter or controller），数据在这三层之间流通（MVVM模式通过数据双向绑定实现view和model同步）。 React 根据state来render，它只是个状态机，并没有解决管理状态的问题。我们在单纯的使用React来写组件的时候，经常会遇到组件间通信和管理组件state的问题，前者常用的解决办法就是把数据提到父组件共享；后者管理state简单的情况还行，一复杂就很麻烦且容易出错，再遇到一些需要异步处理的操作，想想就头皮发麻。 当你开发中遇到一些反人类的操作时，试着去想如何改变一下思路让它变得更简单，别耐着性子安慰自己开发就是这样 :) 解决方案 Redux 正是用来解决大型React应用所面临的状态管理、数据流通、异步处理、测试、团队合作等问题： Redux 用单一的object tree来表示整个应用的state，这个表示state的对象树被放在唯一的store 中，state相当于store的快照；所有组件都会通过API拿到这个state，各取所需； Redux 把页面上用户的操作或者浏览器的行为（如路由的变化）定义为一个要更新state的action，这个action是一个普通对象，它包含了要执行动作的类别和传递到state的数据（如果有的话），它只表明要更改state的意图，相当于一个信号，并不能直接修改state，Redux会集中处理这些信号，这个action由你来决定何时发起； 定义好信号，你还需要根据不同的信号定义不同的逻辑函数（reducers）来更新state。 通过这张图来整理一下： 咳咳…比如用户点击的一个按钮，你在按钮上绑定的回调函数调用了一个（多个）action creator，action creator就返回了一个更新state局部数据的action，store会根据这个（多个）action找到对应的reducers（reducer需要做拆分），按照action发起的顺序依次执行来更新state，每个reducer只负责更新自己关心那部分，根 reducer 把多个子 reducer 输出合并成一个单一的 state 树，生成一个新的state保存在store中，store中的state可以通过相应API传递到子组件。 这就是整个数据流。 那Redux如何处理异步操作？ Redux借鉴了中间件思想，利用可扩展的中间件来改造dispatch函数。比如redux-thunk让dispatch不仅仅可以接收action，还可以接受函数作为参数，你可以在这个函数里完成异步操作。再如redux-saga更强大、也更复杂，在后面会讲到。 Redux 架构方法对于React技术栈，Redux实现了react-redux库来让Redux管理React应用（其他框架也有相应的库），里面集成了一些有用的函数来把一些明确的流程自动化，如createStore用于创建唯一store，可以把根reducer传进createStore使store自动调用对应reducer，可以扩展中间件；提供&lt;Provider store&gt;组件和connect高阶组件用来包裹render component并传递state，connect还能自动dispatch，让你只要调用action creator就能dispatch；提供combineReducers来组合分割的reducers等。 知道这些特性，就可以配合react-router构建大型应用了： 总的思路就是：利用react-router 把应用分割为各个页面，reducer、action creator也跟随页面分割而分割。每个路由对应的页面下都有components和containers，分别存放functional components 和class components，前者用来渲染，后者当做containers被connect包裹，containers包裹components；containers从connect得到state并映射需要的数据到子组件的props，子组件再向下传递。 具体如何构建React + Redux + react-router，我在另一篇博客里讲了。 使用这种架构，开发大型应用变得得心应手。 Redux 存在的问题但是当我深入项目开发的时候，也逐渐发现了一些问题： 这种架构项目结构不够扁平化，文件嵌套比较深，思路比较复杂，搭建、写起来比较麻烦，上手有难度； 由于所有action creator都定义在页面层次上，让子组件调用必须一层一层的传递，很麻烦且非常容易出错，也很难调试； state难以做到局部更新（这个可以用reselect） Redux只是传递了一种思路，定义了几个简单的API，很灵活，架构方式不固定，设计方式不固定（如：如何设计state树）但这也是它的缺点，新人往往看完一遍还是不知道怎么做，对新人不友好 总之，redux可以胜任复杂数据流的应用，但是也比较难，前期架构比较麻烦，适合有经验的人。 使用redux-saga处理异步操作Redux 倡导action 和reducer尽可能”纯净”，没有什么“副作用”。可是像一些异步操作比如获取数据是必须的，在哪处理这些副作用呢？redux 把这些”不纯净的”任务交给了中间件，通过 向createStore里应用中间件，在交由store处理action之前就可以对其完成一些其他的操作： 而redux-saga 是Redux一个强大但并不复杂的用于异步处理的中间件。 它的思路是什么？相比其他redux异步中间件如redux-thunk、redux-promise有什么不同？ 先看名字来理解：saga，这个术语常用于CQRS架构，代表查询与责任分离。 没错，就是查询（dispatch）与责任（sagas）分离。saga提供了action监听函数，只需在组件里dispatch 相应type的action，就可以自动调用你定义好的对应这个action的异步处理函数（sagas）来完成任务，保证了只在组件里dispatch action来发起异步操作而不是redux-thunk、redux-promise的调用action creators。 另外一大特色就是redux-saga做到了异步代码以同步方式写，非常直观方便，怎么做到的呢？它是利用了ES6新魔法Generator迭代器，可以完美解决异步回调地狱，让你以同步方式写异步。saga正是利用Generator特性让其处理异步变得非常方便又容易理解。这是一个常见的请求后台数据的异步操作，感受一下： 1234567891011121314151617function *fetchNodeDetailByNodeId(&#123; payload: &#123; nodeId &#125; &#125;, &#123; call, put &#125;) &#123; try &#123; const &#123; data, status &#125;= yield call(fetchNodeDetailByNodeId, nodeId) if (data &amp;&amp; status.errmsg === 'success') &#123; yield put(&#123; type: 'setStates', payload: &#123; nodeDetailData: data, &#125;, &#125;); &#125; else &#123; message.info('开了个小差,再试一次吧..'); &#125; &#125; catch (error) &#123; console.log(error); &#125; &#125;, call 和 put 是saga的API，相当于dispatch，但是并不是真正执行dispatch，只是发送你指定的指令，交由saga中间件来执行这个指令。这样看来，这个saga函数就是一些指令的集合，称为effects，副作用，用来描述任务 为啥要描述指令而不直接调用呢？这样是因为易于测试，如果直接调用，你还得模拟调用的函数，详见redux-saga文档。 我觉得redux-saga相比于其他中间件的优点： 查询与责任分离，保证了action的纯洁性，符合redux设计思想 实现以同步方式写异步操作，容易理解，逻辑清晰 通过发送指令而不是直接调用让异步操作变得容易测试 监听、执行自动化 提供了丰富强大的指令来完成复杂的操作，比如无阻塞调用，同时执行多个任务等 讲道理，任何redux异步操作都可以让saga这个中间件来完成，非常复杂的同样可以胜任，并且很容易理解（异步操作以同步方式写）和测试。再配合dva，可以减轻redux的复杂度同时完成更强大的功能。 这样以来，redux配合saga，就可以让它们各司其职，整个思路也变得清晰起来： redux 倡导action和reducer要纯洁，那就让所有异步操作这些不纯洁的任务交给saga，reducer不用变，还是纯函数；定义好对应action的sagas专门用来处理异步操作，我只要在组件需要的地方里dispatch 纯action就行了，符合redux设计思想。 总结使用redux来管理应用状态适用于复杂的应用，而复杂的应用会有复杂的异步处理，异步处理不要用redux的action creator，它不是用来做这个的，也违背了redux设计思想，redux把这些任务交给了异步中间件，应该由它们来完成。使用redux saga是一个推荐的选择，它懂redux，也懂你需要什么。另外，既然你用到了saga，不妨试试dva架构，5分钟上手，值得一试。","tags":[{"name":"Redux","slug":"Redux","permalink":"http://realtcg.com/tags/Redux/"},{"name":"Redux saga","slug":"Redux-saga","permalink":"http://realtcg.com/tags/Redux-saga/"}]},{"title":"对React一些原理的理解","date":"2017-06-25T09:12:58.000Z","path":"2017/06/25/对React一些原理的理解/","text":"前言随着项目开发的深入，不可避免了遇到了一些问题。刚开始出现问题时很懵，不知道该怎么解决，原因就是对React的原理理解的不够透彻，不知道问题出在哪。在解决问题的过程中，也逐渐深入了解了React的一些原理，这篇文章就来分享一下我对React一些原理的理解。 注意 这篇文章并不是教程，只是我对React原理的一些个人理解，欢迎与我一起讨论。文章不对的地方，还请读者费心指出^-^ 概述本文是《使用React技术栈的一些收获》系列文章的第二篇(第一篇在这里，介绍如何开始构建React大型项目)，简单介绍了React一些原理，包括React合成事件系统、组件的生命周期以及setState()。 React合成事件系统React快速的原因之一就是React很少直接操作DOM，浏览器事件也是一样。原因是太多的浏览器事件会占用很大内存。 React为此自己实现了一套合成系统，在DOM事件体系基础上做了很大改进，减少了内存消耗，简化了事件逻辑，最大化解决浏览器兼容问题。 其基本原理就是，所有在JSX声明的事件都会被委托在顶层document节点上，并根据事件名和组件名存储回调函数(listenerBank)。每次当某个组件触发事件时，在document节点上绑定的监听函数（dispatchEvent）就会找到这个组件和它的所有父组件(ancestors)，对每个组件创建对应React合成事件(SyntheticEvent)并批处理(runEventQueueInBatch(events))，从而根据事件名和组件名调用(invokeGuardedCallback)回调函数。 因此，如果你采用下面这种写法，并且这样的P标签有很多个： 12345listView = list.map((item,index) =&gt; &#123; return ( &lt;p onClick=&#123;this.handleClick&#125; key=&#123;item.id&#125;&gt;&#123;item.text&#125;&lt;/p&gt; )&#125;) That’s OK，React帮你实现了事件委托。我之前因为不了解React合成事件系统，还显示的使用了事件委托，现在看来是多此一举的。 由于React合成事件系统模拟事件冒泡的方法是构建一个自己及父组件队列，因此也带来一个问题，合成事件不能阻止原生事件，原生事件可以阻止合成事件。如果需要阻止事件传播, 仅用 event.stopPropagation() 是不行的, 因为React合成事件同样实现了stopPropagation(), 调用event.stopPropagation() 实际上调用了React的stopPropagation()(这里的event指的是React合成事件), 只能阻止React合成事件的传播, 要想彻底阻止传播(包括原生事件), 需要调用React合成事件暴露的原声事件接口, 因此, 阻止事件传播需要同时调用合成事件与原生事件的接口: 1234stopPropagation: function(e)&#123; e.stopPropagation(); e.nativeEvent.stopImmediatePropagation(); &#125;, 如果你想详细了解React合成事件系统，移步http://blog.csdn.net/u013510838/article/details/61224760 组件的生命周期（以父子组件为例）为了搞清楚组件生命周期，构造一个父组件包含子组件并且重写各生命周期函数的场景： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Child extends React.Component &#123; constructor() &#123; super() console.log('Child was created!') &#125; componentWillMount()&#123; console.log('Child componentWillMount!') &#125; componentDidMount()&#123; console.log('Child componentDidMount!') &#125; componentWillReceiveProps(nextProps)&#123; console.log('Child componentWillReceiveProps:'+nextProps.data ) &#125; shouldComponentUpdate(nextProps, nextState)&#123; console.log('Child shouldComponentUpdate:'+ nextProps.data) return true &#125; componentWillUpdate(nextProps, nextState)&#123; console.log('Child componentWillUpdate:'+ nextProps.data) &#125; componentDidUpdate()&#123; console.log('Child componentDidUpdate') &#125; render() &#123; console.log('render Child!') return ( &lt;h1&gt;Child recieve props: &#123;this.props.data&#125;&lt;/h1&gt; ); &#125;&#125;class Father extends React.Component &#123; // ... 前面跟子组件一样 handleChangeState()&#123; this.setState(&#123;randomData: Math.floor(Math.random()*50)&#125;) &#125; render() &#123; console.log('render Father!') return ( &lt;div&gt; &lt;Child data=&#123;this.state.randomData&#125; /&gt; &lt;h1&gt;Father State: &#123; this.state.randomData&#125;&lt;/h1&gt; &lt;button onClick=&#123;this.handleChangeState&#125;&gt;切换状态&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;React.render( &lt;Father /&gt;, document.getElementById('root')); 结果如下：刚开始调用父组件的setState后：在Jsbin上试试看有一张图能说明这之间的流程（图片来源）： setState并不奇怪有一个能反映问题的场景： 12345678910...state = &#123; count: 0&#125;componentDidMount() &#123; this.setState(&#123;count: this.state.count + 1&#125;) this.setState(&#123;count: this.state.count + 1&#125;) this.setState(&#123;count: this.state.count + 1&#125;)&#125;... 看起来state.count被增加了三次，但结果是增加了一次。这并不奇怪： React快的原因之一就是，在执行this.setState()时，React没有忙着立即更新state，只是把新的state存到一个队列（batchUpdate）中。上面三次执行setState只是对传进去的对象进行了合并,然后再统一处理（批处理），触发重新渲染过程，因此只重新渲染一次，结果只增加了一次。这样做是非常明智的，因为在一个函数里调用多个setState是常见的，如果每一次调用setState都要引发重新渲染，显然不是最佳实践。React官方文档里也说了： Think of setState() as a request rather than an immediate command to update the component. 把setState() 看作是重新render的一次请求而不是立刻更新组件的指令。 那么调用this.setState()后什么时候this.state才会更新？答案是即将要执行下一次的render函数时。 这之间发生了什么？setState调用后，React会执行一个事务（Transaction），在这个事务中，React将新state放进一个队列中，当事务完成后，React就会刷新队列，然后启动另一个事务，这个事务包括执行 shouldComponentUpdate 方法来判断是否重新渲染，如果是，React就会进行state合并（state merge）,生成新的state和props；如果不是，React仍然会更新this.state，只不过不会再render了。 开发人员对setState感到奇怪的原因可能就是按照上述写法并不能产生预期效果，但幸运的是我们改动一下就可以实现上述累加效果：这归功于setState可以接受函数作为参数： setState(updater, [callback]) 12345678910...state = &#123; score: 0&#125;componentDidMount() &#123; this.setState( (prevState) =&gt; (&#123;score : prevState.score + 1&#125;) ) this.setState( (prevState) =&gt; (&#123;score : prevState.score + 1&#125;) ) this.setState( (prevState) =&gt; (&#123;score : prevState.score + 1&#125;) ) &#125;&#125; 这个updater可以为函数，该函数接受该组件前一刻的 state 以及当前的 props 作为参数，计算和返回下一刻的 state。 你会发现达到增加三次的目的了: 在Jsbin上试试看 这是因为React会把setState里传进去的函数放在一个任务队列里，React 会依次调用队列中的函数，传递给它们前一刻的 state。 另外，不知道你在jsbin上的代码上注意到没有，调用setState后console.log(this.state.score)输出仍然为0，也就是this.state并未改变，并且只render了一次。 总结学习一个框架或者工具，我觉得应该了解以下几点： 它是什么？能做什么？ 它存在的理由是什么？解决了什么样的问题、满足了什么样的需求？ 它的适用场景是什么？优缺点是什么？ 它怎么用？最佳实践是什么？ 它的原理是什么？ … 通过对React一些原理的简单了解，就懂得了React为什么这么快速的原因之一，也会在问题出现时知道错在什么地方，知道合理的解决方案。","tags":[{"name":"React","slug":"React","permalink":"http://realtcg.com/tags/React/"},{"name":"React基础","slug":"React基础","permalink":"http://realtcg.com/tags/React基础/"}]},{"title":"React + Redux + react router技术栈架构","date":"2017-06-24T11:59:52.000Z","path":"2017/06/24/React + Redux + react router技术栈架构/","text":"前言前些日子刚学习了React，觉得很不错，很符合我的逻辑。于是还没弄明白，就迫不及待的开始了一个中型项目(我觉得）（其实是项目需要赶紧开始，没时间了…咳咳）。期间不出所料地遇到了很多坑和问题，也得到了很多收获，特开几篇文章记录下来。 概述本文是《使用React技术栈的一些收获》系列文章的第一篇，介绍了项目是如何架构的。 具体技术栈项目技术栈使用的是React全家桶：React+redux+react router+es6+webpack+sass以及Data到View层我们使用了reselect。由于数据处理逻辑并不复杂，因此并没有使用immutable.js和Redux saga（后来我觉得连Redux都没必要用）；样式方面考虑到可读性和开发人数较少（俩），我们并没有使用流行的CSS-module。 脚手架的选择选择脚手架就选择了整体架构，我选择的是davezuko大神的react-redux-starter-kit，也是最受欢迎的脚手架之一。并在它的基础上安装了一些用到的包，删去了一些不用的包，让它更适合我们的项目。 项目架构项目目录如下：​ 根据脚手架的架构，我们构建的是一个React单页应用。 总体来说就是采用React router plain object+combineReducer+require.ensure的写法把不同的路由分割在routes目录下，对应不同的页面，做代码分割、按需加载。逻辑图如下： 具体来说首先src目录下有一个main.js，它用来创建store，并拿到路由（plain object形式），然后注入到顶层的Provider组件和其下的Router组件： src下的main.js文件：12345678910111213const initialState = window.___INITIAL_STATE__const store = createStore(initialState)// 创建storeconst MOUNT_NODE = document.getElementById('root')let render = () =&gt; &#123; const routes = require('./routes/index').default(store)// 拿到路由 ReactDOM.render( &lt;AppContainer store=&#123;store&#125; routes=&#123;routes&#125; /&gt;, //注入 MOUNT_NODE )&#125; redux的store也随着页面分割而分割：​ 不同页面下的modules下的文件只负责本页面所需的所有action和reducer，并通过加载页面inject主reducer里，然后在src/store/reduce.js文件里combine,最后被引入到src/store/createStore里和同时引入的redux中间件一起创建store： src/store目录下的reducer.js：12345678910111213export const makeRootReducer = (asyncReducers) =&gt; &#123; return combineReducers(&#123; auth: auth, form: formReducer, location: locationReducer, ...asyncReducers // 各页面下的reducer注入到这里 &#125;)&#125;export const injectReducer = (store, &#123; key, reducer &#125;) =&gt; &#123; store.asyncReducers[key] = reducer store.replaceReducer(makeRootReducer(store.asyncReducers))//注入时更新&#125; 以及src/store下的createStore文件：12345678const store = createStore( makeRootReducer(), initialState, compose( applyMiddleware(...middleware), ...enhancers ) ) routes目录下有一个index.js文件，它使用plain object的写法集合各路由对应的页面； routes下的index.js文件：（用来包含各页面）src/routes/index.js:(采用React router plain object写法) 12345678910111213141516171819202122import CoreLayout from '../layouts/CoreLayout'import Home from './Home'import FollowRoute from './Follow'import SignRoute from './Sign'import HallRoute from './Hall'import UserPageRoute from './UserPage'import PageNotFound from './PageNotFound'import Redirect from './PageNotFound/redirect'export const createRoutes = (store) =&gt; (&#123; path: '/', component: CoreLayout, indexRoute: Home, childRoutes: [ // 各页面 FollowRoute(store), SignRoute(store), HallRoute(store), UserPageRoute(store), PageNotFound(), Redirect ]&#125;) 每个页面目录下也有一个index.js文件并使用getComponent + webpack ensure按需加载页面的container和reducer： 每个页面下的index.js文件：(负责输出这个页面)src/routes/sign/index.js（其他页面差不多，举个例子） 12345678910111213import &#123; injectReducer &#125; from '../../store/reducers'// 引入注入reducer函数export default (store) =&gt; (&#123; path: 'sign', //页面路由 getComponent (nextState, cb) &#123; require.ensure([], (require) =&gt; &#123; // webpack按需加载 const Sign = require('./containers/SignContainer').default //引入总container const reducer = require('./modules/index').default//引入总reducer injectReducer(store, &#123; key: 'sign', reducer &#125;)// 加载时注入页面reducer到主reducer cb(null, Sign)// 返回页面 &#125;) &#125;&#125;) 在每个页面下，index.js是获得每个页面的入口，每个页面都有自己的components和containers以及actions和reducers，目录看起来像这样： components和containers都是这个页面下的组件和容器，如果其他页面也会使用里面的组件和容器，就会把他们放在src/component和src/containers下共用。modules下的文件是这个页面所有的action和reducer。如果页面逻辑可以分离，会把各逻辑下的reducer抽离并单开一个index.js，并在其中combine： ​ =&gt; 总结与反思通过上述架构，项目代码逻辑变得很清晰，每一个文件都有其专属的功能，互不影响，开发过程变得工程化、流程化，思路很清晰，代码出错率大大降低，开发速度大大提高。React router plain object+redux combineReducer的组合很好的将代码按不同页面做了分割;而 getComponent + webpack ensure又做到了页面的按需加载，项目页面运行速度提升了不少。但是有一个问题，在react route4.0版本中getComponent被移除了，并提供了更加简洁的方式（实际上就是替你做了按需加载）：Bundle组件+webpack 加载器undle-loader。使用这种方式的话，目录结构将会变得更简单、更容易理解，避免了多层嵌套，因此，项目还需要改善。","tags":[{"name":"React","slug":"React","permalink":"http://realtcg.com/tags/React/"},{"name":"React架构","slug":"React架构","permalink":"http://realtcg.com/tags/React架构/"}]},{"title":"JavaScript常用函数总结(一)","date":"2017-05-12T16:00:44.000Z","path":"2017/05/13/JavaScript常用函数总结-一/","text":"前言最近在使用React技术栈时并没有选用jQuery,想借此巩固一下原生API,提高原生开发能力,毕竟这才是内功。 概述本文总结了JavaScript常用函数，这些函数包括Array常用函数以及String常用函数 JavaScript原生函数Array常用函数 isArray() -判断某个值是不是数组类型 123if(Array.isArray(value))&#123; //对数组进行操作&#125; join(&quot;分隔符&quot;) 12var a = [1,2,3,4,5]; var b = a.join(\"|\"); //a：[1,2,3,4,5] b：\"1|2|3|4|5\" 栈方法 push() -可以接受任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度： 1234var colors = new Array();var count = colors.push(\"red\",\"green\");console.log(colors);//[\"red\",\"green\"]console.log(count);//2 pop() -从数组末尾移除最后一项，减少数组length值，然后返回移除的项 123var item = colors.pop();console.log(item);//\"green\"console.log(colors.length);//1 队列方法 shift() -移除数组的第一项并返回该项，同时将数组长度减一 123var item = colors.shift();console.log(item);//\"red\"console.log(colors.length);//1 unshift() -在数组前端添加任意个项并返回新数组的长度 12var count = colors.unshift(\"yellow\",\"black\");console.log(colors);//[\"yellow\",\"black\",\"red\",\"green\"] 重排序方法 reverse() -反转数组项的顺序 12var values = [1,2,3,4,5];console.log(values.reverse());//5,4,3,2,1 sort() -默认情况下按升序排列数组项，即最小的值在前。为了实现排序，sort方法会调用每个数组项的toString(),然后比较字符串，以确定排序。即使数值项是数字，比较的也是字符串，这通常不是最佳方案，因此sort()可以接受一个比较函数作为参数，返回经过排序后的数组 1234567var values = [0,1,5,10,15];console.log(values.sort());//0,1,10,15,5function compare(value1,value2)&#123;return value2 - value1;&#125;console.log(values.sort(compare));//0,1,5,10,15 操作方法 concat() -合并数组的意思,可以接受n个字符串或数组。 123var colors = [\"red\",\"green\",\"pink\"];var color2 = colors.concat(\"bliue\",[\"black\",\"yellow\"]);//[\"red\",\"green\",\"pink\",\"blue\",\"black\",\"yellow\"] 先创建一个数组副本，然后将接受到的参数添加到副本末尾，最后返回新构建的数组，原数组不会受到影响。 slice() -切数组的意思，接受一到两个数值型参数表示切下的起始结束位置 123var colors = [\"red\",\"green\",\"pink\"];var color1 = colors.slice(1);//[\"green\",\"pink\"]var color2 = colors.slice(1,2); //[\"green\"] slice()同样不会对原数组产生影响，它会创建一个副本操作后返回。参数可以为负数。 splice() -剪接的意思，可以实现数组的删除、插入、替换。 splice(起始位置,删除的项数,插入的项(可以多个项,可选)) 返回从原始数组中删除的项,对原数组直接操作 123var colors = [\"red\",\"green\",\"pink\"];var color1 = colors.splice(0,1);//[\"green\",\"pink\"],删除第一项var color2 = colors.splice(1,0,\"black\"); //[\"green\",“black”,\"pink\"] indexOf() -返回查找的项的位置，接受两个参数，indexOf(要查找的项(可选),查找起点位置索引),它会使用===来查 1234var colors = [\"red\",\"green\"];console.log(colors);//[\"red\",\"green\"]console.log(color2);/ 迭代方法 以下每个迭代函数都会接受两个参数，一个是要在每一项运行的函数和运行在该函数的作用域对象——影响this的值，为数组的每一项运行的给定函数接受三个参数：function(数组的项,该项在对象的位置,数组本身){} every() -如果该函数对每一项都返回true，则返回true filter() -返回该函数会返回true的项组成的数组 forEach() -单纯运行给定函数，无返回值 map() -返回给定函数运行在数组中的每个项的结果组成的数组 some() -如果该函数对任一项返回true，则返回true 1234567891011121314151617181920 var values = [1,2,3,4,5]; console.log(values.every(function(item)&#123; return (item&gt;2); &#125;));//false console.log(values.some(function(item)&#123; return (item&gt;2); &#125;));//true console.log(values.filter(function(item)&#123; return (item&gt;2); &#125;));//[3,4,5] console.log(values.map(function(item)&#123; return (item*2); &#125;));//[2,4,6,8,10] console.log(values.forEach(function(item)&#123; //执行某些操作&#125;)); 归并方法 reduce() -浓缩的意思，接受一个给定函数（function(pre,cur,index,array){}）和作为归并基础的值（可选），迭代数组所有项，返回一个构建的值 1234var values = [1,2,3,4,5];console.log(values.reduce(function(pre,cur,index,array)&#123;return pre + cur;&#125;));//15 String常用函数 查找方法 字符串方法 charAt(n)返回字符串中第n(0~length-1)个字符； charCodeAt(n)返回字符串中第n个字符的Unicode编码； fromCharCode(0或多个字符的Unicode编码)返回根据字符编码创建的字符串 位置方法 indexOf(要查找的字符串,开始查找位置（可选）)返回找到的子串首次出现的索引或-1（未找到）。可以用于数组查找项，不能查找对象。 匹配方法 match(正则表达式)返回存放匹配结果的数组，正则如果没有加全局标记g那么这个数组会有个input属性，它指向调用match()的字符串对象.未找到返回null. 12345var str = \"hello,world\";str.match(\"he\");[\"he\", index: 0, input: \"hello,world\"]str.match(/he/);//[\"he\", index: 0, input: \"hello,world\"]str.match(/he/g);//[\"he\"]str.match(/l/g);//[\"l\", \"l\", \"l\"] search(正则表达式)返回字符串中第一个与正则表达式相匹配的子串的索引，忽略全局标记g和lastIndex属性 12345var str = \"hello,world\";str.search(\"he\");//0str.search(/he/);//0str.search(/he/g);//0str.match(/l/g);//2 replace(正则(字符串),替换文本或函数)创建一个原字符串副本，替代后返回 123var str = \"hello,world\";str.replace(/l/g,\"b\");//\"hebbo,worbd\"console.log(str);//\"hello,world\" split(分隔符,(数组长度))返回根据指定分隔符将字符串分割成多个子串组成的数组,这个分隔符必须是原字符串里的某个字符，否则返回原字符串 123var str = \"hello,world\";str.split(\"\");//[\"h\", \"e\", \"l\", \"l\", \"o\", \",\", \"w\", \"o\", \"r\", \"l\", \"d\"]str.split(\"o\");//[\"hell\", \",w\", \"rld\"] 操作方法 concat(string,...)返回把所有参数都连接到原字符串后形成的字符串 slice(剪切的起始位置,结束位置)返回剪切后的字符串，创建副本，原字符串不变 substring()功能与slice相同，不同的是参数不能为负 trim()清楚字符串（注意不是字符）前后的空格 编码方法 escape(string)、unescape(string)返回字符串常规编码（解码） encodeURI(string)、decodeURI(string)URI字符串编码与解码 转换方法 toUpperCase()、toLocaleUpperCase()转为大写 toLowerCase()、toLocaleLowerCase()转为小写","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://realtcg.com/tags/JavaScript/"},{"name":"JavaScript函数","slug":"JavaScript函数","permalink":"http://realtcg.com/tags/JavaScript函数/"}]},{"title":"我对JavaScript对象的理解","date":"2017-04-12T09:12:58.000Z","path":"2017/04/12/我对JavaScript对象的理解/","text":"注意 这篇文章仅仅是我个人对于JavaScript对象的理解，并不是教程。这篇文章写于我刚了解js对象之后。文章肯定有错误之处，还望读者费心指出，在下方评论即可^-^ 什么是JavaScript对象12345678910111213141516var person = &#123; //person就是对象，对象都有各种属性，每个属性又都对应着自己的值 //键值对形式 name: \"Mofan\",//可以包含字符串 age: 20,//数字 parents: [ //数组 \"Daddy\", \"Mami\", ] sayName: function()&#123; //函数 console.log(this.name); &#125;, features: &#123; //甚至是对象（很少用，我是没见过） height: \"178cm\", weight: \"60kg\", &#125;&#125; js里除了基本类型外所有事物都是对象： 函数是对象：function sayName(){} ——sayName是函数对象 数组是对象：var arr = new Array() ——arr是数组对象 为什么JavaScript要这么设计呢？我觉得首先这样一来，统一了数据结构，使JavaScript成为一门编程风格非常自由化的脚本语言：无论定义什么变量，统统var；其次，JavaScript对象都有属性和方法，函数数组都是对象，调用引用就会非常灵活方便；再者，为了构建原型链？ 创建对象的几种方式 Object()模式使用对象字面量：var obj={...}就像上面那样或者使用原生构造函数Object()： 1234567var person = new Object();person.name = \"Mofan\";person.sayName = function()&#123; console.log(this.name); &#125;;console.log(person.name);//Mofanobj.sayName();//Mofan 利用函数作用域使用自定义构造函数模式模仿类（构造器模式）： 12345678910function Person(name,age)&#123; this.name = name; this.age = age; this.print = function()&#123; console.log(this.name + this.age) &#125;;&#125;var person = new Person(\"Mofan\",19);console.log(person.name+person.age);//Mofan19person.print();//Mofan19 原型模式： 12345678910111213141516171819function Person()&#123;&#125;//可以这样写/*Person.prototype.name = \"Mofan\";Person.prototype.age = 19;Person.prototype.print = function()&#123; console.log(this.name+this.age);&#125;*///推荐下面这样写，但两种方式不能混用！因为下面这种方式实际上重写了//Person原型对象，如果两者混用，后面赋值方式会覆盖前面赋值方式Person.prototype = &#123; name:\"Mofan\", age:19, print:function()&#123; console.log(this.name+this.age); &#125;&#125;var person = new Person();console.log(person.name+person.age);//Mofan19person.print();//Mofan19 组合构造函数模式和原型模式： 12345678910111213141516function Person(name,age)&#123; //这里面初始化属性 this.name = name; this.age = age; ...&#125;Person.prototype = &#123; //这里面定义公有方法 print:function()&#123; console.log(this.name+this.age); &#125;, ...&#125;var person = new Person(\"Mofan\",19);console.log(person.name+person.age);//Mofan19person.print();//Mofan19 动态创建原型模式： 1234567891011121314151617181920function Person(name,age)&#123; //初始化属性 this.name = name; this.age = age; //在创建第一个对象（第一次被调用）时定义所有公有方法,以后不再调用 if(typeof this.print !=\"function\")&#123; Person.prototype.print =function()&#123; console.log(this.name+this.age); &#125;; Person.prototype.introduction=function()&#123; console.log(\"Hi!I'm \"+this.name+\",I'm \"+this.age); &#125;; //如果采用对象字面量对原型添加方法的话，第一次创建的对象将不会有这些方法 &#125;; &#125;var person = new Person(\"Mofan\",19);person.print();//Mofan19person.introduction();//Hi!I'm Mofan,I'm 19 还有一些模式用的场景比较少 这些模式的应用场景怎么会有这么多的创建模式？其实是因为js语言太灵活了，因此前辈们总结出这几种创建方式以应对不同的场景，它们各有利弊。 第一种方式，使用字面量或者使用构造函数Object()常用于创建普通对象存储数据等。它们的原型都是Object，彼此之间没有什么关联。事实上，下面创建方式都是一样的： 123456var o1 = &#123;&#125;;//字面量的表现形式var o2 = new Object;var o3 = new Object();var o4 = new Object(null);var o5 = new Object(undefined);var o6 = Object.create(Object.prototype);//等价于 var o = &#123;&#125;;//即以 Object.prototype 对象为一个原型模板,新建一个以这个原型模板为原型的对象 第二种方式，利用函数作用域模仿类，这样就可以在创建对象时传参了，可以创建不同属性值得对象，实现对象定制。不过print方法也定义在了构造函数里面，如果要把它当做公有方法的话，这样每new一个对象，都会有这个方法，太浪费内存了。可以这样修改一下构造器模式： 1234567891011121314//构造器方法2function print()&#123; //定义一个全局的 Function 对象,把要公有的方法拿出来 console.log(this.name + this.age);&#125;function Person(name,age)&#123; this.name = name; this.age = age; this.print = print.bind(this);//每个 Person 对象共享同一个print 方法版本(方法有自己的作用域，不用担心变量被共享)&#125;var person = new Person(\"Mofan\",19); console.log(person.name+person.age);//Mofan19 person.print();//Mofan19 然而这样看起来很乱，也谈不上类的封装性。还是使用原型吧 第三种方式，纯原型模式，不管是属性还是方法都添加到原型里面去了，这样做好处是很省内存，但是应用范围就少了，更多的对象 内部的属性是需要定制的，而且一旦更改原型，所有这个原型实例都会跟着改变。因此可以结合构造函数方式来实现对对象的定制，于是就有了 第四种方式——组合构造函数模式与原型模式，可以定制的放在构造器里，共有的放在原型里，这也符合构造器和原型的特性。 “这是es5中使用最广泛、认同度最高的创建自定义类型的方法”`—《JavaScript高级程序设计》第三版 ​ 第五种方式，动态原型模式，出现这种方式是因为有些面向对象开发人员习惯了类构造函数，于是对这种独立出来的构造函数和原型感到困惑和不习惯。于是，就出现了把定义原型也写进构造函数里的动态原型模式。上面在动态原型模式程序里面讲“如果采用对象字面量对原型添加方法的话，第一次创建的对象将不会有这些方法”这是因为在if语句执行以前，第一个对象已经被创建了，然后执行if里面的语句，如果采用对象字面量给原型赋值，就会导致原型在实例创建之后被重写，创建的第一个实例就会失去与原型的链接，也就没有原型里的方法了。不过以后创建的对象就可以使用原型里的方法了，因为它们都是原型被修改后创建的。 原型是什么在JavaScript中，原型就是一个对象，没必要把原型和其他对象区别对待，只是通过它可以实现对象之间属性的继承。任何一个对象也可以成为原型。之所以经常说对象的原型，实际上就是想找对象继承的上一级对象。对象与原型的称呼是相对的，也就是说，一个对象，它称呼继承的上一级对象为原型，它自己也可以称作原型链下一级对象的原型。 一个对象内部的[[Prototype]]属性生来就被创建，它指向继承的上一级对象，称为原型。函数对象内部的prototype属性也是生来就被创建（只有函数对象有prototype属性），它指向函数的原型对象（不是函数的原型！）。当使用var instance = new Class();这样每new一个函数（函数被当做构造函数来使用）创建实例时，JavaScript就会把这个原型的引用赋值给实例的原型属性，于是实例内部的[[Prototype]]属性就指向了函数的原型对象，也就是prototype属性。 原型真正意义上指的是一个对象内部的[[Prototype]]属性，而不是函数对象内部的prototype属性，这两者之间没有关系！对于一个对象内部的[[Prototype]]属性，不同浏览器有不同的实现： 12345678910 var a = &#123;&#125;; //Firefox 3.6+ and Chrome 5+ Object.getPrototypeOf(a); //[object Object] //Firefox 3.6+, Chrome 5+ and Safari 4+ a.__proto__; //[object Object] //all browsers a.constructor.prototype; //[object Object] 之所以函数对象内部存在prototype属性，并且可以用这个属性创建一个原型，是因为这样以来，每new一个这样的函数（函数被当做构造函数来使用）创建实例，JavaScript就会把这个原型的引用赋值给实例的原型属性，这样以来，在原型中定义的方法等都会被所有实例共用，而且，一旦原型中的某个属性被定义，就会被所有实例所继承（就像上面的例子）。这种操作在性能和维护方面其意义是不言自明的。这也正是构造函数存在的意义（JavaScript并没有定义构造函数，更没有区分构造函数和普通函数，是开发人员约定俗成）。下面是一些例子： 1234567891011121314var a = &#123;&#125; //一个普通的对象function fun()&#123;&#125; //一个普通的函数//普通对象没有prototype属性console.log(a.prototype);//undefinedconsole.log(a.__proto__===Object.prototype);//true//只有函数对象有prototype属性console.log(fun.prototype);//Objectconsole.log(fun.__proto__===Function.prototype);//trueconsole.log(fun.prototype.__proto__===Object.prototype);//trueconsole.log(fun.__proto__.__proto__===Object.prototype);//trueconsole.log(Function.prototype.__proto__===Object.prototype);//trueconsole.log(Object.prototype.__proto__);//null 当执行console.log(fun.prototype);输出为 123// 一个对象, 对象包含constructor、__proto__两个属性constructor:ƒ fun()__proto__:Object 可以看到，每创建一个函数，就会创建prototype属性，这个属性指向函数的原型对象（不是函数的原型），并且这个原型对象会自动获得constructor属性，这个属性是指向prototype属性所在函数的指针。而__proto__属性是每个对象都有的。 接着上面再看： 123456789101112function Person()&#123;&#125;//构造函数,约定首字母大写var person1 = new Person();//person1为Person的实例console.log(person1.prototype);//undefinedconsole.log(person1.__proto__===Person.prototype);//trueconsole.log(person1.__proto__.__proto__===Object.prototype);//trueconsole.log(person1.constructor);//function Person()&#123;&#125;//函数Person是Function构造函数的实例console.log(Person.__proto__===Function.prototype);//true//Person的原型对象是构造函数Object的实例console.log(Person.prototype.__proto__===Object.prototype);//true person1和上面那个普通的对象a有区别，它是构造函数Person的实例。前面讲过： 当使用var instance = new Class();这样每new一个函数（函数被当做构造函数来使用）创建实例时，JavaScript就会把这个原型的引用赋值给实例的原型属性，于是实例内部的[[Prototype]]属性就指向了函数的原型对象，也就是prototype属性。 因此person1内部的[[Prototype]]属性就指向了Person的原型对象，然后Person的原型对象内部的[[Prototype]]属性再指向Object.prototype，相当于在原型链中加了一个对象。通过这种操作，person1就有了构造函数的原型对象里的方法。 另外，上面代码console.log(person1.constructor);//function Person(){}中，person1内部并没有constructor属性，它只是顺着原型链往上找，在person1.__proto__里面找到的。 可以用下面这张图理清原型、构造函数、实例之间的关系： 继承JavaScript并没有继承这一现有的机制，但可以利用函数、原型、原型链模仿。下面是三种继承方式： 类式继承1234567891011121314151617181920212223//父类function SuperClass()&#123; this.superValue = \"super\";&#125;SuperClass.prototype.getSuperValue = function()&#123; return this.superValue;&#125;;//子类function SubClass()&#123; this.subValue = \"sub\";&#125;//类式继承,将父类实例赋值给子类原型，子类原型和子类实例可以访问到父类原型上以及从父类构造函数中复制的属性和方法SubClass.prototype = new SuperClass();//为子类添加方法SubClass.prototype.getSubValue = function()&#123; return this.subValue;&#125;//使用var instance = new SubClass();console.log(instance.getSuperValue);//superconsole.log(instance.getSubValue);//sub 这种继承方式有很明显的两个缺点： 实例化子类时无法向父类构造函数传参 如果父类中的共有属性有引用类型，就会在子类中被所有实例所共用，那么任何一个子类的实例更改这个引用类型就会影响其他子类实例,可以使用构造函数继承方式解决这一问题 构造函数继承1234567891011121314151617181920212223 //父类 function SuperClass(id)&#123; this.superValue = [\"big\",\"large\"];//引用类型 this.id = id; &#125; SuperClass.prototype.getSuperValue = function()&#123; return this.superValue; &#125;; //子类 function SubClass(id)&#123; SuperClass.call(this,id);//调用父类构造函数并传参 this.subValue = \"sub\"; &#125; var instance1 = new SubClass(10);//可以向父类传参 var instance2 = new SubClass(11); instance1.superValue.push(\"super\");console.log(instance1.superValue);//[\"big\", \"large\", \"super\"]console.log(instance1.id);//10console.log(instance2.superValue);[\"big\", \"large\"]console.log(instance2.id);//11console.log(instance1.getSuperValue());//error 这种方式是解决了类式继承的缺点，不过在代码的最后一行你也看到了，没有涉及父类原型，因此违背了代码复用的原则。所以组合它们： 组合继承123456789101112131415161718192021222324252627282930function SuperClass(id)&#123; this.superValue = [\"big\",\"large\"];//引用类型 this.id = id; &#125; SuperClass.prototype.getSuperValue = function()&#123; return this.superValue; &#125;; //子类 function SubClass(id,subValue)&#123; SuperClass.call(this,id);//调用父类构造函数并传参 this.subValue = subValue; &#125; SubClass.prototype = new SuperClass(); SubClass.prototype.getSubValue = function()&#123; return this.subValue; &#125; var instance1 = new SubClass(10,\"sub\");//可以向父类传参 var instance2 = new SubClass(11,\"sub-sub\"); instance1.superValue.push(\"super\"); console.log(instance1.superValue);//[\"big\", \"large\", \"super\"] console.log(instance1.id);//10 console.log(instance2.superValue);[\"big\", \"large\"] console.log(instance2.id);//11 console.log(instance1.getSuperValue());[\"big\", \"large\", \"super\"] console.log(instance1.getSubValue());//sub console.log(instance2.getSuperValue());//[\"big\", \"large\"] console.log(instance2.getSubValue());//sub-sub 嗯，比较完美了，但是有一点，父类构造函数被调用了两次，这就导致第二次调用也就是创建实例时重写了原型属性，原型和实例都有这些属性，显然性能并不好。先来看看克罗克福德的寄生式继承： 12345678910111213141516171819 function object(o)&#123; function F()&#123;&#125;; F.prototype = o; return new F(); &#125; function createAnnther(original)&#123; var clone = object(original); clone.sayName = function()&#123; console.log(this.name); &#125; return clone; &#125; var person = &#123; name:\"Mofan\", friends:[\"xiaoM\",\"Alice\",\"Neo\"], &#125;; var anotherPerson = createAnnther(person); anotherPerson.sayName();//\"Mofan\"&#125; 就是让一个已有对象变成新对象的原型，然后再在createAnother函数里加强。你也看到了，person就是一个普通对象，所以这种寄生式继承适合于根据已有对象创建一个加强版的对象，在主要考虑通过已有对象来继承而不是构造函数的情况下，这种方式的确很方便。但缺点也是明显的，createAnother函数不能复用，我如果想给另外一个新创建的对象定义其他方法，还得再写一个函数。仔细观察一下，其实寄生模式就是把原型给了新对象，对象再加强。 等等，写到这个地方，我脑子有点乱，让我们回到原点：继承的目的是什么？应该继承父类哪些东西？我觉得取决于我们想要父类的什么，我想要父类全部的共有属性（原型里）并且可以自定义继承的父类私有属性（构造函数里）！前面那么多模式它们的缺点主要是因为这个： 1SubClass.prototype = new SuperClass(); 那为什么要写这一句呢？是只想要继承父类的原型吗？如果是为什么不这么写： 1SubClass.prototype = SuperClass.prototype; 这样写是可以继承父类原型，但是风险极大：SuperClass.prototype属性它是一个指针，指向SuperClass的原型，如果把这个指针赋给子类prototype属性，那么子类prototype也会指向父类原型。对SubClass.prototype任何更改，就是对父类原型的更改，这显然是不行的。 寄生组合式继承但出发点没错，可以换种继承方式，看看上面的寄生式继承里的object()函数，如果把父类原型作为参数，它返回的对象实现了对父类原型的继承，没有调用父类构造函数，也不会对父类原型产生影响，堪称完美。 12345678910111213141516171819202122232425262728293031323334353637383940function object(o)&#123; function F()&#123;&#125;; F.prototype = o; return new F(); &#125;function inheritPrototype(subType,superType)&#123; var proto = object(superType.prototype); proto.constructor = subType;//矫正一下construcor属性 subType.prototype = proto; &#125; function SuperClass(id)&#123; this.superValue = [\"big\",\"large\"];//引用类型 this.id = id; &#125; SuperClass.prototype.getSuperValue = function()&#123; return this.superValue; &#125;; //子类 function SubClass(id,subValue)&#123; SuperClass.call(this,id);//调用父类构造函数并传参 this.subValue = subValue; &#125; inheritPrototype(SubClass,SuperClass);//继承父类原型 SubClass.prototype.getSubValue = function()&#123; return this.subValue; &#125; var instance1 = new SubClass(10,\"sub\");//可以向父类传参 var instance2 = new SubClass(11,\"sub-sub\"); instance1.superValue.push(\"super\"); console.log(instance1.superValue);//[\"big\", \"large\", \"super\"] console.log(instance1.id);//10 console.log(instance2.superValue);//[\"big\", \"large\"] console.log(instance2.id);//11 console.log(instance1.getSuperValue());//[\"big\", \"large\", \"super\"] console.log(instance1.getSubValue());//sub console.log(instance2.getSuperValue());//[\"big\", \"large\"] console.log(instance2.getSubValue());//sub-sub 解决了组合继承的问题，只调用了一次父类构造函数，而且还能保持原型链不变，为什么这么说，看对寄生组合的测试： 12console.log(SubClass.prototype.__proto__===SuperClass.prototype);//ture console.log(SubClass.prototype.hasOwnProperty(\"getSuperValue\"));//false 因此，这是引用类型最理想的继承方式。 总结创建用于继承的对象最理想的方式是组合构造函数模式和原型模式（或者动态原型模式），就是让可定义的私有属性放在构造函数里，共有的放在原型里；继承最理想的方式是寄生式组合，就是让子类的原型的[[prototype]]属性指向父类原型，然后在子类构造函数里调用父类构造函数实现自定义继承的父类属性。 JavaScript对象总有一些让我困惑的地方，不过我还会继续探索。我在此先把我了解的记录下来，与各位共勉。错误的地方请费心指出，我将感谢您的批评指正。 本文为作者原创，转载请注明本文链接，作者保留权利。 参考文献：[1] http://www.cnblogs.com/chuaWeb/p/5039232.html[2] http://www.cnblogs.com/xjser/p/4962821.html[3] https://javascriptweblog.wordpress.com/2010/06/07/understanding-javascript-prototypes/","tags":[{"name":"JavaScript对象","slug":"JavaScript对象","permalink":"http://realtcg.com/tags/JavaScript对象/"}]},{"title":"今天我20岁","date":"2017-03-08T15:37:45.000Z","path":"2017/03/08/20/","text":"今天，我来到地球整整20年了。 本来还想大过一回，好好庆祝一下，但想想《好先生》里陆远说的那句话：“男人需要一辈子来成熟”也就作罢了。可今天毕竟是意义非凡的一天，所以我决定在今天把这些天我想说的话，我心里的话都写下来，以后多少有个纪念。 20岁了，不是十几岁了，想想都觉得可怕，想想都觉得时间过的飞快。以前还在想:我什么时候才能到20岁，我20多岁会是什么样子。喏，这不就20岁了么。 上了大学以来，可以说我的心态和三观发生了不小的变化，自己也默默承受着变化带来的副作用。也不跟人说，跟谁说呢？跟父母说？让他们担心你？跟远方的好朋友说？算了，没多大事，跟周围的人说？别开玩笑了，我可说不出口，他们也没兴趣听。还是憋在心里慢慢消化吧.. 梦想20岁，还年轻，不过我急于证明自己，想尽快有所成就，不再依靠父母，早日让他们享福。所以我大一就想好了不读研，大学毕业尽快工作。先让这个家庭富裕起来，再去实现我的梦想吧。有时候觉得一个人的发展很多受家庭的影响:就像我的家庭并不富裕，而且在整个家族里都是最不富裕的，我就想长大挣大钱，先过上富裕的生活，再做自己想做的事。尤其这两年，我见识外面精彩的世界越多，我就越向往，然后就越来越感到与现实的差距，这种差距感不断地督促我，加快我朝着梦想的步伐。 20岁，我一无所有，却想要一切。 所以我对自己的要求越来越严格，越来越自律。不打游戏，不看剧，不出去浪，甚至连谈恋爱都觉得是奢望。每天看书，敲代码，清心寡欲，干一点别的事都觉得有愧疚感。没事，哪怕我舍弃别的东西，我学有所成也行啊，至少有一件事做成了也能给我安慰啊。然而事情总是不像我想象的那样好，有时候光靠努力是不行的，还要有方法、运气、效率… 我最害怕的就是，我舍弃了别的东西，还没弄好一直投入精力去做的事情。 所以每当我学习不顺的时候，我的心情就糟糕到了极点。原本我可以花时间多交几个朋友，我们一起吃饭，一起出去玩，一起打球，放假一块出去旅游;说不定我还会遇到我生命中的那个她，我们互相爱着对方，照顾对方，给予对方心灵的慰藉和归属感，一起享受和对方快乐美好的时光…这才是我心目中的那个青春。 可是我总是强行打破幻想:度过了这些快乐时光之后呢？你是快乐了四年，你是有了一个美好的青春，可你拿什么养活自己？你拿什么支撑自己的梦想？你忘了你的家庭情况了吗？ 没办法，生活就是这样，时间就那么多，我必须做出选择，必须懂得舍得。 “要好身材就得保持锻炼，要身体健康就要注意饮食，想多看书就得放弃其它时间。其它的也一样，要安逸就不要羡慕动荡，管不住嘴就得接受体重。其实无论过什么样的生活都要付出代价，或者是牺牲一些别的什么。没那么多两全其美的事，选择归根结底都是考验你是否能为了你所坚持的去背负那些代价。” 我强烈感觉我现在处在这样一种情况:我努力，我就能得到我想要的生活，它近在咫尺;我苟活，我只能碌碌无为，随遇而安。也许大学就是这样，你有无限可能，这也可能正是大学毕业后每个人的发展差距很大的原因。 我选择在这个时候朝着我的梦想前进，我选择为之付出大部分的精力，必要时我会全身心投入，我选择舍弃一些做其他事情的时间和精力。我问过自己的内心，实现梦想，才是我真正想要的。 可有时候，那些你忽略的东西也很重要，我现在也逐渐地意识到了。以前忽略它们，是因为太年轻，没有意识到。它们就是亲情，友情，人际关系，待人处世、团队合作、组织、表达的能力… 忽略它们给我带来了许多不好的后果，例如在做项目的时候，整天想的都是项目的事情，走路想，吃饭想，上课想，每天还一副忧心忡忡、严肃的样子，忽略了好多人好多事，忽略了人际交往。久而久之，人家就觉得你这个人是不是真的性格内向，不好相处，也就不跟你相处了(其实我老好相处了心塞(´-ωก`))。这样的事还有很多。 所以啊，我应该尽量平衡好学习和生活以及人际交往冲突的地方，再忙也不忘生活。这也是一种重要的能力。 迷茫到选择20岁，面临越来越多的选择，我内心很挣扎，仿佛20岁所做的每个决定，都会对未来产生重大影响。 20岁了，不能任性了，今后所做的任何事都要有所考虑，所做的任何选择都要慎重。因为过了20，我已经没有可以浪费的资本了。或许正是我觉得选择要慎重，我用了整整一年的时间想清楚我到底是读研、出国还是工作，用了一年时间去发现我今后到底要从事什么样的工作。选择初期，我内心很挣扎，因为我真的不清楚我选那条路好。有时候，看到什么心动的东西，或者前辈们的几句话，或者有感触的事就忽然做出选择，但过一段时间后，又开始怀疑这个选择，进而又回到了原点…有时挣扎到深处，甚至开始思考一些更”底层””的问题: 人生的意义是什么？我该活出什么样子？… 后来，我还是做出了选择，”Follow my heart”，接受我自己。 追随我的心，接受我自己。可能没有其他的路好，但我肯定不会后悔，还会因此感到快乐和安心。 烦恼总有一段时间感觉生活好没意思。每天起床，吃饭，没精打采的上课，下课，吃饭，上课，下课，回来敲代码…更重要的是，那个时候我什么都不想做，什么都不感兴趣。我有时候都羡慕室友，天天打游戏也不烦，还快快乐乐，至少能有一个爱好，找点乐子，消磨消磨时间。我有什么爱好啊？天呐，我都不知道我有什么爱好。或许正是因为我清心寡欲，没什么爱好，我才老是觉得生活没有什么意思，才老是思考人生的意义到底是什么。 总有一段时间，感到很孤独，莫名的孤独，突然的孤独。感觉自己没有一个知心的朋友，没有可以倾诉的人。我开始越来越喜欢听伤感的歌，听的时候一边伤感，一边疗伤，也算是发泄了。长大了，烦恼多了，却少了可以倾诉的人，自己也不想倾诉了。我觉得以前的我很开心，我没有烦恼，我喜欢的人和我的朋友都在身边，最重要的是，那时我擅长自娱。现在我好像变得多愁善感了，变得敏感了，变得沉默了。我身边好像少了一些东西，生活没有那么精彩丰富了。也许我睡一觉就不那么觉得了，但是我肯定还会感到孤独，在某个时候。这一年我在外面过得并不开心。 不过我还是想到了一些方法来消解郁闷，简单但有效果的方法就是跑步！ 我发现我跑步的时候，心里面很平静，再听着歌，内心就更加放松。我很喜欢晚上跑到筋疲力竭的时候，边听歌边走在跑道上，四周无人，尽情地放松我自己…这对我来说的确是一种非常有效果的发泄方式，每次跑完回来后，我的步伐就会变得更加坚定，内心照样如此。我想我会坚持下去的，因为我喜欢跑步时和跑步后的那种释放的感觉。跑步给我带来的不仅是身体上的健康，最重要的是让我的心态逐渐变得阳光，自信。 向往的生活哈哈，我向往有一天，我和我的家庭在欧洲或者美国的某个风景美丽的小镇定居了下来，我们有一个不大不小但温馨漂亮的房子，房子有一片绿地，还有菜园。我和我的爱人有两个可爱的孩子，一男一女，还有一只狗狗。我做着我喜欢的工作，我妻子专心地照顾家庭，孩子们接受着最好的教育。每天我们互道早安晚安，一起吃饭，每到周末，我们一起驾着车出去郊游，我们和孩子们还有狗狗尽情地玩耍…哈哈哈哈哈哈 先写这么多！晚安~","tags":[{"name":"感想","slug":"感想","permalink":"http://realtcg.com/tags/感想/"}]}]