[{"title":"认识node核心模块--全局对象及Cluster","date":"2017-10-25T12:59:29.000Z","path":"2017/10/25/认识node核心模块-全局对象及Cluster/","text":"node 模块是node 完成强大功能的实现者。node 的核心模块包括events、fs、buffer、stream、cluster、http、net、一些操作OS和工具模块、全局对象等。本文将在node核心特性理解的基础上进一步深入探讨node核心模块的具体细节。本文主要探讨的模块有：全局对象global及其重要属性、多进程cluster、events重要类EventEmitter、流Stream、文件系统fs、网络http，还会介绍node框架express相关。 概述本文先来介绍全局对象global及其重要属性、多进程cluster模块。 正文node全局对象global与浏览器对应的window一样，在node中global是全局对象，在全局作用域定义的任何变量都会保存为global的属性，称为全局变量。下面是global一些重要的属性： 模块：module、require、exports 这三个全局变量组成了node 的模块定义和引入，是 commonJS 的实现。node将每个文件视为一个模块，在执行到每个模块之前都会定义好上述三个变量，因此可以直接使用。来看它们之间的协作： 12345678// module1.jsexports.fun = function(a,b) &#123; return a + b;&#125; //绑定在exports的属性可以被其他模块引入使用//module2.jsvar module1 = require('./module1')module1.fun(3,2) //5 相关机制： module 表示对这个模块的引用，因此module 实际上不是全局的，而是每个模块本地的。module除了exports 还有其他关于模块的属性，例如module.children exports 其实是module.exports的简写，表示这个模块的输出。有一点需要注意，对exports直接赋值exports = {...}并不会被输出，因为exports事先已经被定义了，再次这样赋值会被覆盖，需要带上module：module.exports = {...} require 表示引入某个模块，填写模块路径即可，在node_modules里面的模块填写名字即可，js文件可以不用写扩展名。 另外，由于V8引擎对ES6的不断支持，node 中也可以直接使用ES6的一些特性、例如promise、class等，ES6的模块也被node 实验性的引入并且是稳定的。详情见nodejs中文网。可以在node.green查看支持的特性 异步操作 setTimeout、setInterval、setImmediate、process.nextTick setTimeout和setInterval跟浏览器端一样，不同的是，node实现了setImmediate（目前浏览器端只有 IE实现了该方法）。它表示在 Node.js 事件循环的当前回合结束时要调用的函数，用来把一些需要长时间运行的操作放在一个回调函数里,在node主线程完成后面的其他语句后,就立刻执行这个回调函数，参数是一个函数和用作这个函数的参数，作用跟setTimeout(fn,0)差不多，都是相当于立即在事件队列末尾插入一个事件，但也有差别。 process.nextTick(fn,...args)表示在当前调用栈结束后，在下一个事件执行前调用回调函数。node 提供这个API是为了把复杂耗时的任务放到最后去处理，以便优先执行简单的任务。来看它们之间的比较： 1234setTimeout(() =&gt; console.log(\"setTimeout0\"),0)setImmediate(() =&gt; console.log(\"setImmediate\"))process.nextTick(() =&gt; console.log(\"nextTick\"))//输出nextTick setTimeout0 setImmediate 或者 nextTick setImmediate setTimeout0 无论process.nextTick写在什么地方，它总是第一个输出。无论setTimeout和setImmediate谁先谁后，都可能出现两种结果，其中setTimeout(fn,0)先于setImmediate多一点。这是因为它们三个产生的事件推入到了不同的watcher（观察者）中—— setTimeout推入到了定时器观察者，setImmediate是check观察者，而process.nextTick()是idle观察者 ，而node主线程在事件循环时调用watcher 的顺序一般是 idle观察者 &gt; check观察者，idle观察者 &gt; 定时器观察者，check 和定时器不分先后，但定时器先于check的概率大一点。 node进程： process process 是node对进程的表示，提供了操作进程的接口，可以用process来提供进程有关信息，控制进程 。 process提供的接口包括 描述进程的一些状态（事件）：exit、beforeExit、uncaughtException、Signal 进程退出返回的状态码：Uncaught Fatal Exception、Signal Exits、Unused等 进程的相关信息：stdout、stderr、config、stdin、exitCode、pid(进程编号)等 操作进程的方法：abort、chdir、cwd、kill(发送信号给进程)、exit、nextTick、getgid、setgid、uptime等 其他： console、__filename、 __dirname 这些都是全局变量，可以在任何地方引用 node 子进程：child_process模块一个进程只能利用一个CPU时间分片，为了高效利用多核CPU，node 提供了可以创建子进程(注意不是子线程)的child_process模块，来帮助主进程高效利用多核CPU完成其他复杂的任务。之所以提供创建子进程而不是子线程的接口，是因为这让我们的程序状态单一，不用在意状态同步、死锁、上下文切换开销等等多线程编程中的头疼问题。这样以来一个进程只有一个线程。虽然单线程也会带来一些问题，如错误会引起整个应用退出等，但这都有了很好的解决方案。 创建子进程 node有三种创建子进程的接口： exec / execFile: 这两者都会创建子进程来执行，执行的结果会存储在Buffer中。不同的是前者创建一个shell进程来执行命令，后者直接创建一个进程用来执行可执行文件，因此前者适合用来执行shell命令然后获取输出，后者效率较高。这两者因为输出的结果存储在Buffer中，因此只适合输出轻量的数据。 spawn：适合用于进程输入、输出数据量比较大的情况，因为它支持以 stream 的形式输入输出，可以用于任何命令。spawn的参数option有一个stdio配置项，用来配置子进程与父进程之间的IO通道，还有一个detached来配置子进程是否独立运行，可以创建常驻后台进程。总之，给予了子进程更多的灵活性。 fork：fork 其实是spawn的特例，它会创建一个V8实例，只能用来运行node.js程序，并且与上面两种方法不同的是，fork会在父子进程间建立 IPC 通道，父子进程之间可以互相收发消息——通过监听 message 事件和调用 send 方法，就可以在父子进程间进行通信了。 父子进程通信 首先，这三种API都返回ChildProcess实例，因此都可以通过访问stdout属性来得到输出，exec/execFile 接口还可以在参数里绑定回调函数拿到子进程的stdout 。 123456789101112131415161718192021const &#123; exec, execFile, spawn, fork &#125; = require(\"child_process\")// exec/execFile 接口既可以在参数里绑定回调函数拿到输出流，也可以利用返回的ChildProcess实例const exec_process = exec(\"node child_process.js\", &#123;&#125;, (err, stdout, stderr) =&gt; &#123; if (err) &#123; console.log(err) &#125; else if(stdout) &#123; console.log(stdout) &#125; else &#123; console.log(stderr) &#125;&#125;)exec_process.stdout.on('data',(data) =&gt; console.log(`$&#123;data&#125;`))// spawn 接口没有回调函数，只能利用返回的ChildProcess实例绑定监听数据函数拿到子进程的输出const spawn_process = spawn('node',['child_process'], &#123;&#125;)spawn_process.stdout.on('data', (data) =&gt; console.log(`$&#123;data&#125;`))//fork 也可以利用返回的ChildProcess实例，注意配置项silent要设为trueconst fork_process = fork('child_process.js', [], &#123;'silent': true&#125;)fork_process.stdout.on('data' ,(data) =&gt; console.log(`$&#123;data&#125;`)) 其次， fork返回的ChildProcess实例有一个额外的内置的通信通道IPC，它允许消息在父进程和子进程之间来回传递。 12345678910111213141516171819// child_process.jsprocess.on('message', (data) =&gt; &#123; console.log(`message from Parent: $&#123;data&#125;`);&#125;)setTimeout(() =&gt; &#123; process.send('send from child');&#125;, 2000)// parent.jsconst &#123; fork &#125; = require(\"child_process\")const p = fork( 'child_process.js', // 需要执行的脚本路径 [], // 传递的参数 &#123;&#125;)p.on('message', data =&gt; &#123; //监听子进程消息 console.log(`message from child: $&#123;data&#125;`)&#125;)p.send('send from parent') //发送消息给子进程 集群：Cluster 模块 cluster模块是对child_process模块的进一步封装，专用于解决单进程NodeJS Web服务器无法充分利用多核CPU的问题。使用该模块可以简化多进程服务器程序的开发，让每个核上运行一个工作进程，并统一通过主进程监听端口和分发请求。 ——七天学会node.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const cluster = require('cluster');const http = require('http');const numCPUs = require('os').cpus().length;console.log(numCPUs)if (cluster.isMaster) &#123; console.log(`主进程 $&#123;process.pid&#125; 正在运行`); // 衍生工作进程。 for (let i = 0; i &lt; numCPUs; i++) &#123; cluster.fork(); // 调用了 child_process.fork()方法创建工作进程 &#125; cluster.on('exit', (worker, code, signal) =&gt; &#123; console.log(`工作进程 $&#123;worker.process.pid&#125; 已退出`); &#125;);&#125; else &#123; // 工作进程可以共享任何 TCP 连接。 // 在本例子中，共享的是一个 HTTP 服务器。 http.createServer((req, res) =&gt; &#123; res.writeHead(200); res.end('你好世界\\n'); &#125;).listen(8000); console.log(`工作进程 $&#123;process.pid&#125; 已启动`);&#125;console.log(\"WOW\")// 输出（Mac OS）4主进程 55570 正在运行WOW4工作进程 55571 已启动WOW4工作进程 55572 已启动WOW4工作进程 55573 已启动WOW4工作进程 55574 已启动WOW//可以看到 fork 是异步创建的，调用时请求创建进程并立即返回，系统创建好进程后会加入到事件队列，执行到事件就调用回调函数，这个回调函数包括执行一遍这个文件 cluster.fork()实际调用了child_process.fork()，因此建立了IPC通道与父进程通信。它会创建一个进程并返回cluster.worker实例。创建的每个进程之间都是独立的，一个进程的开启和关闭不影响其他进程。只要有存活的进程，服务器就可以继续处理连接。 主进程负责监听端口，接收新连接后会自动将连接循环（默认）分发给cluster.fork()创建的工作进程来帮忙处理，因此可以使用cluster模块来实现简单的负载均衡。 注意： cluster.fork()返回cluster.worker实例可能会引起困惑，困惑的原因把主进程和工作进程做了master和worker的区分，这里不用这么区分，既然主进程也是进程，那么也可以看作worker，调用cluster.fork().send(message)就可以向子进程发送信息，同样监听信息也是cluster.fork().on(&#39;message&#39;, (data) =&gt; {...})。 worker 和 process 都是相对的，如果当前执行进程是主进程就代表主进程，是工作进程就代表工作进程。 cluster代表整个集群，也就是主进程和工作进程，随着当前执行进程的变化，cluster的属性也在变化。在cluster上面绑定的事件对每个进程都起作用。cluster有一些API 是只对于主进程或只对于工作进程的，例如只能在主进程而不能在工作进程中调用的：fork、cluster.workers等，只能在工作进程不能在主进程调用的：cluster.worker等。 跟上面child_process模块不一样的是，cluster.fork()只有增加进程环境变量的参数(一般是不带的)，没有要执行文件路径的参数，因此像上面代码那样主进程做的事和工作进程做的事写在同一文件(if-else语句里)是合理的。","tags":[{"name":"node","slug":"node","permalink":"http://realtcg.com/tags/node/"},{"name":"node基础","slug":"node基础","permalink":"http://realtcg.com/tags/node基础/"}]},{"title":"node核心特性理解","date":"2017-10-14T14:03:16.000Z","path":"2017/10/14/node核心特性理解/","text":"node是在前端领域经常看到的词。node对于前端的重要性已经不言而喻，掌握node也是作为合格的前端工程师一项基本功了。知道node、知道后端的一些东西，才能更好的与别人合作，发挥更大的价值。 概述本文主要介绍了我对node的一些核心特性的理解，包括node架构、特点、机制、核心模块与简单应用。 正文从浏览器到node首先，node是一个平台，使用javascript作为编程语言，运行在服务端。服务端语言能做的，node一般都能做，而且有些情况下做的更好，因为它具有自己的特色。 node是javascript运行环境（runtime），就像浏览器一样，是一个平台。在浏览器中，V8引擎负责解释javascript，你在javascript调用的接口都是浏览器实现并提供的，浏览器会调用底层的、由其他语言（C++）实现并封装好的接口来完成任务；同样，在node中，也是V8引擎负责解释javascript，而你在javascript调用的浏览器提供的接口就不能用了，因为它脱离了浏览器的环境，但是因为你在node环境中，你就可以使用node提供的由C++语言实现的、由javascript封装好的各种接口来完成后端任务。浏览器提供的API用于处理前端任务，比如弹个窗，换个主题，处理用户操作等，而node因为服务后端，因此提供的API则用来处理后端任务，比如响应请求，读取文件等，这些API由不同的模块提供。因为关注领域不一样，因此所做的任务就不一样，提供的API就不一样，但是原理、相关实现大致与浏览器端相同。 从浏览器到node这一块如果想了解更多，推荐IBM的文章node.js到底是什么？ node 架构node架构分为三层（参考链接）： 图片来源 Node standard library：node标准库，也就是node模块提供各种接口的javascript实现，任何javascript代码、npm install 或者你写的模块都在这里 Node bindings：包括C/C++ bindings（胶水代码）和Add on（添加其他C/C++库时需要自己写的Bindings），这一层向下封装了V8和libuv接口，向上提供了基础API接口，是连接javascript和C++的桥梁 第三层是支撑 Node.js 运行的关键，由 C/C++ 实现。 V8 是Google开发的JavaScript引擎，提供JavaScript运行环境，可以说它就是 Node.js 的发动机，负责解释javascript，与chrome浏览器相同。 Libuv 是专门为Node.js开发的一个封装库，提供跨平台的异步I/O能力，负责node运行时的线程池调度。 C-ares：提供了异步处理 DNS 相关的能力。 http_parser、OpenSSL、zlib 等：提供包括 http 解析、SSL、数据压缩等系统底层的访问。 平常我们用到的也就是第一层node各个模块实现的接口。 那他们之间时如何协作的呢 程序启动，V8引擎会首先解析javascript代码，通过Node bindings来调用C/C++库。执行到当前事件时，会把事件放在调用堆栈（stack和heap）处理（可以理解为放进一个工作空间，如上图），在堆栈中的任何I/O请求都会交给libuv来处理，libuv维持一个线程池，里面是一些工作线程(如下图)，请求会调用这些线程来完成任务，这些线程则调用底层的C/C++库。完成时，libuv再把结果返回事件队列等待主线程执行。在此期间，主线程继续执行其他任务。 node 执行特性单线程、非阻塞型I／O单线程的意思就是只在一个线程上运行javascript。首先，javascript 在浏览器端是单线程的，这是为了避免多线程产生任务冲突的情况；其次，java和PHP这类多线程后端语言，为避免同步I/O阻塞，每处理一个连接都会产生一个新线程，这样的话在遇到大量并发请求时就会受到物理内存的限制。node 延续了浏览器端单线程javascript，只用一个主线程执行javascript，不断循环遍历事件队列，执行事件。事实上，主线程发出的I/O请求，都会交给其他线程去完成，其他线程完成后悔返回结果放到事件队列。在此期间，主线程会继续执行其他任务，也就是在交给libuv后直接返回，继续执行下面的任务，主线程只负责循环执行事件队列，因此这种模式称为非阻塞型I／O，性能很好，适用于处理大量并发请求，还能简化开发。 事件驱动机制还是跟浏览器的差不多。总的来说就是，浏览器端把鼠标点击、键盘按键等定义为事件，而node把网络请求、I／O操作等也看作事件，严格来说，一切动作都是事件，这就是事件驱动的思想。在程序启动时，便进入事件循环，不断遍历执行事件队列中产生的事件，而在执行过程中，又会产生新的事件，因此称为事件循环。主线程执行事件时，遇到麻烦的I/O请求会交给libuv来调度其他工作线程来帮忙，忙完后就会形成事件返回结果到事件队列等待主线程处理。在此期间，主线程会继续执行其他任务。 mbp 曾经做过一个巧妙的比喻，把 Node.js 看成一家餐厅。我在此借用下他的例子，稍作修改来阐述下 Node.js 的执行情况： 把 Node.js 应用程序想象成一家星巴克，一个训练有素的前台服务生（唯一的主线程）在柜台前接受订单。当很多顾客同时光临的时候，他们排队（进入事件队列）等候接待；每当服务生接待一位顾客，服务生会把订单告知给经理（libuv），经理安排相应的专职人员去烹制咖啡（工作线程或者系统特性）。这个专职人员会使用不同的原料和咖啡机（底层 C/C++ 组件）按订单要求制作咖啡或甜点，通常会有四个这样的专职人员保持在岗待命（线程池），高峰期的时候也可以安排更多（不过需要在一早就安排人员来上班，而不能中午临时通知）。服务生把订单转交给经理之后不需要等着咖啡制作完成，而是直接开始接待下一位顾客（事件循环放进调用堆栈的另一个事件），你可以把当前调用堆栈里的事件看成是站在柜台前正在接受服务的顾客。 当咖啡完成时，会被发送到顾客队列的最后位置，等它移动到柜台前服务生会叫相应顾客的名字，顾客就来取走咖啡（最后这部分在真实生活中听起来有点怪，不过你从程序执行的角度理解就比较合乎情理了）。 ​ ——By Amio 如果你想进一步了解javascript 事件驱动机制，推荐深入理解 javascript 事件循环机制 node 模块node 模块机制是CommonJs 的实现。起初，javascript 标准一片混沌，并没有其他成熟语言（例如C++）的模块机制、标准库、接口等，为了让javascript 具备开发大型应用的能力，为了让 javascript 能在后端运行，CommonJS 就制定了javascript 模块规范。node 借鉴了这个规范，让javascript 以模块形式组织起来。模块机制是一个成熟语言必备的，一个模块代表一个功能的封装，它就像搭积木一样，不同模块可以衔接在一块，使语言具有极强的可扩展型。node 模块机制同时制定了模块规范，能让全球的开发者都可以在node官网上传自己的包。此外，node 社区又实现了node 包管理器npm，使用npm可以轻松管理各种包。 node 的模块分为核心模块和用户模块，前者是底层的、自带的，后者是第三方。 核心模块有Global(全局对象)、Http、fs(文件系统)、Buffer、Stream、Events、URL、path等，这些模块提供了后端服务的基本功能，都提供自己关注功能的API。 在使用模块时，require 即可。但在require背后，node 有一套寻找模块的机制： 从上图可以看到，node 优先从缓存区读取，缓存区有直接读取，没有则加载并缓存，这样做不用一遍一遍去找了，非常高效。node 在缓存区没有发现模块时，会分析require 的路径和文件后缀，node 有个模块路径的查找策略，我们可以在名为module_paths 的js文件里console.log(module.paths)然后node module_paths.js运行来间接查看node 寻找文件模块的具体文件的方式： 123456[ '/home/username/nodeProject/node_modules', '/home/username/node_modules', '/home/node_modules', '/node_modules' ] //Linux下的数组输出(/home/username因电脑不同而异)[ 'c:\\\\nodeProject\\\\node_modules', 'c:\\\\node_modules' ] //Windows 也就是按照下面的顺序： 当前文件目录下的node_modules目录。 父目录下的node_modules目录。 父目录的父目录下的node_modules目录。 沿路径向上逐级递归，直到根目录下的node_modules目录。 这些顺序都是在查找缓存之后的。 在找到模块后，node 将在引入之前对这个模块进行编译执行，编译成功后会缓存，执行的结果会返回给调用者。 简单应用有了node 自带核心模块的基础功能，就可以进一步封装更强大、容易操作的功能了，就像jQuery 对于javascript 基础API 一样，node 社区也诞生了像 Express、KOA等框架来构建node.js程序 这些框架的详情移步2017 Node.js 开发框架比较 另外，node 还可以连接MySQL，MangoDB进行数据库操作。 下面是使用express 脚手架生成的基本 node应用结构： 1234567891011121314151617.├── app.js //程序入口├── bin│ └── www //二机制文件├── package.json //项目配置文件├── public│ ├── images │ ├── javascripts│ └── stylesheets│ └── style.css├── routes│ ├── index.js //路由文件入口│ └── users.js└── views ├── error.jade //界面模板 ├── index.jade └── layout.jade 现在使用 node作为后端语言通常都要配合类库和框架使用。 node 的单线程、非阻塞型特点让它非常适合高并发的应用，适合处理大量重复的、简单的逻辑，适合构建Rest/JSON API服务；同时，也正是因为这些特性，node 不适合CPU使用率较重、IO使用率较轻的偏计算应用。缺点是因为单线程，一个进程挂就全挂了，可靠性低，但这是可以避免的。node 更多的应用是在前端、中间件、前后端分离等。 由于 node 的诸多优点，现在越来越多大公司开始使用node、深度使用node。 总结node 的核心概念、思想远不止这么多，应用更是多了去了，无奈本人水平有限，只能说个浅层，还有很多像进程管理、异步编程、异常调试、部署、性能调优、与集群、CDN协调等都值得深入探索一下。无论如何，node 是让javascript 迈向企业级开发语言重要的一步（也许已经是了），前端工程师从未像现在这样的powerful，能做的事情越来越多，所能涉及的领域也越来越多。前端这行越来越令人兴奋了。","tags":[{"name":"node","slug":"node","permalink":"http://realtcg.com/tags/node/"},{"name":"node基础","slug":"node基础","permalink":"http://realtcg.com/tags/node基础/"}]},{"title":"我对前端工程师这个职业的看法","date":"2017-09-26T16:01:56.000Z","path":"2017/09/27/我对前端工程师这个职业的看法/","text":"最近刚刚实习结束回到学校，陆续见到了很多朋友和同学。在与他们的交谈中，很多都会问我实习时在做什么，这时，我就很不好意思地、委婉地说，我主要的工作是用编程来实现产品需求。然后他们就会说：哦！原来就是敲代码，码农啊！ 为什么我会很不好意思、要委婉着说，就是因为我每次只要说我在做编程，都被他们冠以程序猿、码农的称号，而且我感觉他们的脑海里也浮现出天天熬夜加班、熊猫眼、凌乱头发、屌丝一样的画面。 我就会感觉我很冤，我就会感觉他们误解很深，我就会感觉很失落。 这个行业不是外行人想的那样，网上说程序员天天熬夜加班、熊猫眼、凌乱头发、屌丝一样等等，这之中有一部分是程序员自黑，有一部分是真的，但只是一小部分、条件差的情况，这个每个行业都有啊。我认识的这个行业的人，有一部分在BAT这样的大公司上班，有一部分是在C／D轮公司上班，还有在创业公司上班。大公司几乎都是每天10点上班，6点下班，周末双休；创业公司可能比较忙，但也不会强制天天熬夜加班，而且上班时间不打卡，是自由的。我之前实习时，我对面的一位同事每天11点来。工资福利就不用说了，其他行业很少能比的。 这个行业工作内容确实有点枯燥（对外行人来说），大部分时间面对的是机器，不是人。但也不能一概而论，尤其是前端这个方向，需要经常跟产品、设计、后端同学交流，因为前端所处的是一个承上启下的位置。而且还有很多活动，比如开会、讨论方案、团建什么的，交流还是挺多的。 不像教师、医生那么受人尊敬，不像金融、管理那么高大上，但是我认为这个新兴的行业在未来会同样值得人尊敬。代码改变了世界。我们用代码教会了机器像人一样思考，我们也是老师；我们用代码识别了患者体内异常的情况，我们也是医生；我们还能让代码运行在每个人的移动设备上，连接每个人，赋能每个人，服务每个人，能让你足不出户, get everything。哦，by the way, 还顺便帮助人类登上了月球…你看见的，看不见的，也许都有我们的努力，你口中的码农都有崇高的理想，他们不在乎吃穿，不在乎外貌，他们正在通过自己的努力，通过自己的方式，改变着世界。乔布斯、扎克伯格、李彦宏、雷军等科技界大佬，都是编程过来的。我不觉得这个工作有什么枯燥的地方，就算有，想想它给人们带来的便利，想想它将服务亿万用户，想想就激动。 前端工程师，这个我热爱的职业，我就更想说一下了。这个职业面向用户，工作内容相对后端和其他编程领域的职业更加人性化、更加丰富多彩。我一直把这个职业视作一个魔术师，它把产品经理脑海里的想法、设计师的设计稿变成了现实，变成了可操作、可以服务每个人的、绚丽多彩、体验友好的web／APP产品。给人便利，给人信息、给人视觉、体验上的享受。所以，我一直觉得，好的web产品除了服务、传递信息，还应该给人良好的用户体验、完美的视觉体验，给人以舒服流畅的操作、美的享受，这才符合魔术师的职业素养。 前端近几年发展比其他领域要快很多，前端能做的事情也越来越多——前端、后端、移动端、嵌入式设备、VR、动画、甚至深度学习，前端都能做。我感兴趣的方向是图形、动画、webGL、甚至VR等方向，因此我觉得将来自己还是个动画师，设计师…这一切的工作，都伴随着美，都在与美打交道，何谈枯燥呢？ 我不再花费力气去劝说那些不了解这行却以为自己了解、带有偏见的人了，我热爱我从事的工作，管他们怎么说呢。","tags":[{"name":"前端工程师","slug":"前端工程师","permalink":"http://realtcg.com/tags/前端工程师/"},{"name":"职业规划","slug":"职业规划","permalink":"http://realtcg.com/tags/职业规划/"}]},{"title":"我对javascript事件循环机制的理解","date":"2017-09-21T08:23:17.000Z","path":"2017/09/21/我对javascript事件循环机制的理解/","text":"之前在学习 javascript 在浏览器的应用时，也知道 javascript 是一个事件驱动语言，但对javascript事件驱动机制只有概念上的认识，因此，对异步机制也存在困惑。最近在接触 node.js ，对javascript事件驱动机制有了更深的理解。 概述本文分别讲解了javascript在浏览器端和服务器端(node.js)的事件驱动机制，期间加入了一些异步编程的例子加深理解。 正文javascript 在浏览器端的事件驱动机制 首先，javascript 在浏览器端运行是单线程的，这是由浏览器决定的，这是为了避免多线程执行不同任务会发生冲突的情况。也就是说我们写的javascript 代码只在一个线程上运行，称之为主线程（HTML5提供了web worker API可以让浏览器开一个线程运行比较复杂耗时的 javascript任务，但是这个线程仍受主线程的控制）。单线程的话，如果我们做一些“sleep”的操作比如说： 1234var now = + new Date()while (+new Date() &lt;= now + 1000)&#123;//这是一个耗时的操所&#125; 那么在这将近一秒内，线程就会被阻塞，无法继续执行下面的任务。 还有些操作比如说获取远程数据、I/O操作等，他们都很耗时，如果采用同步的方式，那么进程在执行这些操作时就会因为耗时而等待，就像上面那样，下面的任务也只能等待，这样效率并不高。 为了解决单线程带来的阻塞问题很多操作系统实现了异步编程机制，浏览器中也是这么做的，主要表现如下： 只在主线程中运行 javascript 代码 主线程一启动就进入事件循环，整个过程就是不断的循环，不断地执行回调函数 遇到网络请求、I/O操作等时，浏览器会单开工作线程来处理，并设置相应的观察者，然后立即返回主线程，主线程继续执行下面的任务 浏览器开的线程处理好任务或者有监听的事件后会用得到的数据（或输入）形成一个事件，放在相应观察者的事件队列中，事件队列是在主线程中 主线程不断的循环，不断检查事件队列，通过遍历事件依次执行事件对应的回调函数 图片来源https://segmentfault.com/img/bVxLvF) 注意：下图中的消息队列是存储在主线程中 上图中，假设你发起了一个AJAX请求，无论你把这个请求写在什么地方，它始终都在回调函数里。因为事件驱动机制就是把一切抽象为事件，代码开始执行也是一个事件，也会隐式调用回调函数，调用回调函数就是开始执行代码。然后主线程发起异步任务后就会随即返回，继续执行”代码开始事件”对应回调函数里下面的代码，等到这个回调函数执行完毕，就会执行下一个事件。在这之间，Ajax线程会完成请求，然后把请求完成的事件（包含返回的数据）发送到事件队尾中等待处理，等到主线程执行到这个事件时，指定的回调函数即被执行。 大概是这样。如果有几处疑问的话请往下看。下面结合代码讲一下具体的过程和机制。 12345678console.log(\"开始\");setTimeout(function()&#123; console.log('延迟执行的')&#125;, 1000);setTimeout(function()&#123; console.log('立即执行的')&#125;, 0);console.log('结束') //开始 结束 立即执行的 延迟执行的 watcher机制 watcher，观察者，是事件驱动系统重要的机制。 setTimeout称为定时器，这是浏览器给的API。每当你使用定时器，这个函数将会设置一个watcher，观察者。主线程会不断的循环，不断的”经过”这里检查时间，当主线程检查时间间隔符合要求时，就会产生一个定时器事件，加入到这个watcher事件队列中并执行回调函数。因此执行setTimeout只是在时间到的时候产生了要调用回调函数的消息加入到了事件队列中，因此，回调函数并不一定在指定的时间时调用，它取决于前面有多少等待处理的事件。 刚才讲的是定时器观察者，还有I/O观察者、网络请求观察者、鼠标事件观察者、键盘事件观察者等等等等，我们经常遇到事件监听函数会让你绑定一个回调函数，这种监听函数一般就会设置watcher，其他线程产生的事件也会放到相应watcher的事件队列中，因此每个watcher会产生自己的事件队列。主线程在循环的时候，实际上是在依次调用这些watcher，检查每个watcher的事件队列，有事件就执行相应的回调。 （原创不容易，转载请注明出处 : )，有错误请评论）： 它的过程就是 ： 进程一启动就进入事件循环 有监听就添加watcher 遍历watcher下的事件队列 执行下一个watcher 事件驱动机制，它会有各种各样的事件，大量的事件，它所做的一切都跟处理事件有关。但并不是所有的事件都有watcher，如果都有，主进程任务会变得非常繁重，况且有些事件我们并不关心，例如你只写了一个定时器，代表你关心这个事件，那么点击事件、网络请求事件就不用关心，因为你根本就没写啊，也就没有watcher。 javascript 在 node.js上的事件驱动机制 javascript 在 node.js上的事件驱动机制与浏览器端大致相同，都是单线程，都有event loop，上面讲的javascript在浏览器端的事件循环机制在node上也是大致一样的，不同的是执行者何执行者的行为不一样，因为他们关注的任务不一样： node端异步机制和事件循环更加纯粹一些。node为了支持高并发，所有的API几乎都是异步的，这样会充分利用操作系统的其他线程来帮忙完成任务，主线程只负责事件消费。例如当web server接收到请求，node就把它关闭，交给其他线程进行处理，然后去服务下一个web请求。当这个请求完成，它被放到处理队列，当到达队列开头，这个结果被返回给用户。这样的话webserver一直接受请求而不等待任何读写操作，这种非阻塞型I/O性能很强。 浏览器端是浏览器负责执行BOM API，管理线程，处理用户输入信息等，在node上是node的一个核心库libuv负责执行node API，管理主线程（运行javascript）和工作线程等。 因为前端和后端关注的内容不同，因此两个运行环境的API也专注于不同的任务 这就是我对事件驱动机制的理解，有错误欢迎指正！ 推荐阅读 JavaScript：彻底理解同步、异步和事件循环(Event Loop) 【朴灵评注】JavaScript 运行机制详解：再谈Event Loop 单线程的JS引擎与 Event Loop MDN:并发模型与事件循环","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://realtcg.com/tags/JavaScript/"},{"name":"Javascript事件循环机制","slug":"Javascript事件循环机制","permalink":"http://realtcg.com/tags/Javascript事件循环机制/"}]},{"title":"面试&实习心得","date":"2017-09-19T15:15:13.000Z","path":"2017/09/19/面试-实习心得/","text":"从大二下学期放暑假开始（7.14）到8月初，我一直在寻找一份实习，锻炼一下自己，看看学的怎么样。这期间，我相继面试了小米、途牛、滴滴和百度，都拿了实习offer。其中百度拿了两次实习offer，但由于我自身一些原因，都爽约了。（在这里给百度真诚地道个歉，我非常珍视这两次机会，但无奈遇到了不可抗拒的原因，今后有机会还会再投的(˶‾᷄ ⁻̫ ‾᷅˵)）最后选择了在滴滴实习，很难得的经历。实习期间一直没空闲下来分享一下，结果拖到了现在…那么这篇文章就来分享一下我的面试和实习心得吧 面试有一些记不清了，毕竟时间太久了… 小米 说一下你的前端学习经历 css左右边固定宽，中间自适应，有几种方案 css3动画，transition属性知多少 说说你是如何配置你项目里的webpack 如何判断变量是true or false 数组去重，要求时间复杂度为O(n) http状态码，304什么情况 跨域方法 其他想不起来了… 途牛 typeof 都返回哪些类型 typeof null 返回什么，为什么？ cookie和session有什么区别 有没有实际写过、解决过跨域相关问题 使用过ES6／7哪些特性 说说 promise 几个常用API和原理 React的特性，接着问原理，接着问好在哪里 堆和栈的区别 其他想不起来了… 滴滴 React技术栈做项目用到了哪些东西 React特性、virtual dom、diff 、合成事件、调和等原理 为啥要给列表类组件设个key? 读过React源码吗？ 使用过哪些状态管理库，我说Redux，接着问Redux 是如何管理React 的，你又是如何使用Redux架构你的项目的 Redux 有哪些优缺点 了解数据可视化吗？做过之类的东西没有？ 了解node吗 其他记不起来了…总之都是围绕React技术栈来问的，上来就问框架很显然想让你进来直接干活：） 百度（地图事业部） 你在滴滴实习，为啥要来百度？（blablabla…夸了百度一番） 你在滴滴做什么东西？用了什么东西（数据可视化，还用了你们的echarts呢(/ω＼)） 那你知道echarts有哪些可以优化的地方？读过它的源码吗？ React 特性、原理，React 突出的思想 你是如何使用Redux架构技术栈的 我看你用了Redux-saga，它比thunk、promise有啥好处？ 你使用过哪些ES6 新特性、promise原理 跨域的几种方法 你这个项目有没有遇到什么你觉得难的问题，你怎么解决的？ 你有啥想问我的？（一般问部门技术栈、工作氛围） 其他记不起来了… 百度（校园品牌部） 介绍一下前端经历 你平常如何用css管理页面布局的，我说栅格，又问栅格怎么实现的 css3动画、transition、transform，canvas、svg sass跟less的区别？ javascript 有哪些特性，我说了弱类型、单线程、事件驱动，就有了下面的 你怎么理解事件驱动机制的？ 用过事件委托吗？怎么用的？ 嗯…ES6 用过哪些新特性？我提到了箭头函数，于是就问 箭头函数跟ES5匿名函数有什么区别？我提到了this指向，然后就接着问 箭头函数自动绑定this原理是什么？ 嗯…你这个项目怎么配置webpack的？用过gulp吗？webpack跟gulp有啥区别？ React 突出的特性 怎么用git建立一个远程分支 Linux命令知多少？ 怎么把一个链表倒序？ 其他记不清了…. 总结 总的来说，由于面试的特殊时期，面试难度会比春招实习、校招要低很多。 面试会围绕你的简历来问，所以简历写好并且为简历做好准备很重要。 面试大多问的是基础，而且问的很细，经常围绕一个点来深挖，还会问一些经常用到的API，所以面试一定要准备，把一些零碎的知识温习一下，基础很重要。项目问的比较少，但项目决定你简历的质量。 前端要掌握的知识面比较广，但是有一些是构建工程所必须的，最好先培养自己比较全面的基础技术栈，可以足够形成构建一般工程项目的基本能力，然后再深挖。 照目前情况来看，深入理解一门框架是很有必要的，但也没必要多。 前端面试算法问题问的较少(大公司问的较多)，但别告诉我你不知道查找、排序、去重、遍历二叉树… 面试一定要保持平和心态，抱着我已经拿到BAT offer的心态，不紧不慢的交谈，用眼神、肢体语言帮助嘴巴说话；择机展示思考的过程，全程展示对这行的热情。 祝愿大家都能找到心仪的实习、工作。 实习我在滴滴实习了一个多月就走了，原因是学校课太多，导员不让出去，我也意识到了现在还是以学业为重… 实习期间，我参与了两个项目，一个是一个滴滴实时计算平台，另一个是 Druid 管理平台。 实时计算平台，面向滴滴内部工程师，是一个依靠滴滴海量数据完成实时计算、任务调度、自动报警监控等等，项目很大，做了一年了，业界少有吧….我所做的是将我负责的部分数据可视化及国际化； Druid 管理平台，仍面向内部工程师，是一个可视化数据库管理平台，前端由我和另一位实习生负责。我做的是一期核心模块的开发。 最大的体会就是 要对产品有极致追求，不能容忍错误，不能容忍繁琐的操作，还要兼顾所有可能的操作 体会到了海量数据下的性能的重要性，开始关注性能优化 要抱着后台什么数据都有可能产生的考虑，来写健壮的程序，类型检查、空值检测、try catch是必要的 做好渐进增强、功能解耦、组件分离很能体现一个人的编程能力和水平，最忌讳代码粘一块、写死，坑的都是自己,,, 调试很重要，要有写debugger的习惯 时刻准备迎接新技术，哪怕从未听说，只要项目需要，就得立刻上手(我所在的组还是很喜欢用新技术的，只要它好用，License符合) 前后端分离的接口文档遵循规范能少说很多废话 项目管理，敏捷开发是很好的方式 我所在的组开发项目的流程一般是：老大不知道从哪弄来一个需求(可能上级安排的，很多是自己想的…)，然后全员开会说需求、定任务，各成员写排期，后端定具体需求、接口，前端配合后端一同开始，每周报告任务进展… 对前端er来说，改需求不用那么在意，我们最终的目的都是让这个产品更好不是吗？ 实习生很少会接触to C产品，做的大多是面向内部人员，因为出bug好商量嘛… 我所在的部门女工程师还是挺多的，这个的确让我很惊讶(No Offense)… 想到再补充(/ω＼) 这次实习，确实比自学效率高多了，而且最重要的是，开阔了眼界，了解了这行业前沿是个什么情况，大公司又是如何部署前端技术栈开发项目的，以及我自身的不足。我也很幸运，找到了自己感兴趣的方向。","tags":[{"name":"实习","slug":"实习","permalink":"http://realtcg.com/tags/实习/"},{"name":"面试题","slug":"面试题","permalink":"http://realtcg.com/tags/面试题/"}]},{"title":"dva值得一试","date":"2017-08-25T13:30:07.000Z","path":"2017/08/25/dva值得一试/","text":"前言使用React技术栈管理大型复杂的应用往往要使用Redux来管理应用的状态，然而随着深度使用，Redux也暴露出了一些问题。如编写页面配套（action、reducer）过于繁琐、复杂，组件之间耦合较深、不够扁平化、调用action creator发起动作破坏action纯洁性且必须层层传递等。这些缺点迫使使用Redux的人开始探索好的架构方式，解决或减轻使用Redux的问题。业界标杆阿里为此推出了dva 和 Mirror两种改良Redux的架构方案，不过这两者类似，本文就介绍一下dva。 概述本文介绍了dva的产生背景，dva是什么，用来做什么，解决了什么问题，使用场景，原理，实践以及我的使用心得。 背景Redux 文档中介绍，我们需要编写页面的action creator来提交，需要写reducer来更新state，最好对action 和 reducer 做页面为单位的分割，利用redux 给的API 构建容器组件包裹父组件来connect store拿到数据，然后再向下传递给functional component 来渲染，整个过程就实现了单向数据流。当应用复杂起来，一般的做法是配合react-router 做页面分割，光这个分割，你就得 做redux store 的创建，中间件的配置，路由的初始化，Provider 的 store 的绑定，saga 的初始化，还要处理 reducer, component, saga之间的联系…这个没办法，Redux就这么复杂；但是每个页面下要有自己对应的action、reducer，一般还会有saga，这样的话每个页面下都要有四五个文件目录（还有components、containers），每个文件目录下估计还要有不同功能的action、reducer、saga…如果这能忍的话，你在组件里发起action有两个方案，第一：调用经过层层传递的action creator 或者 sagas，第二，让saga监听action，再在组件里直接dispatch相应action类型就行了，不用层层传递，但是得提前 fork -&gt; watcher -&gt; worker…..真的是非常复杂，容易出错。 dva 是什么dva名字取自游戏守望先锋里的一个驾驶机甲的韩国英雄叫dva，大概含义就是Redux的机甲吧… 确实, dva 是基于现有应用架构 (redux + react-router + redux-saga 等)的一层轻量封装，没有引入任何新概念，全部代码不到 100 行。( Inspired by elm and choo. ) dva 帮你自动化了Redux 架构一些繁琐的步骤，比如上面所说的redux store 的创建，中间件的配置，路由的初始化等等,没有什么魔法，只是帮你做了redux + react-router + redux-saga 架构的那些恶心、繁琐、容易出错的步骤，只需写几行代码就可以实现上述步骤，它解决了背景所说的所有缺点。dva介绍 此外，dva重要的特性就是把一个路由下的state、reducer、sagas 写到一块了，清晰明了 12345678910111213141516171819202122232425262728293031323334app.model(&#123; namespace: 'products', //分割的路由，对应要combine到root Reducer里的名字，这里就是state.products state: &#123; //这个路由下初始state list: [], loading: false, &#125;, subscriptions: [ //用来监听路径变化，这里就是当路由为products时dispatch一个获取数据的请求 setup(&#123; dispatch, history &#125;) &#123; return history.listen((&#123; pathname &#125;) =&gt; &#123; if (pathname === 'products') &#123; //dispatch(&#123; type: 'getUserInfo', payload: &#123;&#125; &#125;); &#125; &#125;); &#125;, &#125;, ], effects: &#123; //saga里的effects，里面的各种处理异步操作的saga ['products/query']: function*() &#123; yield call(delay(800)); yield put(&#123; type: 'products/query/success', payload: ['ant-tool', 'roof'], &#125;); &#125;, &#125;, reducers: &#123; // reducers ['products/query'](state) &#123; return &#123; ...state, loading: true, &#125;; &#125;, ['products/query/success'](state, &#123; payload &#125;) &#123; return &#123; ...state, loading: false, list: payload &#125;; &#125;, &#125;,&#125;); dva的思想官方文档 dva就是把之前Redux每个路由下的state、reducer、sagas写到一块去了，做了写到一块去也能做到以前redux能做的事，并且让思路变得很清晰 ： 每个路由下都有一个model，这个model掌管这个路由的所有状态（action、state、reducer、sagas），组件想改变状态dispatch type名字就行了。 实践搞懂框架的脚手架是快速上手这个框架的一个好方法，下面是dva-cli 项目架构123456789101112131415161718.├── src ├── assets # 图片、logo ├── components # 公用UI组件 ├── index.css # CSS for entry file ├── index.html # HTML for entry file ├── index.js # 入口文件 ├── models # 这里存放的就是上面说的dva的model，最好每个路由一个model ├── router.js # 路由文件 ├── routes # 路由组件，跟Redux相同 ├── services # 每个页面的services，通常是获取后端数据的接口定义 └── utils # 存放一些工具 └── request.js # 这里封装一个用来与后端通信的接口├── .editorconfig #├── .eslintrc # Eslint config├── .gitignore #├── .roadhogrc # Roadhog config└── package.json # 按照dva的架构，每个路由下都有个model层，在model定义好这个路由的initialstate、reducers、sagas、subscriptions；然后connect组件，当在组件里发起action时，直接dispatch就行了，dva会帮你自动调用sagas/reducers。当发起同步action时，type写成&#39;(namespace)/(reducer)&#39;dva就帮你调用对应名字的reducer直接更新state，当发起异步action，type就写成&#39;(namespace)/(saga)&#39;,dva就帮你调用对应名字的saga异步更新state，非常方便： 在组件里： 12345678...const &#123; dispatch &#125; = this.propsdispatch(&#123; type: 'namespace/sagas', //这里的type规范为model里面定义的namespace和effects下面定义的sagas或者 payload: &#123; // reducers,这样就能实现自动调用这些函数 ... &#125;&#125;) 注意，dispatch用来更新state某个数据后，下一步从state拿到的这个数据并不是更新后的： 12345678910... const &#123; dispatch, data &#125; = this.props dispatch(&#123; type: 'namespace/sagas', //这里的type规范为model里面定义的namespace和effects下面定义的sagas或者 payload: &#123; // reducers,这样就能实现自动调用这些函数 data //这里想更新data &#125; &#125;) console.log(data) // 仍然是之前的数据，并不是dispatch更新后的数据 // 因为dispatch是异步的，如同React的setState后面打印state 此外，由于不用层层传递action creator，mapDispatchToProps就不用再写了，组件之间的耦合度也降低了，或者说根本没有关系了，dva使组件之间的关系变得更加扁平化,没有什么父子、兄弟关系，这样组件就具有很高的可重用性。所有需要在组件里通信的数据都要放在state中，然后connect组件，只拿到组件关心的数据，就像这样： 123456789101112131415class App extends Component &#123; ...&#125; function mapStateToProps(state) &#123; const &#123; data &#125; = state.user; // user 对应namespace const loading = state.loading.effects['user/fetch']; return &#123; data, loading &#125;;&#125;export default connect(mapStateToProps)(User); 这样写，除了具有很高的重用性，也避免了父组件更新，子组件也会随之更新的缺点了！只要这个组件关心的数据没变，它就不会重新渲染，省掉了重写shouldComponentUpdate来提高性能，逻辑也变得清晰、简单起来！ 另外，model下有个subscriptions用于订阅一个数据源，可以在这里面监听路由变化，比如当路由跳转到本页面时，发起请求来获取初始数据： 12345678910111213subscriptions: &#123; setup: (&#123; history, dispatch &#125;) =&gt; history.listen((&#123; pathname, query &#125;) =&gt; &#123; if (pathname === '/user') &#123; dispatch(&#123; type: 'fetch', payload: &#123; query &#125; &#125;); &#125; &#125;), &#125;,&#125;; 问题使用没多久，了解较浅，暂时没发现什么问题 总结dva框架封装了Redux 架构一些繁琐、复杂的步骤和常用库，使用dva，不会构建Redux架构也可以，dva帮你做好了; dva 降低了组件之间的耦合度，没有父子、兄弟组件的关系，提高了组件可重用性以及渲染性能，使思路变得简单清晰； dva架构思路清晰，代码书写方式固定，有利于团队合作，但可扩展性不强","tags":[{"name":"React","slug":"React","permalink":"http://realtcg.com/tags/React/"},{"name":"dva","slug":"dva","permalink":"http://realtcg.com/tags/dva/"}]},{"title":"对使用Redux和Redux-saga管理状态的思考","date":"2017-08-12T10:32:45.000Z","path":"2017/08/12/对使用Redux和Redux-saga管理状态的思考/","text":"概述本文介绍了我对 Redux 状态管理的思想、原理、架构方法的认识和思考以及配合redux-saga处理异步操作的实践 前言You know, React 只是属于MV*架构模式的 view 层，是一种状态机，只使用 React 难以控制大型、复杂的应用，它需要一些框架来帮助管理状态，因此如何有效、简单、易于测试地管理这个状态机是各种架构框架感兴趣的。Facebook 早就意识到这个问题并提出了 Flux 架构，比较复杂; 后来出现了 Redux、Mobx 等。MobX 可以处理简单数据流的场景，可以实现精确更新; Redux 是从 Flux 和其他框架借鉴了一些思想， 它比 Flux 简单、易于理解、用于处理复杂数据流，并具有很强的扩展性，社区诞生了像redux-thunk、redux-promise、redux-saga等中间件用于方便地处理异步操作。最近也在项目中使用了 Redux 及其中间件 redux-saga 来管理状态和处理异步操作，这篇文章就来谈谈我对它们的思考和实践。 正文Redux 思想先来谈谈背景（需求） 我觉得理解Redux的思想，谈谈MV*架构模式的思路也许会有帮助。 MV*架构模式，它们的核心都是职责分离、解耦，不同的层次做不同的事，能让一个复杂、混乱的应用变得思路清晰，代码可以复用，并且易于测试，有利于分工合作，构建更大、更复杂的应用。 一个应用要包括哪些功能？表现（view）、处理数据的逻辑（model）以及数据映射到表现层的逻辑（presenter or controller），数据在这三层之间流通（MVVM模式通过数据双向绑定实现view和model同步）。 React 根据state来render，它只是个状态机，并没有解决管理状态的问题。我们在单纯的使用React来写组件的时候，经常会遇到组件间通信和管理组件state的问题，前者常用的解决办法就是把数据提到父组件共享；后者管理state简单的情况还行，一复杂就很麻烦且容易出错，再遇到一些需要异步处理的操作，想想就头皮发麻。 当你开发中遇到一些反人类的操作时，试着去想如何改变一下思路让它变得更简单，别耐着性子安慰自己开发就是这样 :) 解决方案 Redux 正是用来解决大型React应用所面临的状态管理、数据流通、异步处理、测试、团队合作等问题： Redux 用单一的object tree来表示整个应用的state，这个表示state的对象树被放在唯一的store 中，state相当于store的快照；所有组件都会通过API拿到这个state，各取所需； Redux 把页面上用户的操作或者浏览器的行为（如路由的变化）定义为一个要更新state的action，这个action是一个普通对象，它包含了要执行动作的类别和传递到state的数据（如果有的话），它只表明要更改state的意图，相当于一个信号，并不能直接修改state，Redux会集中处理这些信号，这个action由你来决定何时发起； 定义好信号，你还需要根据不同的信号定义不同的逻辑函数（reducers）来更新state。 通过这张图来整理一下： 咳咳…比如用户点击的一个按钮，你在按钮上绑定的回调函数调用了一个（多个）action creator，action creator就返回了一个更新state局部数据的action，store会根据这个（多个）action找到对应的reducers（reducer需要做拆分），按照action发起的顺序依次执行来更新state，每个reducer只负责更新自己关心那部分，根 reducer 把多个子 reducer 输出合并成一个单一的 state 树，生成一个新的state保存在store中，store中的state可以通过相应API传递到子组件。 这就是整个数据流。 那Redux如何处理异步操作？ Redux借鉴了中间件思想，利用可扩展的中间件来改造dispatch函数。比如redux-thunk让dispatch不仅仅可以接收action，还可以接受函数作为参数，你可以在这个函数里完成异步操作。再如redux-saga更强大、也更复杂，在后面会讲到。 Redux 架构方法对于React技术栈，Redux实现了react-redux库来让Redux管理React应用（其他框架也有相应的库），里面集成了一些有用的函数来把一些明确的流程自动化，如createStore用于创建唯一store，可以把根reducer传进createStore使store自动调用对应reducer，可以扩展中间件；提供&lt;Provider store&gt;组件和connect高阶组件用来包裹render component并传递state，connect还能自动dispatch，让你只要调用action creator就能dispatch；提供combineReducers来组合分割的reducers等。 知道这些特性，就可以配合react-router构建大型应用了： 总的思路就是：利用react-router 把应用分割为各个页面，reducer、action creator也跟随页面分割而分割。每个路由对应的页面下都有components和containers，分别存放functional components 和class components，前者用来渲染，后者当做containers被connect包裹，containers包裹components；containers从connect得到state并映射需要的数据到子组件的props，子组件再向下传递。 具体如何构建React + Redux + react-router，我在另一篇博客里讲了。 使用这种架构，开发大型应用变得得心应手。 Redux 存在的问题但是当我深入项目开发的时候，也逐渐发现了一些问题： 这种架构项目结构不够扁平化，文件嵌套比较深，思路比较复杂，搭建、写起来比较麻烦，上手有难度； 由于所有action creator都定义在页面层次上，让子组件调用必须一层一层的传递，很麻烦且非常容易出错，也很难调试； state难以做到局部更新（这个可以用reselect） Redux只是传递了一种思路，定义了几个简单的API，很灵活，架构方式不固定，设计方式不固定（如：如何设计state树）但这也是它的缺点，新人往往看完一遍还是不知道怎么做，对新人不友好 总之，redux可以胜任复杂数据流的应用，但是也比较难，前期架构比较麻烦，适合有经验的人。 使用redux-saga处理异步操作Redux 倡导action 和reducer尽可能”纯净”，没有什么“副作用”。可是像一些异步操作比如获取数据是必须的，在哪处理这些副作用呢？redux 把这些”不纯净的”任务交给了中间件，通过 向createStore里应用中间件，在交由store处理action之前就可以对其完成一些其他的操作： 而redux-saga 是Redux一个强大但并不复杂的用于异步处理的中间件。 它的思路是什么？相比其他redux异步中间件如redux-thunk、redux-promise有什么不同？ 先看名字来理解：saga，这个术语常用于CQRS架构，代表查询与责任分离。 没错，就是查询（dispatch）与责任（sagas）分离。saga提供了action监听函数，只需在组件里dispatch 相应type的action，就可以自动调用你定义好的对应这个action的异步处理函数（sagas）来完成任务，保证了只在组件里dispatch action来发起异步操作而不是redux-thunk、redux-promise的调用action creators。 另外一大特色就是redux-saga做到了异步代码以同步方式写，非常直观方便，怎么做到的呢？它是利用了ES6新魔法Generator迭代器，可以完美解决异步回调地狱，让你以同步方式写异步。saga正是利用Generator特性让其处理异步变得非常方便又容易理解。这是一个常见的请求后台数据的异步操作，感受一下： 1234567891011121314151617function *fetchNodeDetailByNodeId(&#123; payload: &#123; nodeId &#125; &#125;, &#123; call, put &#125;) &#123; try &#123; const &#123; data, status &#125;= yield call(fetchNodeDetailByNodeId, nodeId) if (data &amp;&amp; status.errmsg === 'success') &#123; yield put(&#123; type: 'setStates', payload: &#123; nodeDetailData: data, &#125;, &#125;); &#125; else &#123; message.info('开了个小差,再试一次吧..'); &#125; &#125; catch (error) &#123; console.log(error); &#125; &#125;, call 和 put 是saga的API，相当于dispatch，但是并不是真正执行dispatch，只是发送你指定的指令，交由saga中间件来执行这个指令。这样看来，这个saga函数就是一些指令的集合，称为effects，副作用，用来描述任务 为啥要描述指令而不直接调用呢？这样是因为易于测试，如果直接调用，你还得模拟调用的函数，详见redux-saga文档。 我觉得redux-saga相比于其他中间件的优点： 查询与责任分离，保证了action的纯洁性，符合redux设计思想 实现以同步方式写异步操作，容易理解，逻辑清晰 通过发送指令而不是直接调用让异步操作变得容易测试 监听、执行自动化 提供了丰富强大的指令来完成复杂的操作，比如无阻塞调用，同时执行多个任务等 讲道理，任何redux异步操作都可以让saga这个中间件来完成，非常复杂的同样可以胜任，并且很容易理解（异步操作以同步方式写）和测试。再配合dva，可以减轻redux的复杂度同时完成更强大的功能。 这样以来，redux配合saga，就可以让它们各司其职，整个思路也变得清晰起来： redux 倡导action和reducer要纯洁，那就让所有异步操作这些不纯洁的任务交给saga，reducer不用变，还是纯函数；定义好对应action的sagas专门用来处理异步操作，我只要在组件需要的地方里dispatch 纯action就行了，符合redux设计思想。 总结使用redux来管理应用状态适用于复杂的应用，而复杂的应用会有复杂的异步处理，异步处理不要用redux的action creator，它不是用来做这个的，也违背了redux设计思想，redux把这些任务交给了异步中间件，应该由它们来完成。使用redux saga是一个推荐的选择，它懂redux，也懂你需要什么。另外，既然你用到了saga，不妨试试dva架构，5分钟上手，值得一试。","tags":[{"name":"Redux","slug":"Redux","permalink":"http://realtcg.com/tags/Redux/"},{"name":"Redux saga","slug":"Redux-saga","permalink":"http://realtcg.com/tags/Redux-saga/"}]},{"title":"对React一些原理的理解","date":"2017-06-25T09:12:58.000Z","path":"2017/06/25/对React一些原理的理解/","text":"前言随着项目开发的深入，不可避免了遇到了一些问题。刚开始出现问题时很懵，不知道该怎么解决，原因就是对React的原理理解的不够透彻，不知道问题出在哪。在解决问题的过程中，也逐渐深入了解了React的一些原理，这篇文章就来分享一下我对React一些原理的理解。 注意 这篇文章并不是教程，只是我对React原理的一些个人理解，欢迎与我一起讨论。文章不对的地方，还请读者费心指出^-^ 概述本文是《使用React技术栈的一些收获》系列文章的第二篇(第一篇在这里，介绍如何开始构建React大型项目)，简单介绍了React一些原理，包括React合成事件系统、组件的生命周期以及setState()。 React合成事件系统React快速的原因之一就是React很少直接操作DOM，浏览器事件也是一样。原因是太多的浏览器事件会占用很大内存。 React为此自己实现了一套合成系统，在DOM事件体系基础上做了很大改进，减少了内存消耗，简化了事件逻辑，最大化解决浏览器兼容问题。 其基本原理就是，所有在JSX声明的事件都会被委托在顶层document节点上，并根据事件名和组件名存储回调函数(listenerBank)。每次当某个组件触发事件时，在document节点上绑定的监听函数（dispatchEvent）就会找到这个组件和它的所有父组件(ancestors)，对每个组件创建对应React合成事件(SyntheticEvent)并批处理(runEventQueueInBatch(events))，从而根据事件名和组件名调用(invokeGuardedCallback)回调函数。 因此，如果你采用下面这种写法，并且这样的P标签有很多个： 12345listView = list.map((item,index) =&gt; &#123; return ( &lt;p onClick=&#123;this.handleClick&#125; key=&#123;item.id&#125;&gt;&#123;item.text&#125;&lt;/p&gt; )&#125;) That’s OK，React帮你实现了事件委托。我之前因为不了解React合成事件系统，还显示的使用了事件委托，现在看来是多此一举的。 由于React合成事件系统模拟事件冒泡的方法是构建一个自己及父组件队列，因此也带来一个问题，合成事件不能阻止原生事件，原生事件可以阻止合成事件。用 event.stopPropagation() 并不能停止事件传播，应该使用 event.preventDefault()。 如果你想详细了解React合成事件系统，移步http://blog.csdn.net/u013510838/article/details/61224760 组件的生命周期（以父子组件为例）为了搞清楚组件生命周期，构造一个父组件包含子组件并且重写各生命周期函数的场景： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Child extends React.Component &#123; constructor() &#123; super() console.log('Child was created!') &#125; componentWillMount()&#123; console.log('Child componentWillMount!') &#125; componentDidMount()&#123; console.log('Child componentDidMount!') &#125; componentWillReceiveProps(nextProps)&#123; console.log('Child componentWillReceiveProps:'+nextProps.data ) &#125; shouldComponentUpdate(nextProps, nextState)&#123; console.log('Child shouldComponentUpdate:'+ nextProps.data) return true &#125; componentWillUpdate(nextProps, nextState)&#123; console.log('Child componentWillUpdate:'+ nextProps.data) &#125; componentDidUpdate()&#123; console.log('Child componentDidUpdate') &#125; render() &#123; console.log('render Child!') return ( &lt;h1&gt;Child recieve props: &#123;this.props.data&#125;&lt;/h1&gt; ); &#125;&#125;class Father extends React.Component &#123; // ... 前面跟子组件一样 handleChangeState()&#123; this.setState(&#123;randomData: Math.floor(Math.random()*50)&#125;) &#125; render() &#123; console.log('render Father!') return ( &lt;div&gt; &lt;Child data=&#123;this.state.randomData&#125; /&gt; &lt;h1&gt;Father State: &#123; this.state.randomData&#125;&lt;/h1&gt; &lt;button onClick=&#123;this.handleChangeState&#125;&gt;切换状态&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;React.render( &lt;Father /&gt;, document.getElementById('root')); 结果如下：刚开始调用父组件的setState后：在Jsbin上试试看有一张图能说明这之间的流程（图片来源）： setState并不奇怪有一个能反映问题的场景： 12345678910...state = &#123; count: 0&#125;componentDidMount() &#123; this.setState(&#123;count: this.state.count + 1&#125;) this.setState(&#123;count: this.state.count + 1&#125;) this.setState(&#123;count: this.state.count + 1&#125;)&#125;... 看起来state.count被增加了三次，但结果是增加了一次。这并不奇怪： React快的原因之一就是，在执行this.setState()时，React没有忙着立即更新state，只是把新的state存到一个队列（batchUpdate）中。上面三次执行setState只是对传进去的对象进行了合并,然后再统一处理（批处理），触发重新渲染过程，因此只重新渲染一次，结果只增加了一次。这样做是非常明智的，因为在一个函数里调用多个setState是常见的，如果每一次调用setState都要引发重新渲染，显然不是最佳实践。React官方文档里也说了： Think of setState() as a request rather than an immediate command to update the component. 把setState() 看作是重新render的一次请求而不是立刻更新组件的指令。 那么调用this.setState()后什么时候this.state才会更新？答案是即将要执行下一次的render函数时。 这之间发生了什么？setState调用后，React会执行一个事务（Transaction），在这个事务中，React将新state放进一个队列中，当事务完成后，React就会刷新队列，然后启动另一个事务，这个事务包括执行 shouldComponentUpdate 方法来判断是否重新渲染，如果是，React就会进行state合并（state merge）,生成新的state和props；如果不是，React仍然会更新this.state，只不过不会再render了。 开发人员对setState感到奇怪的原因可能就是按照上述写法并不能产生预期效果，但幸运的是我们改动一下就可以实现上述累加效果：这归功于setState可以接受函数作为参数： setState(updater, [callback]) 12345678910...state = &#123; score: 0&#125;componentDidMount() &#123; this.setState( (prevState) =&gt; (&#123;score : prevState.score + 1&#125;) ) this.setState( (prevState) =&gt; (&#123;score : prevState.score + 1&#125;) ) this.setState( (prevState) =&gt; (&#123;score : prevState.score + 1&#125;) ) &#125;&#125; 这个updater可以为函数，该函数接受该组件前一刻的 state 以及当前的 props 作为参数，计算和返回下一刻的 state。 你会发现达到增加三次的目的了: 在Jsbin上试试看 这是因为React会把setState里传进去的函数放在一个任务队列里，React 会依次调用队列中的函数，传递给它们前一刻的 state。 另外，不知道你在jsbin上的代码上注意到没有，调用setState后console.log(this.state.score)输出仍然为0，也就是this.state并未改变，并且只render了一次。 总结学习一个框架或者工具，我觉得应该了解以下几点： 它是什么？能做什么？ 它存在的理由是什么？解决了什么样的问题、满足了什么样的需求？ 它的适用场景是什么？优缺点是什么？ 它怎么用？最佳实践是什么？ 它的原理是什么？ … 通过对React一些原理的简单了解，就懂得了React为什么这么快速的原因之一，也会在问题出现时知道错在什么地方，知道合理的解决方案。","tags":[{"name":"React","slug":"React","permalink":"http://realtcg.com/tags/React/"},{"name":"React基础","slug":"React基础","permalink":"http://realtcg.com/tags/React基础/"}]},{"title":"React + Redux + react router技术栈架构","date":"2017-06-24T11:59:52.000Z","path":"2017/06/24/React + Redux + react router技术栈架构/","text":"前言前些日子刚学习了React，觉得很不错，很符合我的逻辑。于是还没弄明白，就迫不及待的开始了一个中型项目(我觉得）（其实是项目需要赶紧开始，没时间了…咳咳）。期间不出所料地遇到了很多坑和问题，也得到了很多收获，特开几篇文章记录下来。 概述本文是《使用React技术栈的一些收获》系列文章的第一篇，介绍了项目是如何架构的。 具体技术栈项目技术栈使用的是React全家桶：React+redux+react router+es6+webpack+sass以及Data到View层我们使用了reselect。由于数据处理逻辑并不复杂，因此并没有使用immutable.js和Redux saga（后来我觉得连Redux都没必要用）；样式方面考虑到可读性和开发人数较少（俩），我们并没有使用流行的CSS-module。 脚手架的选择选择脚手架就选择了整体架构，我选择的是davezuko大神的react-redux-starter-kit，也是最受欢迎的脚手架之一。并在它的基础上安装了一些用到的包，删去了一些不用的包，让它更适合我们的项目。 项目架构项目目录如下：​ 根据脚手架的架构，我们构建的是一个React单页应用。 总体来说就是采用React router plain object+combineReducer+require.ensure的写法把不同的路由分割在routes目录下，对应不同的页面，做代码分割、按需加载。逻辑图如下： 具体来说首先src目录下有一个main.js，它用来创建store，并拿到路由（plain object形式），然后注入到顶层的Provider组件和其下的Router组件： src下的main.js文件：12345678910111213const initialState = window.___INITIAL_STATE__const store = createStore(initialState)// 创建storeconst MOUNT_NODE = document.getElementById('root')let render = () =&gt; &#123; const routes = require('./routes/index').default(store)// 拿到路由 ReactDOM.render( &lt;AppContainer store=&#123;store&#125; routes=&#123;routes&#125; /&gt;, //注入 MOUNT_NODE )&#125; redux的store也随着页面分割而分割：​ 不同页面下的modules下的文件只负责本页面所需的所有action和reducer，并通过加载页面inject主reducer里，然后在src/store/reduce.js文件里combine,最后被引入到src/store/createStore里和同时引入的redux中间件一起创建store： src/store目录下的reducer.js：12345678910111213export const makeRootReducer = (asyncReducers) =&gt; &#123; return combineReducers(&#123; auth: auth, form: formReducer, location: locationReducer, ...asyncReducers // 各页面下的reducer注入到这里 &#125;)&#125;export const injectReducer = (store, &#123; key, reducer &#125;) =&gt; &#123; store.asyncReducers[key] = reducer store.replaceReducer(makeRootReducer(store.asyncReducers))//注入时更新&#125; 以及src/store下的createStore文件：12345678const store = createStore( makeRootReducer(), initialState, compose( applyMiddleware(...middleware), ...enhancers ) ) routes目录下有一个index.js文件，它使用plain object的写法集合各路由对应的页面； routes下的index.js文件：（用来包含各页面）src/routes/index.js:(采用React router plain object写法) 12345678910111213141516171819202122import CoreLayout from '../layouts/CoreLayout'import Home from './Home'import FollowRoute from './Follow'import SignRoute from './Sign'import HallRoute from './Hall'import UserPageRoute from './UserPage'import PageNotFound from './PageNotFound'import Redirect from './PageNotFound/redirect'export const createRoutes = (store) =&gt; (&#123; path: '/', component: CoreLayout, indexRoute: Home, childRoutes: [ // 各页面 FollowRoute(store), SignRoute(store), HallRoute(store), UserPageRoute(store), PageNotFound(), Redirect ]&#125;) 每个页面目录下也有一个index.js文件并使用getComponent + webpack ensure按需加载页面的container和reducer： 每个页面下的index.js文件：(负责输出这个页面)src/routes/sign/index.js（其他页面差不多，举个例子） 12345678910111213import &#123; injectReducer &#125; from '../../store/reducers'// 引入注入reducer函数export default (store) =&gt; (&#123; path: 'sign', //页面路由 getComponent (nextState, cb) &#123; require.ensure([], (require) =&gt; &#123; // webpack按需加载 const Sign = require('./containers/SignContainer').default //引入总container const reducer = require('./modules/index').default//引入总reducer injectReducer(store, &#123; key: 'sign', reducer &#125;)// 加载时注入页面reducer到主reducer cb(null, Sign)// 返回页面 &#125;) &#125;&#125;) 在每个页面下，index.js是获得每个页面的入口，每个页面都有自己的components和containers以及actions和reducers，目录看起来像这样： components和containers都是这个页面下的组件和容器，如果其他页面也会使用里面的组件和容器，就会把他们放在src/component和src/containers下共用。modules下的文件是这个页面所有的action和reducer。如果页面逻辑可以分离，会把各逻辑下的reducer抽离并单开一个index.js，并在其中combine： ​ =&gt; 总结与反思通过上述架构，项目代码逻辑变得很清晰，每一个文件都有其专属的功能，互不影响，开发过程变得工程化、流程化，思路很清晰，代码出错率大大降低，开发速度大大提高。React router plain object+redux combineReducer的组合很好的将代码按不同页面做了分割;而 getComponent + webpack ensure又做到了页面的按需加载，项目页面运行速度提升了不少。但是有一个问题，在react route4.0版本中getComponent被移除了，并提供了更加简洁的方式（实际上就是替你做了按需加载）：Bundle组件+webpack 加载器undle-loader。使用这种方式的话，目录结构将会变得更简单、更容易理解，避免了多层嵌套，因此，项目还需要改善。","tags":[{"name":"React","slug":"React","permalink":"http://realtcg.com/tags/React/"},{"name":"React架构","slug":"React架构","permalink":"http://realtcg.com/tags/React架构/"}]},{"title":"JavaScript常用函数总结(一)","date":"2017-05-12T16:00:44.000Z","path":"2017/05/13/JavaScript常用函数总结-一/","text":"前言最近在使用React技术栈时并没有选用jQuery,想借此巩固一下原生API,提高原生开发能力,毕竟这才是内功。 概述本文总结了JavaScript常用函数，这些函数包括Array常用函数以及String常用函数 JavaScript原生函数Array常用函数 isArray() -判断某个值是不是数组类型 123if(Array.isArray(value))&#123; //对数组进行操作&#125; join(&quot;分隔符&quot;) 12var a = [1,2,3,4,5]; var b = a.join(\"|\"); //a：[1,2,3,4,5] b：\"1|2|3|4|5\" 栈方法 push() -可以接受任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度： 1234var colors = new Array();var count = colors.push(\"red\",\"green\");console.log(colors);//[\"red\",\"green\"]console.log(count);//2 pop() -从数组末尾移除最后一项，减少数组length值，然后返回移除的项 123var item = colors.pop();console.log(item);//\"green\"console.log(colors.length);//1 队列方法 shift() -移除数组的第一项并返回该项，同时将数组长度减一 123var item = colors.shift();console.log(item);//\"red\"console.log(colors.length);//1 unshift() -在数组前端添加任意个项并返回新数组的长度 12var count = colors.unshift(\"yellow\",\"black\");console.log(colors);//[\"yellow\",\"black\",\"red\",\"green\"] 重排序方法 reverse() -反转数组项的顺序 12var values = [1,2,3,4,5];console.log(values.reverse());//5,4,3,2,1 sort() -默认情况下按升序排列数组项，即最小的值在前。为了实现排序，sort方法会调用每个数组项的toString(),然后比较字符串，以确定排序。即使数值项是数字，比较的也是字符串，这通常不是最佳方案，因此sort()可以接受一个比较函数作为参数，返回经过排序后的数组 1234567var values = [0,1,5,10,15];console.log(values.sort());//0,1,10,15,5function compare(value1,value2)&#123;return value2 - value1;&#125;console.log(values.sort(compare));//0,1,5,10,15 操作方法 concat() -合并数组的意思,可以接受n个字符串或数组。 123var colors = [\"red\",\"green\",\"pink\"];var color2 = colors.concat(\"bliue\",[\"black\",\"yellow\"]);//[\"red\",\"green\",\"pink\",\"blue\",\"black\",\"yellow\"] 先创建一个数组副本，然后将接受到的参数添加到副本末尾，最后返回新构建的数组，原数组不会受到影响。 slice() -切数组的意思，接受一到两个数值型参数表示切下的起始结束位置 123var colors = [\"red\",\"green\",\"pink\"];var color1 = colors.slice(1);//[\"green\",\"pink\"]var color2 = colors.slice(1,2); //[\"green\"] slice()同样不会对原数组产生影响，它会创建一个副本操作后返回。参数可以为负数。 splice() -剪接的意思，可以实现数组的删除、插入、替换。 splice(起始位置,删除的项数,插入的项(可以多个项,可选)) 返回从原始数组中删除的项,对原数组直接操作 123var colors = [\"red\",\"green\",\"pink\"];var color1 = colors.splice(0,1);//[\"green\",\"pink\"],删除第一项var color2 = colors.splice(1,0,\"black\"); //[\"green\",“black”,\"pink\"] indexOf() -返回查找的项的位置，接受两个参数，indexOf(要查找的项(可选),查找起点位置索引),它会使用===来查 1234var colors = [\"red\",\"green\"];console.log(colors);//[\"red\",\"green\"]console.log(color2);/ 迭代方法 以下每个迭代函数都会接受两个参数，一个是要在每一项运行的函数和运行在该函数的作用域对象——影响this的值，为数组的每一项运行的给定函数接受三个参数：function(数组的项,该项在对象的位置,数组本身){} every() -如果该函数对每一项都返回true，则返回true filter() -返回该函数会返回true的项组成的数组 forEach() -单纯运行给定函数，无返回值 map() -返回给定函数运行在数组中的每个项的结果组成的数组 some() -如果该函数对任一项返回true，则返回true 1234567891011121314151617181920 var values = [1,2,3,4,5]; console.log(values.every(function(item)&#123; return (item&gt;2); &#125;));//false console.log(values.some(function(item)&#123; return (item&gt;2); &#125;));//true console.log(values.filter(function(item)&#123; return (item&gt;2); &#125;));//[3,4,5] console.log(values.map(function(item)&#123; return (item*2); &#125;));//[2,4,6,8,10] console.log(values.forEach(function(item)&#123; //执行某些操作&#125;)); 归并方法 reduce() -浓缩的意思，接受一个给定函数（function(pre,cur,index,array){}）和作为归并基础的值（可选），迭代数组所有项，返回一个构建的值 1234var values = [1,2,3,4,5];console.log(values.reduce(function(pre,cur,index,array)&#123;return pre + cur;&#125;));//15 String常用函数 查找方法 字符串方法 charAt(n)返回字符串中第n(0~length-1)个字符； charCodeAt(n)返回字符串中第n个字符的Unicode编码； fromCharCode(0或多个字符的Unicode编码)返回根据字符编码创建的字符串 位置方法 indexOf(要查找的字符串,开始查找位置（可选）)返回找到的子串首次出现的索引或-1（未找到）。可以用于数组查找项，不能查找对象。 匹配方法 match(正则表达式)返回存放匹配结果的数组，正则如果没有加全局标记g那么这个数组会有个input属性，它指向调用match()的字符串对象.未找到返回null. 12345var str = \"hello,world\";str.match(\"he\");[\"he\", index: 0, input: \"hello,world\"]str.match(/he/);//[\"he\", index: 0, input: \"hello,world\"]str.match(/he/g);//[\"he\"]str.match(/l/g);//[\"l\", \"l\", \"l\"] search(正则表达式)返回字符串中第一个与正则表达式相匹配的子串的索引，忽略全局标记g和lastIndex属性 12345var str = \"hello,world\";str.search(\"he\");//0str.search(/he/);//0str.search(/he/g);//0str.match(/l/g);//2 replace(正则(字符串),替换文本或函数)创建一个原字符串副本，替代后返回 123var str = \"hello,world\";str.replace(/l/g,\"b\");//\"hebbo,worbd\"console.log(str);//\"hello,world\" split(分隔符,(数组长度))返回根据指定分隔符将字符串分割成多个子串组成的数组,这个分隔符必须是原字符串里的某个字符，否则返回原字符串 123var str = \"hello,world\";str.split(\"\");//[\"h\", \"e\", \"l\", \"l\", \"o\", \",\", \"w\", \"o\", \"r\", \"l\", \"d\"]str.split(\"o\");//[\"hell\", \",w\", \"rld\"] 操作方法 concat(string,...)返回把所有参数都连接到原字符串后形成的字符串 slice(剪切的起始位置,结束位置)返回剪切后的字符串，创建副本，原字符串不变 substring()功能与slice相同，不同的是参数不能为负 trim()清楚字符串（注意不是字符）前后的空格 编码方法 escape(string)、unescape(string)返回字符串常规编码（解码） encodeURI(string)、decodeURI(string)URI字符串编码与解码 转换方法 toUpperCase()、toLocaleUpperCase()转为大写 toLowerCase()、toLocaleLowerCase()转为小写","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://realtcg.com/tags/JavaScript/"},{"name":"JavaScript函数","slug":"JavaScript函数","permalink":"http://realtcg.com/tags/JavaScript函数/"}]},{"title":"我对JavaScript对象的理解","date":"2017-04-16T04:53:16.000Z","path":"2017/04/16/我对JavaScript对象的理解/","text":"前言JavaScript这门语言除了基本类型都是对象，可以说JavaScript核心就是对象，因此理解JavaScript对象及其种种特性至关重要，这是内功。本文介绍了我对es5对象，原型, 原型链,以及继承的理解 注意（这篇文章特别长）这篇文章仅仅是我个人对于JavaScript对象的理解，并不是教程。这篇文章写于我刚了解js对象之后。文章肯定有错误之处，还望读者费心指出，在下方评论即可^-^ 什么是JavaScript对象12345678910111213141516var person = &#123; //person就是对象，对象都有各种属性，每个属性又都对应着自己的值 //键值对形式 name: \"Mofan\",//可以包含字符串 age: 20,//数字 parents: [ //数组 \"Daddy\", \"Mami\", ] sayName: function()&#123; //函数 console.log(this.name); &#125;, features: &#123; //对象 height: \"178cm\", weight: \"60kg\", &#125;&#125; js里除了基本类型外所有事物都是对象： 函数是对象：function sayName(){} ` `——sayName是函数对象 数组是对象：var arr = new Array() ——arr是数组对象 为什么JavaScript要这么设计呢？我觉得首先这样一来，统一了数据结构，使JavaScript成为一门编程风格非常自由化的脚本语言：无论定义什么变量，统统var；其次，JavaScript对象都有属性和方法，函数数组都是对象，调用引用就会非常灵活方便；再者，为了构建原型链？ 创建对象的几种方式 Object()模式使用对象字面量：var obj={...}就像上面那样或者使用原生构造函数Object()： 1234567var person = new Object();person.name = \"Mofan\";person.sayName = function()&#123; console.log(this.name); &#125;;console.log(person.name);//Mofanobj.sayName();//Mofan 利用函数作用域使用自定义构造函数模式模仿类（构造器模式）： 12345678910function Person(name,age)&#123; this.name = name; this.age = age; this.print = function()&#123; console.log(this.name + this.age) &#125;;&#125;var person = new Person(\"Mofan\",19);console.log(person.name+person.age);//Mofan19person.print();//Mofan19 原型模式： 12345678910111213141516171819function Person()&#123;&#125;//可以这样写/*Person.prototype.name = \"Mofan\";Person.prototype.age = 19;Person.prototype.print = function()&#123; console.log(this.name+this.age);&#125;*///推荐下面这样写，但两种方式不能混用！因为下面这种方式实际上重写了//Person原型对象，如果两者混用，后面赋值方式会覆盖前面赋值方式Person.prototype = &#123; name:\"Mofan\", age:19, print:function()&#123; console.log(this.name+this.age); &#125;&#125;var person = new Person();console.log(person.name+person.age);//Mofan19person.print();//Mofan19 组合构造函数模式和原型模式： 12345678910111213141516function Person(name,age)&#123; //这里面初始化属性 this.name = name; this.age = age; ...&#125;Person.prototype = &#123; //这里面定义公有方法 print:function()&#123; console.log(this.name+this.age); &#125;, ...&#125;var person = new Person(\"Mofan\",19);console.log(person.name+person.age);//Mofan19person.print();//Mofan19 动态创建原型模式： 1234567891011121314151617181920function Person(name,age)&#123; //初始化属性 this.name = name; this.age = age; //在创建第一个对象（第一次被调用）时定义所有公有方法,以后不再调用 if(typeof this.print !=\"function\")&#123; Person.prototype.print =function()&#123; console.log(this.name+this.age); &#125;; Person.prototype.introduction=function()&#123; console.log(\"Hi!I'm \"+this.name+\",I'm \"+this.age); &#125;; //如果采用对象字面量对原型添加方法的话，第一次创建的对象将不会有这些方法 &#125;; &#125;var person = new Person(\"Mofan\",19);person.print();//Mofan19person.introduction();//Hi!I'm Mofan,I'm 19 还有一些模式用的场景比较少 这些模式的应用场景怎么会有这么多的创建模式？其实是因为js语言太灵活了，因此前辈们总结出这几种创建方式以应对不同的场景，它们各有利弊。 第一种方式，使用字面量或者使用构造函数Object()常用于创建普通对象存储数据等。它们的原型都是Object，彼此之间没有什么关联。事实上，下面创建方式都是一样的： 123456var o1 = &#123;&#125;;//字面量的表现形式var o2 = new Object;var o3 = new Object();var o4 = new Object(null);var o5 = new Object(undefined);var o6 = Object.create(Object.prototype);//等价于 var o = &#123;&#125;;//即以 Object.prototype 对象为一个原型模板,新建一个以这个原型模板为原型的对象 第二种方式，利用函数作用域模仿类，这样就可以在创建对象时传参了，可以创建不同属性值得对象，实现对象定制。不过print方法也定义在了构造函数里面，如果要把它当做公有方法的话，这样每new一个对象，都会有这个方法，太浪费内存了。可以这样修改一下构造器模式： 1234567891011121314//构造器方法2function print()&#123; //定义一个全局的 Function 对象,把要公有的方法拿出来 console.log(this.name + this.age);&#125;function Person(name,age)&#123; this.name = name; this.age = age; this.print = print.bind(this);//每个 Person 对象共享同一个print 方法版本(方法有自己的作用域，不用担心变量被共享)&#125;var person = new Person(\"Mofan\",19); console.log(person.name+person.age);//Mofan19 person.print();//Mofan19 然而这样看起来很乱，也谈不上类的封装性。还是使用原型吧 第三种方式，纯原型模式，不管是属性还是方法都添加到原型里面去了，这样做好处是很省内存，但是应用范围就少了，更多的对象 内部的属性是需要定制的，而且一旦更改原型，所有这个原型实例都会跟着改变。因此可以结合构造函数方式来实现对对象的定制，于是就有了第四种方式——组合构造函数模式与原型模式，可以定制的放在构造器里，共有的放在原型里，这也符合构造器和原型的特性。 “这是es5中使用最广泛、认同度最高的创建自定义类型的方法”—《JavaScript高级程序设计》第三版 第五种方式，动态原型模式，出现这种方式是因为有些面向对象开发人员习惯了类构造函数，于是对这种独立出来的构造函数和原型感到困惑和不习惯。于是，就出现了把定义原型也写进构造函数里的动态原型模式。上面在动态原型模式程序里面讲“如果采用对象字面量对原型添加方法的话，第一次创建的对象将不会有这些方法”这是因为在if语句执行以前，第一个对象已经被创建了，然后执行if里面的语句，如果采用对象字面量给原型赋值，就会导致原型在实例创建之后被重写，创建的第一个实例就会失去与原型的链接，也就没有原型里的方法了。不过以后创建的对象就可以使用原型里的方法了，因为它们都是原型被修改后创建的。 原型是什么在JavaScript中，原型就是一个对象，没必要把原型和其他对象区别对待，只是通过它可以实现对象之间属性的继承。任何一个对象也可以成为原型。之所以经常说对象的原型，实际上就是想找对象继承的上一级对象。对象与原型的称呼是相对的，也就是说，一个对象，它称呼继承的上一级对象为原型，它自己也可以称作原型链下一级对象的原型。 一个对象内部的[[Prototype]]属性生来就被创建，它指向继承的上一级对象，称为原型。函数对象内部的prototype属性也是生来就被创建（只有函数对象有prototype属性），它指向函数的原型对象（不是函数的原型！）。当使用var instance = new Class();这样每new一个函数（函数被当做构造函数来使用）创建实例时，JavaScript就会把这个原型的引用赋值给实例的原型属性，于是实例内部的[[Prototype]]属性就指向了函数的原型对象，也就是prototype属性。 原型真正意义上指的是一个对象内部的[[Prototype]]属性，而不是函数对象内部的prototype属性，这两者之间没有关系！对于一个对象内部的[[Prototype]]属性，不同浏览器有不同的实现： 12345678910 var a = &#123;&#125;; //Firefox 3.6+ and Chrome 5+ Object.getPrototypeOf(a); //[object Object] //Firefox 3.6+, Chrome 5+ and Safari 4+ a.__proto__; //[object Object] //all browsers a.constructor.prototype; //[object Object] 之所以函数对象内部存在prototype属性，并且可以用这个属性创建一个原型，是因为这样以来，每new一个这样的函数（函数被当做构造函数来使用）创建实例，JavaScript就会把这个原型的引用赋值给实例的原型属性，这样以来，在原型中定义的方法等都会被所有实例共用，而且，一旦原型中的某个属性被定义，就会被所有实例所继承（就像上面的例子）。这种操作在性能和维护方面其意义是不言自明的。这也正是构造函数存在的意义（JavaScript并没有定义构造函数，更没有区分构造函数和普通函数，是开发人员约定俗成）。下面是一些例子： 1234567891011121314var a = &#123;&#125; //一个普通的对象function fun()&#123;&#125; //一个普通的函数//普通对象没有prototype属性console.log(a.prototype);//undefinedconsole.log(a.__proto__===Object.prototype);//true//只有函数对象有prototype属性console.log(fun.prototype);//Objectconsole.log(fun.__proto__===Function.prototype);//trueconsole.log(fun.prototype.__proto__===Object.prototype);//trueconsole.log(fun.__proto__.__proto__===Object.prototype);//trueconsole.log(Function.prototype.__proto__===Object.prototype);//trueconsole.log(Object.prototype.__proto__);//null 当执行console.log(fun.prototype);输出为可以看到，每创建一个函数，就会创建prototype属性，这个属性指向函数的原型对象（不是函数的原型），并且这个原型对象会自动获得constructor属性，这个属性是指向prototype属性所在函数的指针。而__proto__属性是每个对象都有的。 接着上面再看： 123456789101112function Person()&#123;&#125;//构造函数,约定首字母大写var person1 = new Person();//person1为Person的实例console.log(person1.prototype);//undefinedconsole.log(person1.__proto__===Person.prototype);//trueconsole.log(person1.__proto__.__proto__===Object.prototype);//trueconsole.log(person1.constructor);//function Person()&#123;&#125;//函数Person是Function构造函数的实例console.log(Person.__proto__===Function.prototype);//true//Person的原型对象是构造函数Object的实例console.log(Person.prototype.__proto__===Object.prototype);//true person1和上面那个普通的对象a有区别，它是构造函数Person的实例。前面讲过： 当使用var instance = new Class();这样每new一个函数（函数被当做构造函数来使用）创建实例时，JavaScript就会把这个原型的引用赋值给实例的原型属性，于是实例内部的[[Prototype]]属性就指向了函数的原型对象，也就是prototype属性。 因此person1内部的[[Prototype]]属性就指向了Person的原型对象，然后Person的原型对象内部的[[Prototype]]属性再指向Object.prototype，相当于在原型链中加了一个对象。通过这种操作，person1就有了构造函数的原型对象里的方法。 另外，上面代码console.log(person1.constructor);//function Person(){}中，person1内部并没有constructor属性，它只是顺着原型链往上找，在person1.__proto__里面找到的。 可以用下面这张图理清原型、构造函数、实例之间的关系： 继承JavaScript并没有继承这一现有的机制，但可以利用函数、原型、原型链模仿。下面是三种继承方式： 类式继承1234567891011121314151617181920212223//父类function SuperClass()&#123; this.superValue = \"super\";&#125;SuperClass.prototype.getSuperValue = function()&#123; return this.superValue;&#125;;//子类function SubClass()&#123; this.subValue = \"sub\";&#125;//类式继承,将父类实例赋值给子类原型，子类原型和子类实例可以访问到父类原型上以及从父类构造函数中复制的属性和方法SubClass.prototype = new SuperClass();//为子类添加方法SubClass.prototype.getSubValue = function()&#123; return this.subValue;&#125;//使用var instance = new SubClass();console.log(instance.getSuperValue);//superconsole.log(instance.getSubValue);//sub 这种继承方式有很明显的两个缺点： 实例化子类时无法向父类构造函数传参 如果父类中的共有属性有引用类型，就会在子类中被所有实例所共用，那么任何一个子类的实例更改这个引用类型就会影响其他子类实例,可以使用构造函数继承方式解决这一问题 构造函数继承1234567891011121314151617181920212223 //父类 function SuperClass(id)&#123; this.superValue = [\"big\",\"large\"];//引用类型 this.id = id; &#125; SuperClass.prototype.getSuperValue = function()&#123; return this.superValue; &#125;; //子类 function SubClass(id)&#123; SuperClass.call(this,id);//调用父类构造函数并传参 this.subValue = \"sub\"; &#125; var instance1 = new SubClass(10);//可以向父类传参 var instance2 = new SubClass(11); instance1.superValue.push(\"super\");console.log(instance1.superValue);//[\"big\", \"large\", \"super\"]console.log(instance1.id);//10console.log(instance2.superValue);[\"big\", \"large\"]console.log(instance2.id);//11console.log(instance1.getSuperValue());//error 这种方式是解决了类式继承的缺点，不过在代码的最后一行你也看到了，没有涉及父类原型，因此违背了代码复用的原则。所以组合它们： 组合继承123456789101112131415161718192021222324252627282930function SuperClass(id)&#123; this.superValue = [\"big\",\"large\"];//引用类型 this.id = id; &#125; SuperClass.prototype.getSuperValue = function()&#123; return this.superValue; &#125;; //子类 function SubClass(id,subValue)&#123; SuperClass.call(this,id);//调用父类构造函数并传参 this.subValue = subValue; &#125; SubClass.prototype = new SuperClass(); SubClass.prototype.getSubValue = function()&#123; return this.subValue; &#125; var instance1 = new SubClass(10,\"sub\");//可以向父类传参 var instance2 = new SubClass(11,\"sub-sub\"); instance1.superValue.push(\"super\"); console.log(instance1.superValue);//[\"big\", \"large\", \"super\"] console.log(instance1.id);//10 console.log(instance2.superValue);[\"big\", \"large\"] console.log(instance2.id);//11 console.log(instance1.getSuperValue());[\"big\", \"large\", \"super\"] console.log(instance1.getSubValue());//sub console.log(instance2.getSuperValue());//[\"big\", \"large\"] console.log(instance2.getSubValue());//sub-sub 嗯，比较完美了，但是有一点，父类构造函数被调用了两次，这就导致第二次调用也就是创建实例时重写了原型属性，原型和实例都有这些属性，显然性能并不好。先来看看克罗克福德的寄生式继承： 12345678910111213141516171819 function object(o)&#123; function F()&#123;&#125;; F.prototype = o; return new F(); &#125; function createAnnther(original)&#123; var clone = object(original); clone.sayName = function()&#123; console.log(this.name); &#125; return clone; &#125; var person = &#123; name:\"Mofan\", friends:[\"xiaoM\",\"Alice\",\"Neo\"], &#125;; var anotherPerson = createAnnther(person); anotherPerson.sayName();//\"Mofan\"&#125; 就是让一个已有对象变成新对象的原型，然后再在createAnother函数里加强。你也看到了，person就是一个普通对象，所以这种寄生式继承适合于根据已有对象创建一个加强版的对象，在主要考虑通过已有对象来继承而不是构造函数的情况下，这种方式的确很方便。但缺点也是明显的，createAnother函数不能复用，我如果想给另外一个新创建的对象定义其他方法，还得再写一个函数。仔细观察一下，其实寄生模式就是把原型给了新对象，对象再加强。 等等，写到这个地方，我脑子有点乱，让我们回到原点：继承的目的是什么？应该继承父类哪些东西？我觉得取决于我们想要父类的什么，我想要父类全部的共有属性（原型里）并且可以自定义继承的父类私有属性（构造函数里）！前面那么多模式它们的缺点主要是因为这个： 1SubClass.prototype = new SuperClass(); 那为什么要写这一句呢？是只想要继承父类的原型吗？如果是为什么不这么写： 1SubClass.prototype = SuperClass.prototype; 这样写是可以继承父类原型，但是风险极大：SuperClass.prototype属性它是一个指针，指向SuperClass的原型，如果把这个指针赋给子类prototype属性，那么子类prototype也会指向父类原型。对SubClass.prototype任何更改，就是对父类原型的更改，这显然是不行的。 寄生组合式继承但出发点没错，可以换种继承方式，看看上面的寄生式继承里的object()函数，如果把父类原型作为参数，它返回的对象实现了对父类原型的继承，没有调用父类构造函数，也不会对父类原型产生影响，堪称完美。 12345678910111213141516171819202122232425262728293031323334353637383940function object(o)&#123; function F()&#123;&#125;; F.prototype = o; return new F(); &#125;function inheritPrototype(subType,superType)&#123; var proto = object(superType.prototype); proto.constructor = subType;//矫正一下construcor属性 subType.prototype = proto; &#125; function SuperClass(id)&#123; this.superValue = [\"big\",\"large\"];//引用类型 this.id = id; &#125; SuperClass.prototype.getSuperValue = function()&#123; return this.superValue; &#125;; //子类 function SubClass(id,subValue)&#123; SuperClass.call(this,id);//调用父类构造函数并传参 this.subValue = subValue; &#125; inheritPrototype(SubClass,SuperClass);//继承父类原型 SubClass.prototype.getSubValue = function()&#123; return this.subValue; &#125; var instance1 = new SubClass(10,\"sub\");//可以向父类传参 var instance2 = new SubClass(11,\"sub-sub\"); instance1.superValue.push(\"super\"); console.log(instance1.superValue);//[\"big\", \"large\", \"super\"] console.log(instance1.id);//10 console.log(instance2.superValue);//[\"big\", \"large\"] console.log(instance2.id);//11 console.log(instance1.getSuperValue());//[\"big\", \"large\", \"super\"] console.log(instance1.getSubValue());//sub console.log(instance2.getSuperValue());//[\"big\", \"large\"] console.log(instance2.getSubValue());//sub-sub 解决了组合继承的问题，只调用了一次父类构造函数，而且还能保持原型链不变，为什么这么说，看对寄生组合的测试： 12console.log(SubClass.prototype.__proto__===SuperClass.prototype);//ture console.log(SubClass.prototype.hasOwnProperty(\"getSuperValue\"));//false 因此，这是引用类型最理想的继承方式。 总结创建用于继承的对象最理想的方式是组合构造函数模式和原型模式（或者动态原型模式），就是让可定义的私有属性放在构造函数里，共有的放在原型里；继承最理想的方式是寄生式组合，就是让子类的原型的[[prototype]]属性指向父类原型，然后在子类构造函数里调用父类构造函数实现自定义继承的父类属性。 JavaScript对象总有一些让我困惑的地方，不过我还会继续探索。我在此先把我了解的记录下来，与各位共勉。错误的地方请费心指出，我将感谢您的批评指正。 本文为作者原创，转载请注明本文链接，作者保留权利。 参考文献：[1] http://www.cnblogs.com/chuaWeb/p/5039232.html[2] http://www.cnblogs.com/xjser/p/4962821.html[3] https://javascriptweblog.wordpress.com/2010/06/07/understanding-javascript-prototypes/","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://realtcg.com/tags/JavaScript/"},{"name":"JavaScript对象","slug":"JavaScript对象","permalink":"http://realtcg.com/tags/JavaScript对象/"}]},{"title":"今天我20岁","date":"2017-03-08T15:37:45.000Z","path":"2017/03/08/20/","text":"今天，我来到地球整整20年了。 本来还想大过一回，好好庆祝一下，但想想《好先生》里陆远说的那句话：“男人需要一辈子来成熟”也就作罢了。可今天毕竟是意义非凡的一天，所以我决定在今天把这些天我想说的话，我心里的话都写下来，以后多少有个纪念。 20岁了，不是十几岁了，想想都觉得可怕，想想都觉得时间过的飞快。以前还在想:我什么时候才能到20岁，我20多岁会是什么样子。喏，这不就20岁了么。 上了大学以来，可以说我的心态和三观发生了不小的变化，自己也默默承受着变化带来的副作用。也不跟人说，跟谁说呢？跟父母说？让他们担心你？跟远方的好朋友说？算了，没多大事，跟周围的人说？别开玩笑了，我可说不出口，他们也没兴趣听。还是憋在心里慢慢消化吧.. 梦想20岁，还年轻，不过我急于证明自己，想尽快有所成就，不再依靠父母，早日让他们享福。所以我大一就想好了不读研，大学毕业尽快工作。先让这个家庭富裕起来，再去实现我的梦想吧。有时候觉得一个人的发展很多受家庭的影响:就像我的家庭并不富裕，而且在整个家族里都是最不富裕的，我就想长大挣大钱，先过上富裕的生活，再做自己想做的事。尤其这两年，我见识外面精彩的世界越多，我就越向往，然后就越来越感到与现实的差距，这种差距感不断地督促我，加快我朝着梦想的步伐。 20岁，我一无所有，却想要一切。 所以我对自己的要求越来越严格，越来越自律。不打游戏，不看剧，不出去浪，甚至连谈恋爱都觉得是奢望。每天看书，敲代码，清心寡欲，干一点别的事都觉得有愧疚感。没事，哪怕我舍弃别的东西，我学有所成也行啊，至少有一件事做成了也能给我安慰啊。然而事情总是不像我想象的那样好，有时候光靠努力是不行的，还要有方法、运气、效率… 我最害怕的就是，我舍弃了别的东西，还没弄好一直投入精力去做的事情。 所以每当我学习不顺的时候，我的心情就糟糕到了极点。原本我可以花时间多交几个朋友，我们一起吃饭，一起出去玩，一起打球，放假一块出去旅游;说不定我还会遇到我生命中的那个她，我们互相爱着对方，照顾对方，给予对方心灵的慰藉和归属感，一起享受和对方快乐美好的时光…这才是我心目中的那个青春。 可是我总是强行打破幻想:度过了这些快乐时光之后呢？你是快乐了四年，你是有了一个美好的青春，可你拿什么养活自己？你拿什么支撑自己的梦想？你忘了你的家庭情况了吗？ 没办法，生活就是这样，时间就那么多，我必须做出选择，必须懂得舍得。 “要好身材就得保持锻炼，要身体健康就要注意饮食，想多看书就得放弃其它时间。其它的也一样，要安逸就不要羡慕动荡，管不住嘴就得接受体重。其实无论过什么样的生活都要付出代价，或者是牺牲一些别的什么。没那么多两全其美的事，选择归根结底都是考验你是否能为了你所坚持的去背负那些代价。” 我强烈感觉我现在处在这样一种情况:我努力，我就能得到我想要的生活，它近在咫尺;我苟活，我只能碌碌无为，随遇而安。也许大学就是这样，你有无限可能，这也可能正是大学毕业后每个人的发展差距很大的原因。 我选择在这个时候朝着我的梦想前进，我选择为之付出大部分的精力，必要时我会全身心投入，我选择舍弃一些做其他事情的时间和精力。我问过自己的内心，实现梦想，才是我真正想要的。 可有时候，那些你忽略的东西也很重要，我现在也逐渐地意识到了。以前忽略它们，是因为太年轻，没有意识到。它们就是亲情，友情，人际关系，待人处世、团队合作、组织、表达的能力… 忽略它们给我带来了许多不好的后果，例如在做项目的时候，整天想的都是项目的事情，走路想，吃饭想，上课想，每天还一副忧心忡忡、严肃的样子，忽略了好多人好多事，忽略了人际交往。久而久之，人家就觉得你这个人是不是真的性格内向，不好相处，也就不跟你相处了(其实我老好相处了心塞(´-ωก`))。这样的事还有很多。 所以啊，我应该尽量平衡好学习和生活以及人际交往冲突的地方，再忙也不忘生活。这也是一种重要的能力。 迷茫到选择20岁，面临越来越多的选择，我内心很挣扎，仿佛20岁所做的每个决定，都会对未来产生重大影响。 20岁了，不能任性了，今后所做的任何事都要有所考虑，所做的任何选择都要慎重。因为过了20，我已经没有可以浪费的资本了。或许正是我觉得选择要慎重，我用了整整一年的时间想清楚我到底是读研、出国还是工作，用了一年时间去发现我今后到底要从事什么样的工作。选择初期，我内心很挣扎，因为我真的不清楚我选那条路好。有时候，看到什么心动的东西，或者前辈们的几句话，或者有感触的事就忽然做出选择，但过一段时间后，又开始怀疑这个选择，进而又回到了原点…有时挣扎到深处，甚至开始思考一些更”底层””的问题: 人生的意义是什么？我该活出什么样子？… 后来，我还是做出了选择，”Follow my heart”，接受我自己。 追随我的心，接受我自己。可能没有其他的路好，但我肯定不会后悔，还会因此感到快乐和安心。 烦恼总有一段时间感觉生活好没意思。每天起床，吃饭，没精打采的上课，下课，吃饭，上课，下课，回来敲代码…更重要的是，那个时候我什么都不想做，什么都不感兴趣。我有时候都羡慕室友，天天打游戏也不烦，还快快乐乐，至少能有一个爱好，找点乐子，消磨消磨时间。我有什么爱好啊？天呐，我都不知道我有什么爱好。或许正是因为我清心寡欲，没什么爱好，我才老是觉得生活没有什么意思，才老是思考人生的意义到底是什么。 总有一段时间，感到很孤独，莫名的孤独，突然的孤独。感觉自己没有一个知心的朋友，没有可以倾诉的人。我开始越来越喜欢听伤感的歌，听的时候一边伤感，一边疗伤，也算是发泄了。长大了，烦恼多了，却少了可以倾诉的人，自己也不想倾诉了。我觉得以前的我很开心，我没有烦恼，我喜欢的人和我的朋友都在身边，最重要的是，那时我擅长自娱。现在我好像变得多愁善感了，变得敏感了，变得沉默了。我身边好像少了一些东西，生活没有那么精彩丰富了。也许我睡一觉就不那么觉得了，但是我肯定还会感到孤独，在某个时候。这一年我在外面过得并不开心。 不过我还是想到了一些方法来消解郁闷，简单但有效果的方法就是跑步！ 我发现我跑步的时候，心里面很平静，再听着歌，内心就更加放松。我很喜欢晚上跑到筋疲力竭的时候，边听歌边走在跑道上，四周无人，尽情地放松我自己…这对我来说的确是一种非常有效果的发泄方式，每次跑完回来后，我的步伐就会变得更加坚定，内心照样如此。我想我会坚持下去的，因为我喜欢跑步时和跑步后的那种释放的感觉。跑步给我带来的不仅是身体上的健康，最重要的是让我的心态逐渐变得阳光，自信。 向往的生活哈哈，我向往有一天，我和我的家庭在欧洲或者美国的某个风景美丽的小镇定居了下来，我们有一个不大不小但温馨漂亮的房子，房子有一片绿地，还有菜园。我和我的爱人有两个可爱的孩子，一男一女，还有一只狗狗。我做着我喜欢的工作，我妻子专心地照顾家庭，孩子们接受着最好的教育。每天我们互道早安晚安，一起吃饭，每到周末，我们一起驾着车出去郊游，我们和孩子们还有狗狗尽情地玩耍…哈哈哈哈哈哈 先写这么多！晚安~","tags":[{"name":"感想","slug":"感想","permalink":"http://realtcg.com/tags/感想/"}]}]